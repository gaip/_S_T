%?class	llbasic
%?version 00045

%?library llsystem
(llsystem.ps) run


% Global variables used in this library

% hidden Global variables used in this library
/MDfirstActIndex 0 def		% erster Message-Index der angezeigt wird
/MXmsgShowTop true def		% wird aktuelle gerade immer die neueste Messages angezeigt (erste Seite)
/MXscrollOnMsgSym false def	% Position der Dreh-Drückazswahl steht auf dem Symbol der Message-Seite
/MDmsgScrollCounter 1 def	% Nummer der aktiven Dreh-Drück-Message
/MXdispRunning false def	% Zeitverlauf des Trenddisplay läuft
/MDtdFactX 1 def				% Zoomfactor für die Zeitachse X des Trenddisplay
/MXtouchInp002CapsLock false def	% caps lock des touchInput002 part aktiviert
/MXfailureBeep false def	% eine Einzelbeep soll angesteuert werden, wenn eine Fehleingabe am touch erfolgte
/testsys_timeout	0	def		% timeout value for testsystem button

/MDbeepVolume			100 def		%?brief Lautstärke des Monitor Lautsprechers	%?type DINT %?dflt    100
/MDfreqBeepOne			1200 def	%?brief Frequenz Einzelbeep 					%?type DINT %?dflt    1200
/MDfreqBeepFailure		100 def		%?brief Frequenz Einzelbeep Fehlbedienung		%?type DINT %?dflt    100
/MDtimeBeepOne			600 def		%?brief Zeit Einzelbeep [ms						%?type DINT %?dflt    600
/MDfreqBeepOn			900 def		%?brief Frequenz Felherbeep Hoch				%?type DINT %?dflt    900
/MDfreqBeepOff			0 def		%?brief Frequenz Fehlerbeep Nieder				%?type DINT %?dflt    0
/MDtimeBeepOn			650 def		%?brief Zeit Fehlerbeep Hoch					%?type DINT %?dflt    650
/MDtimeBeepOff			650 def		%?brief Zeit Fehlerbeep Nieder					%?type DINT %?dflt    650
/MDfreqBeepLmlWarnOn	500 def		%?brief Frequenz LMB Warnung Hoch				%?type DINT %?dflt    500
/MDfreqBeepLmlWarnOff	0 def		%?brief Frequenz LMB Warnung Nieder				%?type DINT %?dflt    0
/MDfreqBeepLmlStopOn	1000 def	%?brief Frequenz LMB Stop Hoch					%?type DINT %?dflt    1000
/MDfreqBeepLmlStopOff	0 def		%?brief Frequenz LMB Stop Nieder				%?type DINT %?dflt    0
/MDtimeBeepLmlWarnOn	150 def		%?brief Zeit LMB Warnung Hoch					%?type DINT %?dflt    150
/MDtimeBeepLmlWarnOff	900 def		%?brief Zeit LMB Warnung Nieder					%?type DINT %?dflt    900
/MDtimeBeepLmlStopOn	500 def		%?brief Zeit LMB Stop Hoch						%?type DINT %?dflt    500
/MDtimeBeepLmlStopOff	200 def		%?brief Zeit LMB Stop Nieder					%?type DINT %?dflt    200


% *********************************************************************************************************************
% Definition von Unterfunktionen
% *********************************************************************************************************************

% set color by number
%!proc sp_set_color
%?subproc
/sp_set_color {
	/idColNum	exch	def
	idColNum -1 eq { Invisible } if
	idColNum 0 eq { Neutral } if
	idColNum 1 eq { Green } if
	idColNum 2 eq { Blue } if
	idColNum 3 eq { Yellow } if
	idColNum 4 eq { Red } if
	idColNum 5 eq { Grey } if
	idColNum 6 eq { LightGrey } if
	idColNum 7 eq { DarkGreen } if
	idColNum 8 eq { Orange } if
	idColNum 9 eq { Brown } if
	idColNum 10 eq { LightBlue } if
	idColNum 11 eq { White } if
	idColNum 12 eq { DarkGrey } if
	idColNum 13 eq { Black } if
} def

% Zeigt einen Messagetext mit variabler Zeilenanzahl auf dem Bildschirm (setzt den Cursor wieder an den Ausgangspunkt)
%!proc sp_showMsgVar
%?subproc
/sp_showMsgVar {
	/LI_xPix	exch	def			% maximale Länge einer Zeile in pixel
	/LI_zeilen	exch	def			% Anzahl der anzuzeigenden Zeilen
	/LI_text	exch	def			% Anzuzeigender Text

	/LDhightStep strhl def
	/LDlineCount 1 def

	matrix currentmatrix
	currentpoint translate

	LI_text LI_xPix LI_zeilen splitstring
	{
		0 LDhightStep LDlineCount mul moveto
		show_utf8				% Zeile einblenden
		LDlineCount LI_zeilen ge { exit } if
		/LDlineCount LDlineCount 1 add store
	} loop
	0 0 moveto
	setmatrix
} def


% Berechnet die Anzahl der Vor- und der Nachkommastellen anhand des Übergebenen Codes, und ermittelt die Zahlenlänge vor dem Komma in Pixel
%!proc sp_getDigitInfo
%?subproc
/sp_getDigitInfo {
	/LI_digits	exch	def			% Kommacode für die Anzeige
	/LI_Value	exch	def			% Zahlenwert
	/LO_riDig	1	def				% Anzahl Stellen nach dem Komma
	/LO_leDig	1	def				% Anzahl Stellen vor dem Komma
	/LO_leLen	1	def				% Länge der Anzeige vor dem Komma
	/LS_helps 	()	def				% String definieren

	% Anzuzeigende Kommastellen ermitteln
	LI_digits abs cvi
	/LO_leDig exch store							% Vorkommastellen speichern
	LI_digits LO_leDig sub							% Nachkommastellen ermitteln
	10 mul abs cvi dup 2 gt { pop 2 } if			% Nachkommastellen: Zahl aufbereiten und auf 2 beschränken
	/LO_riDig exch store							% Nachkommastellen speichern

	% Kontrolle wie lange die Zahl links des Komma ist, ACHTUNG ncvs rundet eventuell 9.99 auf 10.00
	LO_riDig 0 eq { LI_Value round } if
	LO_riDig 1 eq { LI_Value 10 mul round 10 div } if
	LO_riDig 2 ge { LI_Value 100 mul round 100 div } if
	dup 0 lt 1 index -1 gt and { pop -1 } { cvi } ifelse			% gerunderter Zahl das Komma abschneiden damit nur der Werte links des Komma übrigbleibt, bei einer Zahl zwischen 0 und -1 muß das "-" durch "10 mul" mitplatziert werden, da nach cvi 0 herauskommt, und NULL kein Vorzeichen hat
	LS_helps 0 ncvs									% Zahl in string umwandeln um die Länge zu ermitteln
	strw
	/LO_leLen exch store

	LO_riDig LO_leDig LO_leLen
	
} def

% Berechnet die maximale Länge einer Zahl aufgrund des angegebenen Dezimalcodes
%!proc sp_getNumMaxLen
%?subproc
/sp_getNumMaxLen {
	/LI_digits	exch	def			% Kommacode für die Anzeige
	/LO_Len		1		def			% Länge der Anzeige

	/LS_helps 	()	def				% String definieren
	
	8.88 LS_helps
	0 LI_digits sp_getDigitInfo pop
	exch nncvs strw
	/LO_Len exch store
	LO_Len
} def

% Berechnet die Anzahl der Kommastellen eines übergebenen Wertes
%!proc sp_getDeciPoint
%?subproc
/sp_getDeciPoint {
	/LI_Value	exch	def			% zu analysierender Wert
	/LO_rightDigit	1	def			% Anzahl Stellen nach dem Komma

	/LR_help 0 def

	LI_Value dup cvi sub
	/LR_help exch store
	LR_help 0 eq {
		/LO_rightDigit 0 store
	} {
		LR_help 10 mul cvi 0 eq {						% 0.01...0.09
			/LO_rightDigit 2 store
		} {
			LR_help 10 mul cvi LR_help 10 mul eq {		% 0.1, 0.2, 0.3, ... 0.9
				/LO_rightDigit 1 store
			} {
				/LO_rightDigit 2 store
			} ifelse
		} ifelse
	} ifelse
	LO_rightDigit
} def

% sp_scaleProc
% Skaliert den gewünschten Wert in die Anzeige
% Stackübergabe: Anzeigelänge, Anzeigeanfang, Anzeigeende, Wert (z.B.: YbarLen, YbarMin, YbarMax, Yvalue)
% Stackrückgabe: Skalierter Wert
%!proc sp_scaleProc
%?subproc
/sp_scaleProc {
	/Li_value exch def
	/Li_maxValue exch def
	/Li_minValue exch def
	/Li_BarLenPxl exch def
	/Lq_ValuePxl 0 def
	
	Li_maxValue 0 ge {
		Li_maxValue Li_value lt {
			/Lq_ValuePxl Li_BarLenPxl store
		} {
			Li_value Li_minValue lt {
				/Lq_ValuePxl 0 store
			} {
				Li_value Li_minValue sub
				Li_maxValue Li_minValue sub div
				Li_BarLenPxl mul
				/Lq_ValuePxl exch store
			} ifelse
		} ifelse
	} {
		Li_value Li_maxValue lt {
			/Lq_ValuePxl Li_BarLenPxl store
		} {
			Li_value Li_minValue gt {
				/Lq_ValuePxl 0 store
			} {
				Li_value Li_minValue sub
				Li_maxValue Li_minValue sub div
				Li_BarLenPxl mul
				/Lq_ValuePxl exch store
			} ifelse
		} ifelse
	} ifelse
	Lq_ValuePxl
} def

% Zeichnet die Skala zu einem Balken (auf der rechten Seite)
%!proc sp_drawScale001
%?subproc
/sp_drawScale001 {
	/LX_scaleLeft	exch	def		% Skalierung soll nach links zeigen
	/LI_deciNum	exch	def			% Anzahl der Kommastellen des Textes der Skalierung
	/LD_txtAngle	exch	def		% Winkel des Textes (um eventuelle Globale Drehungen zu korrigieren)
	/LX_fineScale	exch	def		% Fine-Skalierung eingeschalten
	/LI_fields	exch	def			% Anzahl Skalierungsfelder
	/LD_maxVal	exch	def			% maximaler Balkenwert in der Einheit
	/LD_minVal	exch	def			% minimaler Balkenwert in der Einheit
	/LI_maxBar	exch	def			% maximaler Balkenwert in Koordinaten

	% Interne Variablen
	/LI_scaleDist	5	def			% Abstand der Skalierung zum Balken
	/LI_scaleLen	5	def				% Länge der Skalierungsstriche
	/LI_scaleLenFine	2	def			% Länge der Skalierungsstriche der Fine-Skalierung
	/LS_helps	() def				% String definieren
	/LI_fieldNum	0 def				% Variable für die Anzahl der Skalierungsfelder anlegen
	/LI_fieldstep 0 def				% Variable für die Größe des Skalierungsschrittes in Koordinaten				
	/LI_fieldstepNum 0 def			% Variable für die Größe des Skalierungsschrittes in Einheit
	/LI_actY	0	def
	/LS_text	()	def
	
	% setze Var für andere Berechnung des Drehpunktes für die Skalenbeschriftung
	/LXvertBar LD_txtAngle 45 lt LD_txtAngle -45 gt LD_txtAngle 315 gt or and LD_txtAngle 135 gt LD_txtAngle 225 lt and LD_txtAngle -135 lt LD_txtAngle -225 gt and or or def


	% diverse Vorgaben negieren, wenn sie nach links gezeichnet werden sollen
	LX_scaleLeft {
		/LI_scaleDist LI_scaleDist neg store
		/LI_scaleLen LI_scaleLen neg store
		/LI_scaleLenFine LI_scaleLenFine neg store
	} if
	% Skalierung zeichnen
	0 0 moveto
	0 LI_maxBar lineto stroke				% Balkengrundlinie zeichnen
	0 0 moveto
	LI_scaleLen 0 lineto stroke				% Nullinie zeichnen
	LI_maxBar LI_fields div
	/LI_fieldstep exch store			% Länge eines Skalierungsfeldes in Koordinaten berechnen
	% Beschriftung errechnen
	LD_maxVal LD_minVal sub
	LI_fields div
	/LI_fieldstepNum exch store
	/LI_fieldNum LD_minVal store		% ersten Anzeigewert speichern

	% 1. Beschriftungspunkt
	matrix currentmatrix
	LI_fieldNum LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
	/LS_text exch store
	LI_scaleLen LI_scaleDist add			% X-Wert auf den Textanfang setzen
	LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
	LX_scaleLeft { neg } if add
	0								% Y-Wert ist 0: Drehpunkt für den Text ist also beim Skalenstrich
	translate						% Ursprung dorthin setzen um zu rotieren
	LD_txtAngle rotate				% System drehen
	LS_text strwh					% Länge und Höhe des string ermitteln
	exch 2 div neg					% Länge halbieren und invertieren
	exch 2 div neg					% Höhe halbieren und invertieren
	moveto							% zum Textursprung springen
	LS_text show_utf8				% text ausgeben
	setmatrix

	/LI_actY 0 store					% aktuellen Y-Wert für die Schleife definieren
	LI_fields {						% Skalierungsschritt-Anzahl für die Schleife auf den Stack legen (Bisher nur position 0 gezeichnet)
		LI_fieldNum LI_fieldstepNum add
		/LI_fieldNum exch store		% Variable Anzeigewert laden
		LI_actY LI_fieldstep add		% aktueller y-Wert erhöhen
		/LI_actY exch store			% y-Wert für den nächsten Schleifendurchlauf speichern
		
		0 LI_actY moveto
		LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
		% Beschriftung
		matrix currentmatrix
		LI_fieldNum LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY					% Textmitte (x und y) definieren
		translate					% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate			% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg				% Höhe halbieren und invertieren
		moveto						% zum Textursprung springen
		LS_text show_utf8						% text ausgeben
		setmatrix

		% Fine-Skalierung zeichnen
		LX_fineScale {
			LI_actY					% y-Wert für die FineScale-Schleife auf den stack legen
			9 {
				LI_fieldstep 10 div	% Skalierungsschritt der FineScale in Koordinaten berechnen
				sub					% um den Fine-Skalierungsschritt vom letzte Y-Wert nach unten springen
				dup					% y-Wert für den nächsten Schleifendurchlauf auf den Stack verdoppeln
				0 exch moveto
				LI_scaleLenFine 0 rlineto stroke			% FineScale zeichnen
			} repeat
			pop						% letzten y-Wert der Fine-Skalierung vom Stack poppen
		} if
	} repeat
	stroke
} def

% Zeichnet eine Skala wie beim Zeigerdisplay zu einem Balken (auf der rechten Seite)
%!proc sp_drawScale002
%?subproc
/sp_drawScale002 {
	/idColorHigh	exch	def				% Farbe für den obersten Warnbereich: 0=neutral, 1=grün, 2=blau, 3=gelb, 4=rot, 5=grau, 6= hellgrau
	/idColorLow		exch	def				% Farbe für den untersten Warnbereich: 0=neutral, 1=grün, 2=blau, 3=gelb, 4=rot, 5=grau, 6= hellgrau
	/idColor		exch	def				% Farbe für den mittleren Skalenbereich: 0=neutral, 1=grün, 2=blau, 3=gelb, 4=rot, 5=grau, 6= hellgrau
	/idDesign		exch	def				% Design des Zeigersdisplays
	/ixScaleActive	exch	def				% Skala aktiviert
	/ixScaleLeft	exch	def				% Skalierung soll nach links zeigen
	/irTxtAngle		exch	def				% Winkel des Textes (um eventuelle Globale Drehungen zu korrigieren)
	/ixFineScale	exch	def				% Fine-Skalierung eingeschalten
	/idDeciNum		exch	def				% Anzahl der Kommastellen des Textes der Skalierung
	/idFields		exch	def				% Anzahl der Skalierungsfelder (kann auch eine Kommazahl sein, d.h. die Skala wird mit kleiner Skalierung ohne Beschriftung weitergeführt)
	/irHigherWarn	exch	def				% Wert oberer Farbumschlag
	/irLowerWarn	exch	def				% Wert unterer Farbumschlag
	/irMaxVal		exch	def				% maximaler Balkenwert in der Einheit
	/irMinVal		exch	def				% minimaler Balkenwert in der Einheit
	/irMaxBar		exch	def				% maximaler Balkenwert in Koordinaten

	% Interne Variablen	
	/LI_Design idDesign def				% Design des Zeigersdisplays
	/LD_Linewidth 1 def
	/LI_lineDist 5 def
	/LI_scaleDist 7 def
	/LI_scaleLen 5 def
	/LI_scaleLenFine 2 def
	/LD_lowChange 0 def
	/LD_highChange 0 def
	/LS_helps	() def				% String definieren
	/LI_fieldNum	0 def			% Variable für die Anzahl der Skalierungsfelder anlegen
	/LI_fieldstep 0 def				% Variable für die Größe des Skalierungsschrittes in Koordinaten				
	/LI_fieldstepNum 0 def			% Variable für die Größe des Skalierungsschrittes in Einheit
	/LI_actY	0	def

	idDesign 10 gt {
		/LI_Design idDesign 10 sub store
	} if

	% diverse Vorgaben setzen (negieren, wenn sie nach links gezeichnet werden sollen)
	LI_Design 1 eq {
		/LD_Linewidth 3 store
		/LI_lineDist 2 store
		/LI_scaleDist 5 store
		/LI_scaleLen 5 store
		/LI_scaleLenFine 2 store
	} if
	LI_Design 2 eq {
		/LD_Linewidth 5 store
		/LI_lineDist 3 store
		/LI_scaleDist 8 store
		/LI_scaleLen 5 store
		/LI_scaleLenFine 2 store
	} if
	LI_Design 3 eq {
		/LD_Linewidth 7 store
		/LI_lineDist 4 store
		/LI_scaleDist 10 store
		/LI_scaleLen 5 store
		/LI_scaleLenFine 2 store
	} if
	ixScaleLeft {
		/LI_lineDist LI_lineDist neg store
		/LI_scaleDist LI_scaleDist neg store
		/LI_scaleLen LI_scaleLen neg store
		/LI_scaleLenFine LI_scaleLenFine neg store
	} if
	irLowerWarn irMinVal gt {
		irLowerWarn irMinVal sub irMaxBar mul irMaxVal irMinVal sub div
		/LD_lowChange exch store
	} if
	irHigherWarn irMaxVal lt {
		irHigherWarn irMinVal sub irMaxBar mul irMaxVal irMinVal sub div
		/LD_highChange exch store
	} if

	% Balkengrundlinie zeichnen
	LD_Linewidth setlinewidth
	0 setlinecap

	% mittlerer Skalenbereich
	currentcolor
	idColor sp_set_color
	LI_lineDist LD_lowChange moveto
	LI_lineDist LD_highChange lineto
	stroke
	setcolor

	% unterer Skalenbereich
	currentcolor
	irLowerWarn irMinVal gt {
		idColorLow sp_set_color
		LI_lineDist 0 moveto
		LI_lineDist LD_lowChange lineto
		stroke
	} if
	setcolor
	
	% oberer Skalenbereich
	currentcolor
	irHigherWarn irMaxVal lt {
		idColorHigh sp_set_color
		LI_lineDist LD_highChange moveto
		LI_lineDist irMaxBar lineto
		stroke
	} if
	setcolor

	% Trennstriche im Skalenbereich
	idDesign 10 gt {
		matrix currentmatrix
		currentcolor
		Invisible
		3 setlinewidth
		irMaxBar idFields div
		/LI_fieldstep exch store			% Länge eines Skalierungsfeldes in Koordinaten berechnen
		/LI_actY 0 store					% aktuellen Y-Wert für die Schleife definieren
		idFields 1 sub {					% Skalierungsschritt-Anzahl für die Schleife auf den Stack legen (Bisher nur position 0 gezeichnet)
			LI_actY LI_fieldstep add		% aktueller y-Wert erhöhen
			/LI_actY exch store				% y-Wert für den nächsten Schleifendurchlauf speichern
			0 LI_actY moveto
			ixScaleLeft { LD_Linewidth neg 0 rlineto }		% Skalierungstrich zeichnen
			{ LD_Linewidth 0 rlineto } ifelse
			stroke
		} repeat
		setcolor
		setmatrix
	} if
	1 setlinewidth
	1 setlinecap
	
	% Skalierung zeichnen
	ixScaleActive {
		LI_scaleDist 0 translate
		0 0 moveto
		LI_scaleLen 0 lineto stroke			% Nullinie zeichnen
		irMaxBar idFields div
		/LI_fieldstep exch store			% Länge eines Skalierungsfeldes in Koordinaten berechnen
		% Beschriftung errechnen
		irMaxVal irMinVal sub
		idFields div
		/LI_fieldstepNum exch store
		/LI_fieldNum irMinVal store		% ersten Anzeigewert speichern
	
		% 1. Beschriftungspunkt
		matrix currentmatrix
		LI_scaleLen LI_scaleDist add 0	% Textanfang (x) und Textmitte (y) definieren
		translate						% Ursprung dorthin setzen um zu rotieren
		irTxtAngle rotate				% System drehen
		LI_fieldNum LS_helps idDeciNum ncvs	% Anzeigewert in String umwandeln
		dup strwh						% Länge und Höhe des string ermitteln
		ixScaleLeft {
			exch neg					% Breite negieren, da der Ursprung nach links versetzt werden muss
		} {
			exch pop 0					% Breite vom stack poppen und durch NULL ersetzen
		} ifelse
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		show_utf8							% text ausgeben
		setmatrix
	
		/LI_actY 0 store					% aktuellen Y-Wert für die Schleife definieren
		idFields {						% Skalierungsschritt-Anzahl für die Schleife auf den Stack legen (Bisher nur position 0 gezeichnet)
			LI_fieldNum LI_fieldstepNum add
			/LI_fieldNum exch store		% Variable Anzeigewert laden
			LI_actY LI_fieldstep add		% aktueller y-Wert erhöhen
			/LI_actY exch store			% y-Wert für den nächsten Schleifendurchlauf speichern
			
			0 LI_actY moveto
			LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
			% Beschriftung
			matrix currentmatrix
			LI_scaleLen LI_scaleDist add LI_actY	% Textanfang (x) und Textmitte (y) definieren
			translate					% Ursprung dorthin setzen um zu rotieren
			irTxtAngle rotate			% System drehen
			LI_fieldNum LS_helps idDeciNum ncvs	% Anzeigewert in String umwandeln
			dup strwh					% Länge und Höhe des string ermitteln
			ixScaleLeft {
				exch neg				% Breite negieren, da der Ursprung nach links versetzt werden muss
			} {
				exch pop 0				% Breite vom stack poppen und durch NULL ersetzen
			} ifelse
			exch 2 div neg				% Höhe halbieren und invertieren
			moveto						% zum Textursprung springen
			show_utf8						% text ausgeben
			setmatrix
	
			% Fine-Skalierung zeichnen
			ixFineScale {
				LI_actY					% y-Wert für die FineScale-Schleife auf den stack legen
				9 {
					LI_fieldstep 10 div	% Skalierungsschritt der FineScale in Koordinaten berechnen
					sub					% um den Fine-Skalierungsschritt vom letzte Y-Wert nach unten springen
					dup					% y-Wert für den nächsten Schleifendurchlauf auf den Stack verdoppeln
					0 exch moveto
					LI_scaleLenFine 0 rlineto stroke			% FineScale zeichnen
				} repeat
				pop						% letzten y-Wert der Fine-Skalierung vom Stack poppen
			} if
		} repeat
		stroke
	} {
		idDesign 10 le {
			ixScaleLeft {
				LI_lineDist LD_Linewidth sub dup
			} {
				LI_lineDist LD_Linewidth add dup
			} ifelse
			0 moveto
				irMaxBar lineto
			stroke
		} if
	} ifelse
} def


% Zeichnet die Skala zu einem Balken wie sp_drawScale001 jedoch mit einstellbarer FineScale und Sichtbarkeit der numerischen Werte der Skala
%!proc sp_drawScale003
%?subproc
/sp_drawScale003 {
	/LX_fineScaleLenBig	exch	def		% Fine-Skalierungsfelder sollen gleich lang sein wie die der groben Skalierung
	/LX_showNumScale	exch	def		% numerische Skalierung soll angezeigt werden
	/LX_scaleLeft	exch	def		% Skalierung soll nach links zeigen
	/LI_deciNum	exch	def			% Anzahl der Kommastellen des Textes der Skalierung
	/LD_txtAngle	exch	def		% Winkel des Textes (um eventuelle Globale Drehungen zu korrigieren)
	/LI_fineFields	exch	def		% Anzahl Fine-Skalierungsfelder
	/LI_fields	exch	def			% Anzahl Skalierungsfelder
	/LD_maxVal	exch	def			% maximaler Balkenwert in der Einheit
	/LD_minVal	exch	def			% minimaler Balkenwert in der Einheit
	/LI_maxBar	exch	def			% maximaler Balkenwert in Koordinaten

	% Interne Variablen
	/LI_scaleDist	5	def			% Abstand der Skalierung zum Balken
	/LI_scaleLen	5	def				% Länge der Skalierungsstriche
	/LI_scaleLenFine	2	def			% Länge der Skalierungsstriche der Fine-Skalierung
	/LS_helps	() def				% String definieren
	/LI_fieldNum	0 def				% Variable für die Anzahl der Skalierungsfelder anlegen
	/LI_fieldstep 0 def				% Variable für die Größe des Skalierungsschrittes in Koordinaten				
	/LI_fieldstepNum 0 def			% Variable für die Größe des Skalierungsschrittes in Einheit
	/LI_actY	0	def
	/LS_text	()	def

	% setze Var für andere Berechnung des Drehpunktes für die Skalenbeschriftung
	/LXvertBar LD_txtAngle 45 lt LD_txtAngle -45 gt LD_txtAngle 315 gt or and LD_txtAngle 135 gt LD_txtAngle 225 lt and LD_txtAngle -135 lt LD_txtAngle -225 gt and or or def

	LX_fineScaleLenBig {
		/LI_scaleLenFine LI_scaleLen store		% Länge der Skalierungsstriche der Fine-Skalierung
	} if
	
	% diverse Vorgaben negieren, wenn sie nach links gezeichnet werden sollen
	LX_scaleLeft {
		/LI_scaleDist LI_scaleDist neg store
		/LI_scaleLen LI_scaleLen neg store
		/LI_scaleLenFine LI_scaleLenFine neg store
	} if
	% Skalierung zeichnen
	0 0 moveto
	0 LI_maxBar lineto stroke				% Balkengrundlinie zeichnen
	0 0 moveto
	LI_scaleLen 0 lineto stroke				% Nullinie zeichnen
	LI_maxBar LI_fields div
	/LI_fieldstep exch store			% Länge eines Skalierungsfeldes in Koordinaten berechnen
	% Beschriftung errechnen
	LD_maxVal LD_minVal sub
	LI_fields div
	/LI_fieldstepNum exch store
	/LI_fieldNum LD_minVal store		% ersten Anzeigewert speichern

	% 1. Beschriftungspunkt
	LX_showNumScale {
		matrix currentmatrix
		LI_fieldNum LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		0								% Y-Wert ist 0: Drehpunkt für den Text ist also beim Skalenstrich
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if

	/LI_actY 0 store					% aktuellen Y-Wert für die Schleife definieren
	LI_fields {						% Skalierungsschritt-Anzahl für die Schleife auf den Stack legen (Bisher nur position 0 gezeichnet)
		LI_fieldNum LI_fieldstepNum add
		/LI_fieldNum exch store		% Variable Anzeigewert laden
		LI_actY LI_fieldstep add		% aktueller y-Wert erhöhen
		/LI_actY exch store			% y-Wert für den nächsten Schleifendurchlauf speichern
		
		0 LI_actY moveto
		LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
		% Beschriftung
		LX_showNumScale {
			matrix currentmatrix
			LI_fieldNum LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
			/LS_text exch store
			LI_scaleLen LI_scaleDist add
			LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
			LX_scaleLeft { neg } if add
			LI_actY					% Textmitte (x und y) definieren
			translate					% Ursprung dorthin setzen um zu rotieren
			LD_txtAngle rotate			% System drehen
			LS_text strwh					% Länge und Höhe des string ermitteln
			exch 2 div neg					% Länge halbieren und invertieren
			exch 2 div neg					% Höhe halbieren und invertieren
			moveto						% zum Textursprung springen
			LS_text show_utf8						% text ausgeben
			setmatrix
		} if

		% Fine-Skalierung zeichnen
		LI_fineFields 1 gt {
			LI_actY					% y-Wert für die FineScale-Schleife auf den stack legen
			LI_fineFields 1 sub {
				LI_fieldstep LI_fineFields div	% Skalierungsschritt der FineScale in Koordinaten berechnen
				sub					% um den Fine-Skalierungsschritt vom letzte Y-Wert nach unten springen
				dup					% y-Wert für den nächsten Schleifendurchlauf auf den Stack verdoppeln
				0 exch moveto
				LI_scaleLenFine 0 rlineto stroke			% FineScale zeichnen
			} repeat
			pop						% letzten y-Wert der Fine-Skalierung vom Stack poppen
		} if
	} repeat
	stroke
} def


% Zeichnet eine logarithmische Skala zu einem Balken immer von 0 beginnend (sonst wie sp_drawScale003)
%!proc sp_drawScale004
%?subproc
/sp_drawScale004 {
	/LX_showNumFineScale	exch	def		% numerische Fein-Skalierung soll angezeigt werden
	/LX_showNumScale	exch	def		% numerische Skalierung soll angezeigt werden
	/LX_scaleLeft	exch	def		% Skalierung soll nach links zeigen
	/LI_deciNum	exch	def			% Anzahl der Kommastellen des Textes der Skalierung
	/LD_txtAngle	exch	def		% Winkel des Textes (um eventuelle Globale Drehungen zu korrigieren)
	/LD_maxVal	exch	def			% maximaler Balkenwert in der Einheit
	/LI_maxBar	exch	def			% maximaler Balkenwert in Koordinaten

	% Interne Variablen
	/LI_scaleDist	5	def			% Abstand der Skalierung zum Balken
	/LI_scaleLen	5	def				% Länge der Skalierungsstriche
	/LI_scaleLenFine	2	def			% Länge der Skalierungsstriche der Fine-Skalierung
	/LS_helps	() def				% String definieren
	/LI_fieldNum	0 def				% Variable für die Anzahl der Skalierungsfelder anlegen
	/LI_fieldstep 0 def				% Variable für die Größe des Skalierungsschrittes in Koordinaten				
	/LI_fieldstepNum 0 def			% Variable für die Größe des Skalierungsschrittes in Einheit
	/LI_actY	0	def
	/LS_text	()	def

	% setze Var für andere Berechnung des Drehpunktes für die Skalenbeschriftung
	/LXvertBar LD_txtAngle 45 lt LD_txtAngle -45 gt LD_txtAngle 315 gt or and LD_txtAngle 135 gt LD_txtAngle 225 lt and LD_txtAngle -135 lt LD_txtAngle -225 gt and or or def
	
	% diverse Vorgaben negieren, wenn sie nach links gezeichnet werden sollen
	LX_scaleLeft {
		/LI_scaleDist LI_scaleDist neg store
		/LI_scaleLen LI_scaleLen neg store
	} if
	% Skalierung zeichnen
	0 0 moveto
	0 LI_maxBar lineto stroke				% Balkengrundlinie zeichnen

	% Die logarithmische Skala wird nach folgendem Beispiel mit Max Wert 25 dargestellt
	% 1. Strich bei Wert 0: log1, 2. Strich bei Wert 1: log2, 3. Strich bei Wert 2: log 3,4. Strich bei Wert 3: log 4, 5. Strich bei Wert 4: log 5, 6. Strich bei Wert 5: log 6, 7. Strich bei Wert 10: log 11, 8. Strich bei Wert 25: log 26
	% berechne logarithmischen Skalierungsfaktor
	/LDlogFact LI_maxBar LD_maxVal 1 add log div def
	% Beschriftungspunkt: 0
	0 0 moveto
	LI_scaleLen 0 lineto stroke				% Nullinie zeichnen
	LX_showNumScale {
		matrix currentmatrix
		/LS_text (0) store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		0								% Y-Wert ist 0: Drehpunkt für den Text ist also beim Skalenstrich
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: 1
	/LI_actY LD_maxVal 25 div 1 add log LDlogFact mul store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale LD_maxVal 5 div 5 mod 0 eq and {
		matrix currentmatrix
		LD_maxVal 5 div 5 div LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: 2
	/LI_actY LD_maxVal 25 div 2 mul 1 add log LDlogFact mul store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale LX_showNumFineScale and LD_maxVal 5 div 5 mod 0 eq and {
		matrix currentmatrix
		LD_maxVal 5 div 5 div 2 mul LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: 3
	/LI_actY LD_maxVal 25 div 3 mul 1 add log LDlogFact mul store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale LX_showNumFineScale and LD_maxVal 5 div 5 mod 0 eq and {
		matrix currentmatrix
		LD_maxVal 5 div 5 div 3 mul LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: 4
	/LI_actY LD_maxVal 25 div 4 mul 1 add log LDlogFact mul store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale LX_showNumFineScale and LD_maxVal 5 div 5 mod 0 eq and {
		matrix currentmatrix
		LD_maxVal 5 div 5 div 4 mul LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: 5
	/LI_actY LD_maxVal 5 div 1 add log LDlogFact mul store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale {
		matrix currentmatrix
		LD_maxVal 5 div LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: 10
	/LI_actY LD_maxVal 5 div 2 mul 1 add log LDlogFact mul store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale {
		matrix currentmatrix
		LD_maxVal 5 div 2 mul LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	% Beschriftungspunkt: Max
	/LI_actY LI_maxBar store
	0 LI_actY moveto
	LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
	LX_showNumScale {
		matrix currentmatrix
		LD_maxVal LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		/LS_text exch store
		LI_scaleLen LI_scaleDist add 
		LXvertBar { LS_text strw 2 div } { strh 2 div } ifelse		% X-Wert für Drehung in die Textmitte setzen, wenn die Skala im Senkrechten Bereich steht
		LX_scaleLeft { neg } if add
		LI_actY
		translate						% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate				% System drehen
		LS_text strwh					% Länge und Höhe des string ermitteln
		exch 2 div neg					% Länge halbieren und invertieren
		exch 2 div neg					% Höhe halbieren und invertieren
		moveto							% zum Textursprung springen
		LS_text show_utf8				% text ausgeben
		setmatrix
	} if
	stroke
} def


% Zeichnet die Skala in negativer Richtung zu einem Doppelbalken (ohne Nullinie)
%!proc sp_drawScaleNeg001
%?subproc
/sp_drawScaleNeg001 {
	/LX_scaleLeft	exch	def		% Skalierung soll nach links zeigen
	/LI_deciNum	exch	def			% Anzahl der Kommastellen des Textes der Skalierung
	/LD_txtAngle	exch	def			% Winkel des Textes (um eventuelle Globale Drehungen zu korrigieren)
	/LX_fineScale	exch	def		% Fine-Skalierung eingeschalten
	/LI_fields	exch	def			% Anzahl Skalierungsfelder
	/LD_maxVal	exch	def			% maximaler Balkenwert in der Einheit
	/LD_minVal	exch	def			% minimaler Balkenwert in der Einheit
	/LI_maxBar	exch	def			% maximaler Balkenwert in Koordinaten

	% Interne Variablen
	/LI_scaleDist	5	def			% Abstand der Skalierung zum Balken
	/LI_scaleLen	5	def				% Länge der Sklierungsstriche
	/LI_scaleLenFine	3	def			% Länge der Sklierungsstriche der Fine-Skalierung
	/LS_helps 	() def				% String definieren
	/LI_fieldNum	0 def				% Variable für die Anzahl der Skalierungsfelder anlegen
	/LI_fieldstep 0 def				% Variable für die Größe des Skalierungsschrittes in Koordinaten				
	/LI_fieldstepNum 0 def			% Variable für die Größe des Skalierungsschrittes in Einheit
	/LI_actY	0	def

	% diverse Vorgaben negieren, wenn sie nach links gezeichnet werden sollen
	LX_scaleLeft {
		/LI_scaleDist LI_scaleDist neg store
		/LI_scaleLen LI_scaleLen neg store
		/LI_scaleLenFine LI_scaleLenFine neg store
	} if

	% Linien und Schriften setzen
	ValueFont
	% Skalierung zeichnen
	0 0 moveto
	0 LI_maxBar neg lineto stroke			% Balkengrundlinie zeichnen
	LI_maxBar LI_fields div
	/LI_fieldstep exch store			% Länge eines Skalierungsfeldes in Koordinaten berechnen
	% Beschriftung errechnen
	LD_maxVal LD_minVal sub
	LI_fields div
	/LI_fieldstepNum exch store
	% erster Anzeigerwert (Minimum) wird nicht gezeichnet, da dieser bei der positiven Skala gezeichnet wurde
	/LI_actY 0 store					% aktuellen Y-Wert für die Schleife definieren
	LI_fields {						% Skalierungsschritt-Anzahl für die Schleife auf den Stack legen (Bisher nur position 0 gezeichnet)
		LI_fieldNum LI_fieldstepNum add
		/LI_fieldNum exch store		% Variable Anzeigewert laden
		LI_actY LI_fieldstep sub		% aktueller y-Wert nach unten erhöhen
		/LI_actY exch store			% y-Wert für den nächsten Schleifendurchlauf speichern
		
		0 LI_actY moveto
		LI_scaleLen 0 rlineto stroke		% Skalierungstrich zeichnen
		% Beschriftung
		matrix currentmatrix
		LI_scaleLen LI_scaleDist add LI_actY	% Textanfang (x) und Textmitte (y) definieren
		translate					% Ursprung dorthin setzen um zu rotieren
		LD_txtAngle rotate			% System drehen
		LI_fieldNum neg LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		dup stringwidth					% Länge und Höhe des string ermitteln
		LX_scaleLeft {
			exch neg				% Breite negieren, da der Ursprung nach links versetzt werden muss
		} {
			exch pop 0				% Breite vom stack poppen und durch NULL ersetzen
		} ifelse
		exch 2 div neg				% Höhe halbieren und invertieren
		moveto						% zum Textursprung springen
		show_utf8						% text ausgeben
		setmatrix

		% Fine-Skalierung zeichnen
		LX_fineScale {
			LI_actY					% y-Wert für die FineScale-Schleife auf den stack legen
			9 {
				LI_fieldstep 10 div	% Skalierungsschritt der FineScale in Koordinaten berechnen
				sub					% um den Fine-Skalierungsschritt vom letzte Y-Wert nach unten springen
				dup					% y-Wert für den nächsten Schleifendurchlauf auf den Stack verdoppeln
				0 exch neg moveto
				LI_scaleLenFine 0 rlineto			% FineScale zeichnen
			} repeat
			pop						% letzten y-Wert der Fine-Skalierung vom Stack poppen
		} if
	} repeat
	stroke

} def



% Zeichnet die Skala zu zwei Balken
%!proc sp_draw2Scale001
%?subproc
/sp_draw2Scale001 {
	/LI_deciNum	exch	def			% Anzahl der Kommastellen des Textes der Skalierung
	/LX_fineScale	exch	def		% Fine-Skalierung eingeschalten
	/LI_fields	exch	def			% Anzahl Skalierungsfelder
	/LD_maxVal	exch	def			% maximaler Balkenwert in der Einheit
	/LD_minVal	exch	def			% minimaler Balkenwert in der Einheit
	/LI_maxBar	exch	def			% maximaler Balkenwert in Koordinaten

	% Interne Variablen
	/LI_scaleDist	5	def			% Abstand der Skalierung zum Balken
	/LI_scaleLen	5	def				% Länge der Sklierungsstriche
	/LI_scaleLenFine	3	def			% Länge der Sklierungsstriche der Fine-Skalierung
	/LI_fieldNum	0 def				% Variable für die Anzahl der Skalierungsfelder anlegen
	/LI_fieldstep 0 def				% Variable für die Größe des Skalierungsschrittes in Koordinaten				
	/LI_fieldstepNum 0 def			% Variable für die Größe des Skalierungsschrittes in Einheit
	/LI_scale1X	-40	def				% Variable für die Position der Skala 1
	/LI_scale2X	40	def				% Variable für die Position der Skala 1
	/LS_helps	()	def				% string definieren
	/LI_actY	0	def

	%Linien und Schriften setzen
	ValueFont
	% Skalierung 1 zeichnen
	matrix
	currentmatrix
	0 0 translate
	LI_scale1X 0 moveto
	0 LI_maxBar rlineto stroke				% Balkengrundlinie 1 zeichnen
	LI_scale1X 0 moveto
	LI_scaleLen 0 rlineto stroke			% Nullinie 1 zeichnen
	LI_scale2X 0 moveto
	0 LI_maxBar rlineto stroke				% Balkengrundlinie 2 zeichnen
	LI_scale2X 0 moveto
	LI_scaleLen neg 0 rlineto stroke		% Nullinie 2 zeichnen
	%Berechnung
	LI_maxBar LI_fields div
	/LI_fieldstep exch store			% Länge eines Skalierungsfeldes in Koordinaten berechnen
	%Beschriftung
	LD_maxVal LD_minVal sub
	LI_fields div
	/LI_fieldstepNum exch store
	/LI_fieldNum LD_minVal store		% ersten Anzeigewert speichern
	LI_fieldNum LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
	dup strwh						% Länge der Beschriftung errechnen
	exch 2 div neg					% x-wert berechnen
	exch 2 div neg					% y-wert berechnen
	moveto							% zum Beschriftungspunkt springen
	show_utf8							% text ausgeben
	/LI_actY 0 store					% aktuellen Y-Wert für die Schleife definieren
	LI_fields {						% Skalierungsschritt-Anzahl für die Schleife auf den Stack legen (Bisher nur position 0 gezeichnet)
		LI_fieldNum LI_fieldstepNum add
		/LI_fieldNum exch store		% Variable Anzeigewert laden
		LI_actY LI_fieldstep add		% aktueller y-Wert erhöhen
		/LI_actY exch store			% y-Wert für den nächsten Schleifendurchlauf speichern

		LI_scale1X LI_actY moveto
		LI_scaleLen 0 rlineto stroke		% Skalierungstrich 1 zeichnen
		LI_scale2X LI_actY moveto
		LI_scaleLen neg 0 rlineto stroke	% Skalierungstrich 1 zeichnen
		% Beschriftung
		LI_fieldNum LS_helps LI_deciNum ncvs	% Anzeigewert in String umwandeln
		dup strwh					% Länge der Beschriftung errechnen
		exch 2 div neg				% X-wert berechnen
		exch 2 div					% y-wert Korrektur berechnen
		LI_actY exch sub				% y-wert berechnen
		moveto						% zum Beschriftungspunkt springen
		show_utf8						% text ausgeben
		% Fine-Skalierung zeichnen
		LX_fineScale {
			LI_actY					% y-Wert für die FineScale-Schleife auf den stack legen
			9 {
				LI_fieldstep 10 div	% Skalierungsschritt der FineScale in Koordinaten berechnen
				sub					% um den Fine-Skalierungsschritt vom letzte Y-Wert nach unten springen
				dup					% y-Wert für den nächsten Schleifendurchlauf auf den Stack verdoppeln
				LI_scale1X exch moveto
				LI_scaleLenFine 0 rlineto stroke			% FineScale zeichnen
				dup					% y-Wert für den nächsten Schleifendurchlauf auf den Stack verdoppeln
				LI_scale2X exch moveto
				LI_scaleLenFine neg 0 rlineto stroke			% FineScale zeichnen
			} repeat
			pop						% letzten y-Wert der Fine-Skalierung vom Stack poppen
		} if
	} repeat
	setmatrix
} def

% Zeichent die Skala zu einem Zeigerdisplay
%!proc sp_drawScaleArc001
%?subproc
/sp_drawScaleArc001 {
	/idColorHigh	exch	def				% Farbe für den obersten Warnbereich: 0=neutral, 1=grün, 2=blau, 3=gelb, 4=rot, 5=grau, 6= hellgrau
	/idColorLow	exch	def				% Farbe für den untersten Warnbereich: 0=neutral, 1=grün, 2=blau, 3=gelb, 4=rot, 5=grau, 6= hellgrau
	/idColor		exch	def				% Farbe für den mittleren Skalenbereich: 0=neutral, 1=grün, 2=blau, 3=gelb, 4=rot, 5=grau, 6= hellgrau
	/LI_Design		exch	def				% Design des Zeigersdisplays
	/LI_ScaleActive	exch	def				% Skala aktiviert
	/LI_outSca		exch	def				% Skalenbeschriftung ausserhalb der Skala
	/LI_ScaleRadius	exch	def				% Radius der Skalenbeschriftung
	/LI_Radius		exch	def				% äusserer Radius des Zeigerdisplays
	/LI_deciNum		exch	def				% Anzahl der Kommastellen des Textes der Skalierung
	/LI_ScaleAngle	exch	def				% Winkelbereich der Skala (pos, neg nach PostScript)
	/LI_AngleBegin	exch	def				% Winkel des Skalenbeginnes
	/LI_NumbFineFields	exch	def			% Anzahl der kleinen Skalierungsfelder innerhalb eines Skalierungsfeldes (kann keine Kommazahl sein)
	/LI_NumbFields	exch	def				% Anzahl der Skalierungsfelder (kann auch eine Kommazahl sein, d.h. die Skala wird mit kleiner Skalierung ohne Beschriftung weitergeführt)
	/LI_HigherWarn	exch	def				% Wert oberer Farbumschlag
	/LI_LowerWarn	exch	def				% Wert unterer Farbumschlag
	/LI_ValueEnd	exch	def				% Wert des Skalenendes
	/LI_ValueBegin	exch	def				% Wert des Skalenanfanges

	/LD_scaleVal	0	def
	/LS_helps	()	def
	/LD_scaleStepAng	0	def
	/LD_scaleStepVal	0	def
	/LD_numbFieldInt	0	def
	/LD_Linewidth 1	def
	/LD_Radius	0	def						% Äusserer Radius der Skalenstriche
	/LD_RadiusSca	0	def					% mittlerer Radius der Skalierung
	/LD_helpi	0	def
	/LD_helpX	0	def
	/LD_helpY	0	def
	/LD_RadOffset	5	def
	/LX_NumScaleAct true def
	/LX_SetRoundBeg false def				% Runden Skalenanfang setzen
	/LX_SetRoundEnd false def				% Rundes Skalenende setzen
	/LX_RoundCap true def					% RoundCap: rundes Skalenende zulassen

	matrix currentmatrix
	
	LI_NumbFields 0 eq {
		/LX_NumScaleAct false store
		/LI_NumbFields 1 store
	} if
	LI_NumbFineFields 0 eq {
		/LI_NumbFineFields 1 store
	} if

	% Berechnungen Hilfsvariablen
	/L_angBeg LI_AngleBegin def																					% Winkel des Skalenbeginns
	/LD_ValRange LI_ValueEnd LI_ValueBegin sub LI_NumbFields cvi div LI_NumbFields mul def						% eigentlicher Bereich der Skala, wenn z.B. eine Kommazahl LI_NumbFields übergeben wurde
	/L_SectAngLow LI_LowerWarn LI_ValueBegin sub LI_ScaleAngle mul LD_ValRange div def							% Winkelbereich der unteren Warnfarbe
	/L_SectAngHigh LD_ValRange LI_ValueBegin add LI_HigherWarn sub LI_ScaleAngle mul LD_ValRange div def		% Winkelbereich der oberen Warnfarbe
	/L_SectAngNorm LI_ScaleAngle L_SectAngLow sub L_SectAngHigh sub	def											% Winkelbereich des mittleren Bereiches


	% Berechnung des Radius der Skalenbeschriftung
	LI_ScaleRadius 0 eq {
		LI_Design 3 le {
			LI_outSca { LI_Radius LD_Linewidth 12 add add } { LI_Radius LD_Linewidth 30 add sub } ifelse
			/LD_RadiusSca exch store
		} {
			LI_outSca { LI_Radius LD_Linewidth 12 add add } { LI_Radius LD_Linewidth 15 add sub } ifelse
			/LD_RadiusSca exch store
		} ifelse
	} {
		/LD_RadiusSca LI_ScaleRadius store
	} ifelse

	LI_Design 1 eq { /LD_Linewidth 3 store } if
	LI_Design 2 eq { /LD_Linewidth 5 store } if
	LI_Design 3 eq { /LD_Linewidth 7 store } if
	LI_Design 4 ge { /LD_Linewidth 3 store } if
	LI_Design 5 ge { /LD_Linewidth 5 store } if
	LI_Design 6 ge { /LD_Linewidth 7 store } if
	LI_Design 7 ge { /LD_Linewidth 9 store } if
	LI_Design 8 ge { /LD_Linewidth 11 store } if

	% ACHTUNG: Die folgende Drehung in der Schleife kann wegen Rundungsfehlern nicht fortlaufend programmiert werden (also pro Schleifendurchlauf um den Step weiterdrehen, dann summiert sich der Rundungsfehler)
	currentcolor
	LI_Design 4 lt {
		LI_ScaleActive {
			matrix currentmatrix
			% Große Skalenstriche
			LI_Radius LD_Linewidth 2 add sub
			/LD_Radius exch store
			/LD_numbFieldInt LI_NumbFields cvi store
			/LD_scaleStepAng LI_ScaleAngle LI_NumbFields div store				% Winkelbereich eines beschrifteten Skalenabschnittes (eventuelle Kommastellen abschneiden)
			/LD_scaleStepVal LI_ValueEnd LI_ValueBegin sub LD_numbFieldInt div store	% Skalenwert eines beschrifteten Skalenabschnittes
			/LD_scaleVal LI_ValueBegin store									% aktueller Skalenwert

			LI_AngleBegin rotate												% Zur Nullinie drehen
			LD_numbFieldInt 1 add cvi {
				/LD_helpi LD_helpi 1 add store									% Schleifenzähler erhöhen
				LD_Radius 7 sub 0 moveto LD_Radius 0 lineto						% Hier wird der lange Strich gezeichnet
				stroke
				LD_RadiusSca 0 transform										% Textmittelpunkt ins globale Koordinatensystem transferieren
				/LD_helpY exch store
				/LD_helpX exch store
				setmatrix														% ins nichtgedrehte Koordinatensystem zurückspringen
				LD_scaleVal LS_helps LI_deciNum ncvs							% Skalenwert in String konvertieren
				/LS_helps exch store											% im String speichern
				LS_helps strwh													% Länge und Höhe des string ermitteln
				exch 2 div														% Breite halbieren
				exch 2 div														% Höhe halbieren
				dtransform														% ermittelten Vektor zum Textursprung ins globale Koordinatensystem transformieren
				LD_helpX 2 index sub											% mit dem Textmittelpunkt den Text-Startpunkt im globalen Koordinatensystem ermitteln
				LD_helpY 2 index sub											% mit dem Textmittelpunkt den Text-Startpunkt im globalen Koordinatensystem ermitteln
				itransform moveto												% x und y vom globalen Koordinatensystem ins lokale transferieren
				LD_helpi 1 eq LI_ScaleAngle abs 340 gt and not LX_NumScaleAct and {				% Wenn der Skalierungskreis geschlossen wird (zum Vollkreis (z.B. Stoppuhr)), wird die Zahl des ersten Striches nicht angezeigt
					LS_helps show_utf8											% Zahl einblenden
				} if
				pop pop
				matrix currentmatrix											% für erneute Drehung von Null aktuelle Matrix speichern
				LI_AngleBegin LD_scaleStepAng LD_helpi mul add rotate			% für nächste Schleife weiterdrehen
				LD_scaleVal LD_scaleStepVal add									% Skalenwert für nächste Schleife berechnen
				/LD_scaleVal exch store											% Skalenwert für nächste Schleife speichern
			} repeat
			setmatrix
			% Kleine Skalenstriche
			matrix currentmatrix
			/LD_helpi 0 store													% Schleifenzähler auf Null setzen
			LI_NumbFields LI_NumbFineFields mul 1 add round {
				LD_scaleStepAng LD_helpi mul LI_NumbFineFields div				% aktuellen Winkelschritt des zu zeichnenden Striches ermitteln
				dup LI_AngleBegin add rotate									% zum Zeichenpunkt drehen
				LD_scaleStepAng mod 0 ne {										% kurzen Strich nur zeichnen, wenn an dieser Position (Winkelschritt) kein langer Strich gezeichnet wurde
					LD_Radius 3 sub 0 moveto LD_Radius 0 lineto stroke			% kurzen Skalenstrich zeichnen
				} if
				LD_helpi 1 add /LD_helpi exch store								% Schleifenzähler erhöhen
				setmatrix matrix currentmatrix									% ins nichtgedrehte Koordinatensystem zurückspringen für erneute Drehung von Null
			} repeat
			setmatrix
			1 setlinewidth
		} {
			% Äusserer Kreis zeichnen wenn keine Skala gezeichnet wird
			matrix currentmatrix
			1 setlinewidth
			/LD_Radius LI_Radius LD_Linewidth add store
			LI_AngleBegin rotate
			LD_Radius 0 moveto
			LI_ScaleAngle 0 lt {
				0 0 LD_Radius 0 LI_ScaleAngle arcn
			} {
				0 0 LD_Radius 0 LI_ScaleAngle arc
			} ifelse
			stroke
			1 setlinewidth
			setmatrix
		} ifelse
	} if
	setcolor
	
	% graphischer Skalierungskreis zeichnen
	matrix currentmatrix currentcolor
	L_angBeg rotate
	LD_Linewidth setlinewidth
	/LD_Radius LI_Radius LD_RadOffset 2 mul add store

	% unterer Skalenbereich
	currentcolor
	LI_LowerWarn LI_ValueBegin gt {
		idColorLow sp_set_color
		LI_Radius 0 moveto
		LI_ScaleAngle 0 lt { 0 0 LI_Radius 0 L_SectAngLow arcn } { 0 0 LI_Radius 0 L_SectAngLow arc } ifelse
		stroke
	} {
		LX_RoundCap { /LX_SetRoundBeg true store } if
	} ifelse
	setcolor
	
	% oberer Skalenbereich
	currentcolor
	LI_HigherWarn LI_ValueEnd lt {
		matrix currentmatrix
		idColorHigh sp_set_color
		L_SectAngLow L_SectAngNorm add rotate
		LI_Radius 0 moveto
		LI_ScaleAngle 0 lt { 0 0 LI_Radius 0 L_SectAngHigh arcn } { 0 0 LI_Radius 0 L_SectAngHigh arc } ifelse
		stroke
		setmatrix
	} {
		LX_RoundCap { /LX_SetRoundEnd true store } if
	} ifelse
	setcolor
	
	0 setlinecap
	% mittlerer Skalenbereich
	currentcolor
	matrix currentmatrix
	idColor sp_set_color
	% Linienanfang abrunden, wenn kein unterer Warnbereich gezeichnet wird
	LX_SetRoundBeg {
		L_SectAngLow rotate
		LI_Radius 0 moveto
		1 setlinecap
		LI_ScaleAngle 0 lt { 0 0 LI_Radius 0 -2 arcn } { 0 0 LI_Radius 0 2 arc } ifelse 
		stroke
		0 setlinecap
		setmatrix matrix currentmatrix
	} if
	% Linienende abrunden, wenn kein oberer Warnbereich gezeichnet wird
	LX_SetRoundEnd {
		L_SectAngLow L_SectAngNorm add rotate
		LI_Radius 0 moveto
		1 setlinecap
		LI_ScaleAngle 0 lt { 0 0 LI_Radius 0 2 arc } { 0 0 LI_Radius 0 -2 arcn } ifelse
		stroke
		0 setlinecap
		setmatrix matrix currentmatrix
	} if
	% Bereich zeichnen
	L_SectAngLow rotate
	LI_Radius 0 moveto
	LI_ScaleAngle 0 lt { 0 0 LI_Radius 0 L_SectAngNorm arcn } { 0 0 LI_Radius 0 L_SectAngNorm arc } ifelse
	stroke
	setmatrix
	setcolor 

	setcolor setmatrix

	% Skalierung mit schwarzen Strichunterbrechungen zeichnen
	LI_Design 4 ge {
		3 setlinewidth
		matrix currentmatrix
		% Große Skalenstriche
		LI_Radius LD_Linewidth 2 div add 
		/LD_Radius exch store
		/LD_numbFieldInt LI_NumbFields cvi store
		/LD_scaleStepAng LI_ScaleAngle LI_NumbFields div store						% Winkelbereich eines beschrifteten Skalenabschnittes (eventuelle Kommastellen abschneiden)
		/LD_scaleStepVal LI_ValueEnd LI_ValueBegin sub LD_numbFieldInt div store	% Skalenwert eines beschrifteten Skalenabschnittes
		/LD_scaleVal LI_ValueBegin store											% aktueller Skalenwert
		/LD_helpi 0 store

		% Skalenstriche zeichnen
		currentcolor
		matrix currentmatrix
		Invisible
		LI_NumbFields LI_NumbFineFields mul 1 sub {
			/LD_helpi LD_helpi 1 add store													% Schleifenzähler erhöhen
			LI_AngleBegin LD_scaleStepAng LI_NumbFineFields div LD_helpi mul add rotate		% für nächste Schleife weiterdrehen
			LD_Radius LD_Linewidth sub 3 sub 0 moveto LD_Radius 1 add 0 lineto				% Hier wird der Skalenstrich Strich gezeichnet
			stroke
			setmatrix																		% ins nichtgedrehte Koordinatensystem zurückspringen
			matrix currentmatrix															% für erneute Drehung von Null aktuelle Matrix speichern
		} repeat
		setmatrix
		setcolor
		
		% Skala beschriften
		/LD_helpi 0 store
		LI_AngleBegin rotate													% Zur Nullinie drehen
		LD_numbFieldInt 1 add {
			/LD_helpi LD_helpi 1 add store										% Schleifenzähler erhöhen
			LD_RadiusSca 0 transform											% Textmittelpunkt ins globale Koordinatensystem transferieren
			/LD_helpY exch store
			/LD_helpX exch store
			setmatrix															% ins nichtgedrehte Koordinatensystem zurückspringen
			LI_ScaleActive LX_NumScaleAct and {
				LD_scaleVal LS_helps LI_deciNum ncvs							% Skalenwert in String konvertieren
				/LS_helps exch store											% im String speichern
				LS_helps strwh													% Länge und Höhe des string ermitteln
				exch 2 div														% Breite halbieren
				exch 2 div														% Höhe halbieren
				dtransform														% ermittelten Vektor zum Textursprung ins globale Koordinatensystem transformieren
				LD_helpX 2 index sub											% mit dem Textmittelpunkt den Text-Startpunkt im globalen Koordinatensystem ermitteln
				LD_helpY 2 index sub											% mit dem Textmittelpunkt den Text-Startpunkt im globalen Koordinatensystem ermitteln
				itransform moveto												% x und y vom globalen Koordinatensystem ins lokale transferieren
				LS_helps show_utf8												% Zahl einblenden und zwei Werte die vom index operator stehengelassen wurden weglöschen
				pop pop
			} if
			matrix currentmatrix												% für erneute Drehung von Null aktuelle Matrix speichern
			LI_AngleBegin LD_scaleStepAng LD_helpi mul add rotate				% für nächste Schleife weiterdrehen
			/LD_scaleVal LD_scaleVal LD_scaleStepVal add store					% Skalenwert für nächste Schleife berechnen
		} repeat
		setmatrix
	} if
	1 setlinewidth
	1 setlinecap
	setmatrix
} def

% shows text strings on screen (horizontally left orientated, vertically centered)
%!proc sp_textLeftCenter
%?subproc
/sp_textLeftCenter {
	/isText exch def	%?brief Text  %?use INP %?type STRI %?dflt text
	0 strh 2 div neg rmoveto
	isText show_utf8
} def


% shows text strings on screen (horizontally and vertically centered)
%!proc sp_textCenterCenter
/sp_textCenterCenter {
	/isText exch def	%?brief Text  %?use INP %?type STRI %?dflt text
	isText stringwidth pop 2 div neg strh 2 div neg rmoveto
	isText show_utf8
} def

% touch button 80 x 160/80 ('L' form)
%!proc sp_touchButtonShift
%?subproc
/sp_touchButtonShift {
	/ixShift	exch	def		% Shift button pressed
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	40 83 5 270 180 arcn 
	30 153 5 0 90 arc 
	6 153 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
	_mxposd _myposd itransform 
	 newpath 
	0 0 moveto
	0 159 rlineto
	39 0 rlineto
	0 -79 rlineto
	40 0 rlineto
	0 -79 rlineto
	ineofill
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		43 80 5 270 180 arcn 
		33 150 5 0 90 arc 
		9 150 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	LX_Active not ixShift and {
		TouchAreaInv
		newpath
		6 4 moveto 
		70 9 5 270 360 arc 
		70 73 5 0 90 arc 
		40 83 5 270 180 arcn 
		30 153 5 0 90 arc 
		6 153 5 90 180 arc 
		6 9 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
} def


% touch button 80 x 160/80 ('_I' form)
%!proc sp_touchButtonEnter
%?subproc
/sp_touchButtonEnter {
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 153 5 0 90 arc 
	46 153 5 90 180 arc 
	36 83 5 0 270 arcn 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
	_mxposd _myposd itransform 
	 newpath 
	0 0 moveto
	0 79 rlineto
	39 0 rlineto
	0 80 rlineto
	40 0 rlineto
	0 -159 rlineto
	ineofill
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 150 5 0 90 arc 
		49 150 5 90 180 arc 
		39 80 5 0 270 arcn 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
} def

% set unit by unitnumber
%!proc sp_set_unit
%?subproc
/sp_set_unit {
	/idUnit		exch	def		% unit selection
	/qsUnit		()	def			% unit as string (SI or imperial)

	% Auswahl und Umrechnung der Einheit
	% Distance by MXchangeUnitDist
		% 10	=	m	/	ft
		% 11	=	m	/	in
		% 12	=	cm	/	ft
		% 13	=	cm	/	in
		% 14	=	mm	/	in
	% Load by MXchangeUnitLoad
		% 20	=	t	/	kip
		% 21	=	t	/	tn sh
		% 22	=	t	/	lb
		% 23	=	t	/	lb/1000
		% 24	=	kg	/	lb
		% 25	=	kN	/	kip
% Pressure by MXchangeUnitPress
		% 30	=	bar	/	psi
	% Temperature by MXchangeUnitTemp
		% 40	=	°C	/	°F
	% Volume by MXchangeUnitVolume
		% 50	=	l/min	/	gal/min
		% 51	=	m³	/	cyd
		% 52	=	l	/	gal
	% Speed by MXchangeUnitSpeed
		% 60	=	km/h	/	mph
		% 61	=	m/s		/	mph
		% 62	=	m/s		/	kn
		% 63	=	m/min	/	ft/min
	% no calculation
		% 70	=	°	/	°
		% 71	=	kN	/	kN
		% 72	=	s	/	s
		% 73	=	kW	/	kW
		% 74	=	%	/	%
		% 75	=	Hz	/	Hz
	% general power units
		% 80	=	Nm	/	lb.ft		by MXchangeUnitDist or MXchangeUnitLoad
		% 81	=	kNm	/	kip.ft		by MXchangeUnitDist or MXchangeUnitLoad

	idUnit 10 eq {
		/qsUnit (m) store
		MXchangeUnitDist {
			/qsUnit (ft) store
		} if
	} if
	idUnit 11 eq {
		/qsUnit (m) store
		MXchangeUnitDist {
			/qsUnit (in) store
		} if
	} if
	idUnit 12 eq {
		/qsUnit (cm) store
		MXchangeUnitDist {
			/qsUnit (ft) store
		} if
	} if
	idUnit 13 eq {
		/qsUnit (cm) store
		MXchangeUnitDist {
			/qsUnit (in) store
		} if
	} if
	idUnit 14 eq {
		/qsUnit (mm) store
		MXchangeUnitDist {
			/qsUnit (in) store
		} if
	} if
	idUnit 20 eq {
		/qsUnit (t) store
		MXchangeUnitLoad {
			/qsUnit (kip) store
		} if
	} if
	idUnit 21 eq {
		/qsUnit (t) store
		MXchangeUnitLoad {
			/qsUnit (tnsh) store
		} if
	} if
	idUnit 22 eq idUnit 23 eq or {
		/qsUnit (t) store
		MXchangeUnitLoad {
			/qsUnit (lb) store
		} if
	} if
	idUnit 24 eq {
		/qsUnit (kg) store
		MXchangeUnitLoad {
			/qsUnit (lb) store
		} if
	} if
	idUnit 25 eq {
		/qsUnit (kN) store
		MXchangeUnitLoad {
			/qsUnit (kip) store
		} if
	} if
	idUnit 30 eq {
		/qsUnit (bar) store
		MXchangeUnitPress {
			/qsUnit (psi) store
		} if
	} if
	idUnit 40 eq {
		/qsUnit (Â°C) store
		MXchangeUnitTemp {
			/qsUnit (Â°F) store
		} if
	} if
	idUnit 50 eq {
		/qsUnit (l/min) store
		MXchangeUnitVolume {
			/qsUnit (gal/min) store
		} if
	} if
	idUnit 51 eq {
		/qsUnit (mÂ³) store
		MXchangeUnitVolume {
			/qsUnit (cyd) store
		} if
	} if
	idUnit 52 eq {
		/qsUnit (l) store
		MXchangeUnitVolume {
			/qsUnit (gal) store
		} if
	} if
	idUnit 60 eq {
		/qsUnit (km/h) store
		MXchangeUnitSpeed {
			/qsUnit (mph) store
		} if
	} if
	idUnit 61 eq {
		/qsUnit (m/s) store
		MXchangeUnitSpeed {
			/qsUnit (mph) store
		} if
	} if
	idUnit 62 eq {
		/qsUnit (m/s) store
		MXchangeUnitSpeed {
			/qsUnit (kn) store
		} if
	} if
	idUnit 63 eq {
		/qsUnit (m/min) store
		MXchangeUnitSpeed {
			/qsUnit (ft/min) store
		} if
	} if
	idUnit 70 eq {
		/qsUnit (Â°) store
	} if
	idUnit 71 eq {
		/qsUnit (kN) store
	} if
	idUnit 72 eq {
		/qsUnit (s) store
	} if
	idUnit 73 eq {
		/qsUnit (kW) store
	} if
	idUnit 74 eq {
		/qsUnit (%) store
	} if
	idUnit 75 eq {
		/qsUnit (Hz) store
	} if
	idUnit 80 eq {
		/qsUnit (Nm) store
		MXchangeUnitDist MXchangeUnitLoad or {
			/qsUnit (lb.ft) store
		} if
	} if
	idUnit 81 eq {
		/qsUnit (kNm) store
		MXchangeUnitDist MXchangeUnitLoad or {
			/qsUnit (kip.ft) store
		} if
	} if

	qsUnit
} def

% calculate imperial value from SI value if imperial is seted
%!proc sp_calc_imperial
%?subproc
/sp_calc_imperial {
	/idUnit		exch	def		%?brief unit selection
	/irValue	exch	def		%?brief SI value		
	/qrValue	0.0	def			%?brief imperial value

	% Auswahl und Umrechnung der Einheit
	% Distance by MXchangeUnitDist
		% 10	=	m	/	ft
		% 11	=	m	/	in
		% 12	=	cm	/	ft
		% 13	=	cm	/	in
		% 14	=	mm	/	in
	% Load by MXchangeUnitLoad
		% 20	=	t	/	kip
		% 21	=	t	/	tn sh
		% 22	=	t	/	lb
		% 23	=	t	/	lb/1000
		% 24	=	kg	/	lb
		% 25	=	kN	/	kip
	% Pressure by MXchangeUnitPress
		% 30	=	bar	/	psi
	% Temperature by MXchangeUnitTemp
		% 40	=	°C	/	°F
	% Volume by MXchangeUnitVolume
		% 50	=	l/min	/	gal/min
		% 51	=	m³	/	cyd
		% 52	=	l	/	gal
	% Speed by MXchangeUnitSpeed
		% 60	=	km/h	/	mph
		% 61	=	m/s		/	mph
		% 62	=	m/s		/	kn
		% 63	=	m/min	/	ft/min
	% no calculation
		% 70	=	°	/	°
		% 71	=	kN	/	kN
		% 72	=	s	/	s
		% 73	=	kW	/	kW
		% 74	=	%	/	%
		% 75	=	Hz	/	Hz
	% general power units
		% 80	=	Nm	/	lb.ft		by MXchangeUnitDist or MXchangeUnitLoad
		% 81	=	kNm	/	kip.ft		by MXchangeUnitDist or MXchangeUnitLoad

	/qrValue irValue store
	
	idUnit 10 ge idUnit 14 le and MXchangeUnitDist and {		% genaue Bereichsabfrage
		irValue
		idUnit 10 eq { (m) (ft) } if
		idUnit 11 eq { (m) (in) } if
		idUnit 12 eq { (cm) (ft) } if
		idUnit 13 eq { (cm) (in) } if
		idUnit 14 eq { (mm) (in) } if
		calc_imperial
		/qrValue exch store 
	} if
	
	idUnit 20 ge idUnit 25 le and MXchangeUnitLoad and {
		irValue
		idUnit 20 eq { (t) (kip) } if
		idUnit 21 eq { (t) (tnsh) } if
		idUnit 22 eq { (t) (lb) } if
		idUnit 23 eq { (t) (lb/1000) } if
		idUnit 24 eq { (kg) (lb) } if
		idUnit 25 eq { (kN) (kip) } if
		calc_imperial
		/qrValue exch store 
	} if

	idUnit 30 ge idUnit 30 le and MXchangeUnitPress and {
		irValue
		idUnit 30 eq { (bar) (psi) } if
		calc_imperial
		/qrValue exch store 
	} if

	idUnit 40 ge idUnit 40 le and MXchangeUnitTemp and {
		irValue
		idUnit 40 eq { (°C) (°F) } if
		calc_imperial
		/qrValue exch store 
	} if

	idUnit 50 ge idUnit 52 le and MXchangeUnitVolume and {
		irValue
		idUnit 50 eq { (l/min) (gal/min) } if
		idUnit 51 eq { (m³) (cyd) } if
		idUnit 52 eq { (l) (gal) } if
		calc_imperial
		/qrValue exch store 
	} if

	idUnit 60 ge idUnit 63 le and MXchangeUnitSpeed and {
		irValue
		idUnit 60 eq { (km/h) (mph) } if
		idUnit 61 eq { (m/s) (mph) } if
		idUnit 62 eq { (m/s) (kn) } if
		idUnit 63 eq { (m/min) (ft/min) } if
		calc_imperial
		/qrValue exch store 
	} if

	idUnit 80 ge idUnit 81 le and MXchangeUnitLoad MXchangeUnitDist or and {
		irValue
		idUnit 80 eq { (Nm) (lb.ft) } if
		idUnit 81 eq { (kNm) (kip.ft) } if
		calc_imperial
		/qrValue exch store 
	} if

	qrValue
} def

% calculate SI value from imperial value if imperial is seted
%!proc sp_calc_SI
%?subproc
/sp_calc_SI {
	/idUnit		exch	def		%?brief unit selection
	/irValue	exch	def		%?brief imperial value
	/qrValue	0.0	def			%?brief SI value		

	% Auswahl und Umrechnung der Einheit
	% Distance by MXchangeUnitDist
		% 10	=	m	/	ft
		% 11	=	m	/	in
		% 12	=	cm	/	ft
		% 13	=	cm	/	in
		% 14	=	mm	/	in
	% Load by MXchangeUnitLoad
		% 20	=	t	/	kip
		% 21	=	t	/	tn sh
		% 22	=	t	/	lb
		% 23	=	t	/	lb/1000
		% 24	=	kg	/	lb
		% 25	=	kN	/	kip
	% Pressure by MXchangeUnitPress
		% 30	=	bar	/	psi
	% Temperature by MXchangeUnitTemp
		% 40	=	°C	/	°F
	% Volume by MXchangeUnitVolume
		% 50	=	l/min	/	gal/min
		% 51	=	m³	/	cyd
		% 52	=	l	/	gal
	% Speed by MXchangeUnitSpeed
		% 60	=	km/h	/	mph
		% 61	=	m/s		/	mph
		% 62	=	m/s		/	kn
		% 63	=	m/min	/	ft/min
	% no calculation
		% 70	=	°	/	°
		% 71	=	kN	/	kN
		% 72	=	s	/	s
		% 73	=	kW	/	kW
		% 74	=	%	/	%
		% 75	=	Hz	/	Hz
	% general power units
		% 80	=	Nm	/	lb.ft		by MXchangeUnitDist or MXchangeUnitLoad
		% 81	=	kNm	/	kip.ft		by MXchangeUnitDist or MXchangeUnitLoad

	/qrValue irValue store
	
	idUnit 10 ge idUnit 14 le and MXchangeUnitDist and {		% genaue Bereichsabfrage
		irValue
		idUnit 10 eq { (m) (ft) } if
		idUnit 11 eq { (m) (in) } if
		idUnit 12 eq { (cm) (ft) } if
		idUnit 13 eq { (cm) (in) } if
		idUnit 14 eq { (mm) (in) } if
		calc_SI
		/qrValue exch store 
	} if
	
	idUnit 20 ge idUnit 25 le and MXchangeUnitLoad and {
		irValue
		idUnit 20 eq { (t) (kip) } if
		idUnit 21 eq { (t) (tnsh) } if
		idUnit 22 eq { (t) (lb) } if
		idUnit 23 eq { (t) (lb/1000) } if
		idUnit 24 eq { (kg) (lb) } if
		idUnit 25 eq { (kN) (kip) } if
		calc_SI
		/qrValue exch store 
	} if

	idUnit 30 ge idUnit 30 le and MXchangeUnitPress and {
		irValue
		idUnit 30 eq { (bar) (psi) } if
		calc_SI
		/qrValue exch store 
	} if

	idUnit 40 ge idUnit 40 le and MXchangeUnitTemp and {
		irValue
		idUnit 40 eq { (°C) (°F) } if
		calc_SI
		/qrValue exch store 
	} if

	idUnit 50 ge idUnit 52 le and MXchangeUnitVolume and {
		irValue
		idUnit 50 eq { (l/min) (gal/min) } if
		idUnit 51 eq { (m³) (cyd) } if
		idUnit 52 eq { (l) (gal) } if
		calc_SI
		/qrValue exch store 
	} if

	idUnit 60 ge idUnit 63 le and MXchangeUnitSpeed and {
		irValue
		idUnit 60 eq { (km/h) (mph) } if
		idUnit 61 eq { (m/s) (mph) } if
		idUnit 62 eq { (m/s) (kn) } if
		idUnit 63 eq { (m/min) (ft/min) } if
		calc_SI
		/qrValue exch store 
	} if

	idUnit 80 ge idUnit 81 le and MXchangeUnitLoad MXchangeUnitDist or and {
		irValue
		idUnit 80 eq { (Nm) (lb.ft) } if
		idUnit 81 eq { (kNm) (kip.ft) } if
		calc_SI
		/qrValue exch store 
	} if

	qrValue
} def



% *************************************************************************************************************************
% Definition von Symbolen die in der llbasic benötigt werden (die llbasic soll nur die llsystem einbinden, keine andere Lib)
% *************************************************************************************************************************

%!proc sp_basicsym001
%?subproc
% Pfeil
/sp_basicsym001 {
	3 setlinewidth_nlw 
	40 15 moveto 
	15 40 lineto 
	stroke 
	15 40 moveto 
	30 40 lineto 
	stroke 
	30 40 moveto 
	30 65 lineto 
	stroke 
	30 65 moveto 
	50 65 lineto 
	stroke 
	50 65 moveto 
	50 40 lineto 
	stroke 
	50 40 moveto 
	65 40 lineto 
	stroke 
	65 40 moveto 
	40 15 lineto 
	stroke 
	1 setlinewidth_nlw 
} def

%!proc sp_basicsym002
%?subproc
% O.K. Symbol
/sp_basicsym002 {
	5 setlinewidth_nlw 
	5 16 moveto 
	10.05 16.05 13 12.05 17 5 curveto 
	stroke 
	18 5 moveto 
	21.05 21.05 25.10 28.10 33 35 curveto 
	stroke 
	1 setlinewidth_nlw 
} def

%!proc sp_basicsym003
%?subproc
% Warnung
/sp_basicsym003 {
	3 setlinewidth_nlw 
	%?plinebeg
	20 32 moveto 
	5 5 lineto 
	35 5 lineto 
	20 32 lineto 
	stroke 
	%?plineend
	22 10 moveto 
	newpath 
	20 10 2 0 360 arc 
	eofill 
	%?plinebeg
	
	newpath 
	19 15 moveto 
	21 15 lineto 
	22 23 lineto 
	18 23 lineto 
	19 15 lineto 
	eofill 
	%?plineend
	1 setlinewidth_nlw
} def


% *************************************************************************************************************************
% Definition von Parts
% *************************************************************************************************************************

%?partdef baCircle001
%?fn	baCircle001
%?brief	cirlce part by angle and radius
%?bbox	-80 -80 79 79
/baCircle001 {
	/ixFromCurrPoint exch def	%?brief draw line from current point %?use INP %?type BOOL %?dflt    false
	/ixClockwise exch def	%?brief draw angle clockwise %?use INP %?type BOOL %?dflt    false
	/irStopAngle exch def	%?brief end angle of the circle %?use INP %?type REAL %?dflt    60.00
	/irStartAngle exch def	%?brief start angle of the circle %?use INP %?type REAL %?dflt    30.00
	/irRadius exch def	%?brief radius of the circle %?use INP %?type REAL %?dflt    10.00
%?manual_beg
	matrix currentmatrix
	irStartAngle rotate
	ixFromCurrPoint not { irRadius 0 moveto } if
	ixClockwise {
		0 0 irRadius 0 irStopAngle irStartAngle sub arcn
	} {
		0 0 irRadius 0 irStopAngle irStartAngle sub arc
	} ifelse
	setmatrix
%?manual_end
} def
%?partend

%?partdef	baBeepPart
%?fn	baBeepPart
%?brief	call this part at the end of page0! part to call the beeper with various frequencys
%?bbox 0 0 79 79
/baBeepPart {
%?manual_beg
	/ixLmlWarn exch def					%?brief lml warning active	%?use INP	%?type BOOL	%?dflt false
	/ixLmlStop exch def					%?brief lml stop active		%?use INP	%?type BOOL	%?dflt false
	/ixLmlActive exch def				%?brief lml active			%?use INP	%?type BOOL	%?dflt false
	/ixOneBeep exch def					%?brief set one beep		%?use INP	%?type BOOL	%?dflt false
	/qxOneBeep false def				%?brief reset the variable	%?use OUT	%?type BOOL	%?dflt false

	/LXmbeepAct false def
	/LXmbeepMsgPage false def

	MDbeepCount 0 gt { 
		/LXmbeepAct true store
	} if
	MDmsgValidNr MDmsgAcknNr gt {
		/LXmbeepMsgPage true store
	} {
		/LXmbeepMsgPage false store
	} ifelse

	% Aufruf des Beep
	ixLmlActive ixLmlStop and {
		MDtimeBeepLmlStopOn MDtimeBeepLmlStopOff MDfreqBeepLmlStopOn MDfreqBeepLmlStopOff MDbeepVolume true 
	} {
		ixLmlActive ixLmlWarn and {
			MDtimeBeepLmlWarnOn MDtimeBeepLmlWarnOff MDfreqBeepLmlWarnOn MDfreqBeepLmlWarnOff MDbeepVolume true 
		} {
			LXmbeepAct LXmbeepMsgPage or {
				MDtimeBeepOn MDtimeBeepOff MDfreqBeepOn MDfreqBeepOff MDbeepVolume true 
			} {
				0 0 0 0 0 false 
			} ifelse
		} ifelse
	} ifelse
	BeepCall
	% Beeper-Zähler für den nächsten Durchlauf auf 0 setzen
	/MDbeepCount 0 store

	% Aufruf eines einzelnen Beep
	ixOneBeep {
		MDtimeBeepOne MDfreqBeepOne MDbeepVolume true BeepCallOne
	} if

	% Aufruf eines einzelnen Beep (soll aufgerufen werden, wenn eine Fehleingabe erfolgte)
	MXfailureBeep {
		MDtimeBeepOne MDfreqBeepFailure MDbeepVolume true BeepCallOne
		/MXfailureBeep false store
	} if
%?manual_end
	qxOneBeep
} def
%?partend

%?partdef baFrame001
%?fn	baFrame001
%?brief	green Frame for selection
%?bbox	0 0 239 159
/baFrame001 {
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0

%?manual_beg
	currentcolor
	3 setlinewidth
	/LD_X2 MDsymbolGrid irScaleX mul 1 sub def
	/LD_Y2 MDsymbolGrid irScaleY mul 1 sub def
	/LD_X2Arc LD_X2 7 sub def
	/LD_Y2Arc LD_Y2 7 sub def
	Green
	7 2 moveto 
	LD_X2Arc 7 5 270 360 arc 
	LD_X2Arc LD_Y2Arc 5 0 90 arc 
	7 LD_Y2Arc 5 90 180 arc
	7 7 5 180 270 arc 
	stroke
	1 setlinewidth
	setcolor
%?manual_end
} def
%?partend

%?partdef baFrame002
%?fn	baFrame002
%?brief	green Frame for selection of Touchbutton 80 x 80
%?bbox	0 0 239 159
/baFrame002 {
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0

%?manual_beg
	currentcolor
	3 setlinewidth
	/LD_X2 MDsymbolGrid irScaleX mul 1 sub def
	/LD_Y2 MDsymbolGrid irScaleY mul 1 sub def
	/LD_X2Arc LD_X2 9 sub def
	/LD_Y2Arc LD_Y2 12 sub def
	Green
	12 4 moveto 
	LD_X2Arc 9 5 270 360 arc 
	LD_X2Arc LD_Y2Arc 5 0 90 arc 
	12 LD_Y2Arc 5 90 180 arc
	12 9 5 180 270 arc 
	stroke
	1 setlinewidth
	setcolor
%?manual_end
} def
%?partend

%?partdef baFrame003
%?fn	baFrame003
%?brief	scaleable Frame with selectable color and linewidth
%?bbox	0 0 239 159
/baFrame003 {
	/idDummy exch def	%?brief dummy %?use INP %?type REAL %?dflt 0.0
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/idColor exch def	%?brief activate any color %?use INP %?type DINT %?dflt 99
	/idLineWidth exch def	%?brief linewidth	%?use INP %?type DINT %?dflt 1

%?manual_beg
	currentcolor
	idColor sp_set_color

	idLineWidth setlinewidth_nlw

	/LD_X2 MDsymbolGrid irScaleX mul 1 sub def
	/LD_Y2 MDsymbolGrid irScaleY mul 1 sub def
	/LD_X2Arc LD_X2 7 sub def
	/LD_Y2Arc LD_Y2 7 sub def
	7 2 moveto 
	LD_X2Arc 7 5 270 360 arc 
	LD_X2Arc LD_Y2Arc 5 0 90 arc 
	7 LD_Y2Arc 5 90 180 arc
	7 7 5 180 270 arc 
	stroke

	1 setlinewidth
	setcolor
%?manual_end
} def
%?partend

%?touchdef baTouchButton001
%?fn	baTouchButton001
%?brief	touch button 80 x 80
%?bbox	0 0 79 79
/baTouchButton001 {
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
%?manual_beg
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend

%?touchdef baTouchButton002
%?fn	baTouchButton002
%?brief	touch button 80 x 75 for page-switch
%?bbox	0 0 79 79
/baTouchButton002 {
	TouchAreaInv
	newpath
	6 5 moveto 
	70 10 5 270 360 arc 
	70 68 5 0 90 arc 
	6 68 5 90 180 arc 
	6 10 5 180 270 arc 
	eofill
%?manual_beg
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 2 moveto 
		73 7 5 270 360 arc 
		73 65 5 0 90 arc 
		9 65 5 90 180 arc 
		9 7 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend


%?touchdef baTouchButton003
%?fn	baTouchButton003
%?brief	touch button 80 x 80 scaleable
%?bbox	0 0 239 159
/baTouchButton003 {
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0

%?manual_beg
	/LD_X2 MDsymbolGrid irScaleX mul 1 sub def
	/LD_Y2 MDsymbolGrid irScaleY mul 1 sub def
	/LD_X2Arc LD_X2 9 sub def
	/LD_Y2Arc LD_Y2 6 sub def
	
	TouchAreaInv
	newpath
	6 4 moveto 
	LD_X2Arc 9 5 270 360 arc 
	LD_X2Arc LD_Y2Arc 5 0 90 arc 
	6 LD_Y2Arc 5 90 180 arc
	6 9 5 180 270 arc 
	eofill
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 LD_Y2 rlineto
	LD_X2 0 rlineto
	0 LD_Y2 neg rlineto 
	ineofill
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		LD_X2Arc 3 add 6 5 270 360 arc 
		LD_X2Arc 3 add LD_Y2Arc 3 sub 5 0 90 arc 
		9 LD_Y2Arc 3 sub 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end
} def
%?partend

%?touchdef baTouchButton004
%?fn	baTouchButton004
%?brief	touch button 80 x 80 invisible, visible during touch button is active
%?bbox	0 0 79 79
/baTouchButton004 {
%?manual_beg
	_mstatus {
		_mxposd _myposd itransform 
		newpath 
		0 0 moveto
		0 79 rlineto
		79 0 rlineto
		0 -79 rlineto 
		ineofill {
			TouchAreaInv
			1 1 78 78 rectfill
		} if
	} if
%?manual_end 
	_mdown {	
		_mxposd _myposd itransform 
		 newpath 
		0 0 moveto
		0 79 rlineto
		79 0 rlineto
		0 -79 rlineto 
		ineofill 
		dup { /_mdown false store } if		
	} { 
		false 
	} ifelse 
} def
%?partend

%?touchdef baTouchButton005
%?fn	baTouchButton005
%?brief	touch button 80 x 80 invisible, visible during touch in the peripherals (240 x 240) is active
%?bbox	0 0 79 79
/baTouchButton005 {
%?manual_beg
	_mstatus {
		_mxposd _myposd itransform 
		newpath 
		-79 -79 moveto
		0 239 rlineto
		239 0 rlineto
		0 -239 rlineto 
		ineofill {
			TouchAreaInv
			0 0 moveto
			0 79 lineto
			79 79 lineto
			79 0 lineto 
			0 0 lineto 
			stroke
		} if
	} if
%?manual_end 
	_mdown {	
		_mxposd _myposd itransform 
		 newpath 
		0 0 moveto
		0 79 rlineto
		79 0 rlineto
		0 -79 rlineto 
		ineofill 
		dup { /_mdown false store } if		
	} { 
		false 
	} ifelse 
} def
%?partend

% ?touchdef baTouchButton006
% ?fn	baTouchButton006
% ?brief	touch button 80 x 80, leaves two boolean values on the stack: true at rising and true while the button is pressed
% ?bbox	0 0 79 79
/baTouchButton006 {
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
%?manual_beg
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mstatus {	
		LX_InArea
	} { 
		false 
	} ifelse 
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
% ?partend


%?touchdef baTouchButton007
%?fn	baTouchButton007
%?brief	touch button 80 x 80 invisible
%?bbox	0 0 79 79
/baTouchButton007 {
	_mdown {	
		_mxposd _myposd itransform 
		 newpath 
		0 0 moveto
		0 79 rlineto
		79 0 rlineto
		0 -79 rlineto 
		ineofill 
		dup { /_mdown false store } if		
	} { 
		false 
	} ifelse 
} def
%?partend

%?touchdef baTouchButton008
%?fn	baTouchButton008
%?brief	touch button 80 x 80, leaves true on the stack while the button is pressed
%?bbox	0 0 79 79
/baTouchButton008 {
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
%?manual_beg
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown _mstatus or {
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend

%?touchdef baTouchButton009
%?fn	baTouchButton009
%?brief	touch button 75 x 80 for page-switch
%?bbox	0 0 79 79
/baTouchButton009 {
	/ixLeftColumn exch def	%?brief touchbutton at left column %?use INP %?type BOOL %?dflt false
%?manual_beg
	TouchAreaInv 
	ixLeftColumn {
		newpath 
		7 4 moveto 
		65 9 5 270 360 arc 
		65 73 5 0 90 arc 
		7 73 5 90 180 arc 
		7 9 5 180 270 arc 
		eofill 
	} {
		newpath 
		11 4 moveto 
		69 9 5 270 360 arc 
		69 73 5 0 90 arc 
		11 73 5 90 180 arc 
		11 9 5 180 270 arc 
		eofill 
	} ifelse
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		ixLeftColumn {
			newpath
			10 1 moveto 
			68 6 5 270 360 arc 
			68 70 5 0 90 arc 
			10 70 5 90 180 arc 
			10 6 5 180 270 arc 
			eofill
		} {
			newpath
			14 1 moveto 
			72 6 5 270 360 arc 
			72 70 5 0 90 arc 
			14 70 5 90 180 arc 
			14 6 5 180 270 arc 
			eofill
		} ifelse
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
	
} def
%?partend

%?touchdef baTouchButton010
%?fn	baTouchButton010
%?brief	touch button 80 x 80, visible 74 x 74, for page switch
%?bbox	0 0 79 79
/baTouchButton010 {
	TouchAreaInv
	newpath
	6 3 moveto 
	70 6 3 270 360 arc 
	70 70 3 0 90 arc 
	6 70 3 90 180 arc 
	6 6 3 180 270 arc 
	eofill
%?manual_beg
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 0 moveto 
		73 3 3 270 360 arc 
		73 67 3 0 90 arc 
		9 67 3 90 180 arc 
		9 3 3 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea { /_mdown false store } if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend

%?touchdef baTouchButton011
%?fn	baTouchButton011
%?brief	touch button 80 x 80, time delayed
%?bbox	0 0 79 79
/baTouchButton011 {
	/MEM_active_00 exch def	%?brief  %?use STATIC %?type BOOL
	/MEM_TimeAtStart exch def	%?brief time when button was pressed %?use STATIC %?type DINT
	/irStartDelayTime exch def	%?brief start delay time until the touch Button response	%?use INP %?type REAL %?dflt    1.00
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
%?manual_beg
	/L_TimeSinSta 0 def				% time since button pressed
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	stroke
	_mstatus {	
		realtime MEM_TimeAtStart sub abs				% hier wird der Absolutwert genommen, da realtime überläuft und negativ wird
		/L_TimeSinSta exch store						% Zeit seit dem Tastendruck in ms
		L_TimeSinSta irStartDelayTime 1000 mul gt {
			LX_Active
		} {
			LX_Active {									% Schraffierung zeichnen wenn der Button gedrückt ist, aber die Zeit noch nicht abgelaufen
				TouchArea
				newpath
				9 1 moveto 
				73 6 5 270 360 arc 
				73 70 5 0 90 arc 
				9 70 5 90 180 arc 
				9 6 5 180 270 arc 
				eofill
				TouchAreaInv
				3 setlinewidth
				5 67 moveto 
				12 74 lineto 
				stroke 
				5 59 moveto 
				20 74 lineto 
				stroke 
				6 52 moveto 
				28 74 lineto 
				stroke 
				6 44 moveto 
				36 74 lineto 
				stroke 
				6 36 moveto 
				44 74 lineto 
				stroke 
				6 28 moveto 
				52 74 lineto 
				stroke 
				6 20 moveto 
				60 74 lineto 
				stroke 
				6 12 moveto 
				68 74 lineto 
				stroke 
				6 4 moveto 
				75 73 lineto 
				stroke 
				13 3 moveto 
				76 66 lineto 
				stroke 
				21 3 moveto 
				76 58 lineto 
				stroke 
				29 3 moveto 
				76 50 lineto 
				stroke 
				37 3 moveto 
				76 42 lineto 
				stroke 
				45 3 moveto 
				76 34 lineto 
				stroke 
				53 3 moveto 
				76 26 lineto 
				stroke 
				61 3 moveto 
				76 18 lineto 
				stroke 
				69 3 moveto 
				76 10 lineto 
				stroke 
				1 setlinewidth
			} if
			false
		} ifelse
	} { 
		/MEM_TimeAtStart realtime store
		false 
	} ifelse 
	MEM_active_00
	FUB_R_TRIG
	/MEM_active_00 exch store
%?manual_end 
	MEM_active_00 MEM_TimeAtStart
} def
%?partend

%?touchdef baTouchButton012
%?fn	baTouchButton012
%?brief	touch button 80 x 80 invisible, time delayed
%?bbox	0 0 79 79
/baTouchButton012 {
	/MEM_active_00 exch def	%?brief  %?use STATIC %?type BOOL
	/MEM_TimeAtStart exch def	%?brief time when button was pressed %?use STATIC %?type DINT
	/irStartDelayTime exch def	%?brief start delay time until the touch Button response	%?use INP %?type REAL %?dflt    1.00
%?manual_beg
	/L_TimeSinSta 0 def				% time since button pressed
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	_mstatus {	
		realtime MEM_TimeAtStart sub abs				% hier wird der Absolutwert genommen, da realtime überläuft und negativ wird
		/L_TimeSinSta exch store						% Zeit seit dem Tastendruck in ms
		L_TimeSinSta irStartDelayTime 1000 mul gt {
			LX_Active
		} {
			false
		} ifelse
	} { 
		/MEM_TimeAtStart realtime store
		false 
	} ifelse 
	MEM_active_00
	FUB_R_TRIG
	/MEM_active_00 exch store
%?manual_end 
	MEM_active_00 MEM_TimeAtStart
} def
%?partend

%?partdef baTouchButPart001
%?fn	baTouchButPart001
%?brief	maintained touch button, stores its output until next activation
%?bbox	0 0 79 79
/baTouchButPart001 {
	/MEM_active exch def	%?brief Button is active %?use STATIC %?type BOOL
	/LX_Activated false def	%?brief Touch ist aktuell gedrückt  %?use LOC %?type BOOL %?dflt false
	/qxActive false def	%?brief Button is active (until next touch) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	baTouchButton001 {	
		/LX_Activated true store 
	} if 
	setcolor 
	setmatrix_nlw 
%?manual_beg
	LX_Activated {
		MEM_active {
			/MEM_active false store
		} {
			/MEM_active true store
		} ifelse
	} if
	/qxActive MEM_active store	
%?manual_end 
	
	qxActive MEM_active 
} def
%?partend

%?partdef baTouchButPart002
%?fn	baTouchButPart002
%?brief	touch button, sets its output at activation by touch (used to set a variable for one scan)
%?bbox	0 0 79 79
/baTouchButPart002 {
	/qxActive false def	%?brief Variable to set for one scan	%?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	baTouchButton001 {	
		/qxActive true store 
	} if 
	setcolor 
	setmatrix_nlw
	qxActive 
} def
%?partend

%?partdef baTouchButPart003
%?fn	baTouchButPart003
%?brief	touch button 80 x 75 for page-switch-line, sets its output at activation (used to set a variable for one scan)
%?bbox	0 0 79 79
/baTouchButPart003 {
	/qxActive false def	%?brief Variable to set for one scan	%?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	baTouchButton002 {	
		/qxActive true store 
	} if 
	setcolor 
	setmatrix_nlw 
	qxActive 
} def
%?partend
	
%?partdef baTouchButPart004
%?fn	baTouchButPart004
%?brief	touch button, increases or decreases a value by keeping the button pressed
%?bbox	0 0 79 79
/baTouchButPart004 {
	/MEM_TimeAtStart exch def	%?brief time when button was pressed %?use STATIC %?type DINT
	/MEM_ValueAtStart exch def	%?brief value when button was pressed %?use STATIC %?type DINT
	/irChangeStep exch def	%?brief change step: changes at single click %?use INP %?type REAL %?dflt    0.1
	/irChangeRate exch def	%?brief change rate: changes of change steps per second %?use INP %?type REAL %?dflt    50.00
	/irStartDelayTime exch def	%?brief start delay time until the value begins to be increased or decreased %?use INP %?type REAL %?dflt    1.00
	/ixIncrease exch def	%?brief increase the value (not decrease) %?use INP %?type BOOL %?dflt true
	/irValue exch def	%?brief value to be changed %?use INP %?type REAL %?dflt    0.00
	/qrValue 0 def	%?brief changed value %?use OUT %?type REAL %?dflt    0.00
%?manual_beg
	/L_Activated false def			% button pressed started (mDown)
	/L_Active false def				% button pressed
	/L_TimeSinSta 0 def				% time since button pressed
	/LI_rightDigStep	0	def
	/L_ActAutoChange	0	def		% change since automatic change startet
	/LR_help	0	def
	
	/qrValue irValue store

	0 0 moveto
	baTouchButton006
	/L_Activated exch store
	/L_Active exch store
	
	% zu verändernde Stellen ermitteln, damit bei Schnellvorlauf auch nur in diesen Schritten gesprungen wird (der endgültige Wert wird ja rechnerisch über realtime ermittelt)
	irChangeStep sp_getDeciPoint
	/LI_rightDigStep exch store

	% Zeitwerte lesen und speichern	
	L_Active {
		realtime
		MEM_TimeAtStart sub abs				% hier wird der Absolutwert genommen, da realtime überläuft und negativ wird
		/L_TimeSinSta exch store			% Zeit seit dem Tastendruck in ms
	} {
		realtime
		/MEM_TimeAtStart exch store
		/MEM_ValueAtStart irValue store
	} ifelse
	
	% Änderung des Wertes berechnen
	% Änderung um 1 bei Tastendruck
	L_Activated {
		ixIncrease { irValue irChangeStep add } { irValue irChangeStep sub } ifelse
		dup
		/MEM_ValueAtStart exch store
		/qrValue exch store
	} if
	% Änderung im Schnellauf
	L_TimeSinSta irStartDelayTime 1000 mul gt L_Active and {
		irChangeRate irChangeStep mul L_TimeSinSta 1000 div irStartDelayTime sub mul 		% Berechnung der Änderung pro Durchlauf
		/L_ActAutoChange exch store
		% Die Änderung pro Durchlauf soll bei Übergabe irChangeStep = 1 auch nur um 1 erfolgen usw.
		LI_rightDigStep 0 eq { L_ActAutoChange round cvi } if							% ACHTUNG Wert bleit am stack
		LI_rightDigStep 1 eq { L_ActAutoChange 10 mul round cvi cvr 10 div } if			% ACHTUNG Wert bleit am stack
		LI_rightDigStep 2 eq { L_ActAutoChange 100 mul round cvi cvr 100 div } if		% ACHTUNG Wert bleit am stack
		ixIncrease { MEM_ValueAtStart add } { MEM_ValueAtStart exch sub } ifelse
		/qrValue exch store
	} if

%?manual_end
	qrValue MEM_TimeAtStart MEM_ValueAtStart 
} def
%?partend

%?partdef baTouchButPart005
%?fn	baTouchButPart005
%?brief	touch button, stores its output while the button is pressed
%?bbox	0 0 79 79
/baTouchButPart005 {
	/qxActive false def	%?brief Button is active (touch is active) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	baTouchButton008 {	
		/qxActive true store 
	} if 
	setcolor 
	setmatrix_nlw 
	qxActive 
} def
%?partend

%?partdef baTouchButPart006
%?fn	baTouchButPart006
%?brief	touch button 80 x 75 for page-switch-line activated by its input, sets its output at activation by touch (used to set a variable for one scan)
%?bbox	0 0 79 79
/baTouchButPart006 {
	/ixButttonActive exch def	%?brief Part is active and Button is visible %?use INP %?type BOOL %?dflt false
	/qxActive false def	%?brief Variable to set for one scan %?use OUT %?type BOOL %?dflt false
	ixButttonActive true eq {	
		matrix currentmatrix_nlw 
		currentcolor 
		0 0 translate 
		0 rotate 
		1 1 scale 
		baTouchButton002 {	
			/qxActive true store 
		} if 
		setcolor 
		setmatrix_nlw 
	} if 
	qxActive 
} def
%?partend

%?partdef baTouchButPart007
%?fn	baTouchButPart007
%?brief	maintained touch button scaleable, stores its output until next activation
%?bbox	0 0 79 79
/baTouchButPart007 {
	/MEM_active exch def	%?brief Button is active %?use STATIC %?type BOOL
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/LX_Activated false def	%?brief Touch ist aktuell gedrückt  %?use LOC %?type BOOL %?dflt false
	/qxActive false def	%?brief Button is active (until next touch) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	irScaleX irScaleY
	baTouchButton003 {	
		/LX_Activated true store 
	} if 
	setcolor 
	setmatrix_nlw 
%?manual_beg
	LX_Activated {
		MEM_active {
			/MEM_active false store
		} {
			/MEM_active true store
		} ifelse
	} if
	/qxActive MEM_active store	
%?manual_end 
	
	qxActive MEM_active 
} def
%?partend

%?partdef baTouchButPart008
%?fn	baTouchButPart008
%?brief	maintained touch button, can also be setted from outside, input and output have to be connect to the same variable
%?bbox	0 0 79 79
/baTouchButPart008 {
	/ixActive exch def	%?brief Button is active (until next touch) %?use INP %?type BOOL %?dflt false
	/LX_Activated false def	%?brief Touch ist aktuell gedrückt  %?use LOC %?type BOOL %?dflt false
	/qxActive false def	%?brief Button is active (until next touch) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	baTouchButton001 {	
		/LX_Activated true store 
	} if 
	setcolor 
	setmatrix_nlw 
%?manual_beg
	/qxActive ixActive store
	LX_Activated {
		ixActive {
			/qxActive false store
		} {
			/qxActive true store
		} ifelse
	} if
%?manual_end 
	
	qxActive 
} def
%?partend

%?partdef baTouchButPart009
%?fn	baTouchButPart009
%?brief	maintained touch button scaleable, can also be setted from outside, input and output have to be connect to the same variable
%?bbox	0 0 79 79
/baTouchButPart009 {
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/ixActive exch def	%?brief Button is active (until next touch) %?use INP %?type BOOL %?dflt false
	/LX_Activated false def	%?brief Touch ist aktuell gedrückt  %?use LOC %?type BOOL %?dflt false
	/qxActive false def	%?brief Button is active (until next touch) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	irScaleX irScaleY 
	baTouchButton003 {	
		/LX_Activated true store 
	} if 
	setcolor 
	setmatrix_nlw 
%?manual_beg
	/qxActive ixActive store
	LX_Activated {
		ixActive {
			/qxActive false store
		} {
			/qxActive true store
		} ifelse
	} if
%?manual_end 
	
	qxActive 
} def
%?partend

%?partdef baTouchButPart011
%?fn	baTouchButPart011
%?brief	maintained invisible touch button, stores its output until next activation
%?bbox	0 0 79 79
/baTouchButPart011 {
	/MEM_active exch def	%?brief Button is active %?use STATIC %?type BOOL
	/LX_Activated false def	%?brief Touch ist aktuell gedrückt  %?use LOC %?type BOOL %?dflt false
	/qxActive false def	%?brief Button is active (until next touch) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	baTouchButton007 {	
		/LX_Activated true store 
	} if 
	setcolor 
	setmatrix_nlw 
%?manual_beg
	LX_Activated {
		MEM_active {
			/MEM_active false store
		} {
			/MEM_active true store
		} ifelse
	} if
	/qxActive MEM_active store	
%?manual_end 
	
	qxActive MEM_active 
} def
%?partend

%?partdef baTouchButPart012
%?fn	baTouchButPart012
%?brief	maintained, time delayed touch button, can also be setted from outside, input and output have to be connect to the same variable
%?bbox	0 0 79 79
/baTouchButPart012 {
	/MEM_TimeAtStart_00 exch def	%?brief  %?use STATIC %?type DINT
	/MEM_active_00_00 exch def	%?brief  %?use STATIC %?type BOOL
	/irStartDelayTime exch def	%?brief start delay time until the touch Button response %?use INP %?type REAL %?dflt    1.00
	/ixActive exch def	%?brief Button is active (until next touch) %?use INP %?type BOOL %?dflt false
	/LX_Activated false def	%?brief Touch ist aktuell gedrückt %?use LOC %?type BOOL %?dflt false
	/qxActive false def	%?brief Button is active (until next touch) %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	irStartDelayTime MEM_TimeAtStart_00 MEM_active_00_00 
	baTouchButton011 
	/MEM_TimeAtStart_00 exch store 
	/MEM_active_00_00 exch store {	
		/LX_Activated true store 
	} if 
	setcolor 
	setmatrix_nlw 
%?manual_beg
	/qxActive ixActive store
	LX_Activated {
		ixActive {
			/qxActive false store
		} {
			/qxActive true store
		} ifelse
	} if
%?manual_end 
	qxActive MEM_TimeAtStart_00 MEM_active_00_00 
} def
%?partend

%?partdef baTouchButPart013
%?fn	baTouchButPart013
%?brief	touch button time delayed, sets its output at activation by touch (used to set a variable for one scan)
%?bbox	0 0 79 79
/baTouchButPart013 {
	/MEM_active_00_00 exch def	%?brief  %?use STATIC %?type BOOL
	/MEM_TimeAtStart_00 exch def	%?brief  %?use STATIC %?type DINT
	/irStartDelayTime exch def	%?brief start delay time until the touch Button response %?use INP %?type REAL %?dflt    1.00
	/qxActive false def	%?brief Variable to set for one scan %?use OUT %?type BOOL %?dflt false
	matrix currentmatrix_nlw 
	currentcolor 
	0 0 translate 
	0 rotate 
	1 1 scale 
	irStartDelayTime 
	MEM_TimeAtStart_00 MEM_active_00_00 
	baTouchButton011 
	/MEM_TimeAtStart_00 exch store 
	/MEM_active_00_00 exch store {	
		/qxActive true store 
	} if 
	setcolor 
	setmatrix_nlw 
	qxActive MEM_active_00_00 MEM_TimeAtStart_00 
} def
%?partend

%?touchdef baTouchButTstsys001
%?fn	baTouchButTstsys001
%?brief	touch button 80 x 80, switch to the text based master testsystem, 
%?bbox	0 0 79 79
/baTouchButTstsys001 {
%?manual_beg
	realtime_sec testsys_timeout sub 0.5 lt { 
		false 
	} { 
		TouchAreaInv
		newpath
		6 4 moveto 
		70 9 5 270 360 arc 
		70 73 5 0 90 arc 
		6 73 5 90 180 arc 
		6 9 5 180 270 arc 
		eofill
		_mxposd _myposd itransform 
		newpath 
		0 0 moveto
		0 79 rlineto
		79 0 rlineto
		0 -79 rlineto 
		ineofill 
		/LX_InArea exch def
		/LX_Active false def
		LX_InArea _mstatus and {
			/LX_Active true store
		} if
		LX_Active not {
			TouchArea
			newpath
			9 1 moveto 
			73 6 5 270 360 arc 
			73 70 5 0 90 arc 
			9 70 5 90 180 arc 
			9 6 5 180 270 arc 
			eofill
		} if
		_mdown {	
			LX_InArea {
				/_mdown false store
				(testsys_master_start) 0 setsysparam
				/testsys_timeout realtime_sec store
			} if
			LX_InArea
		} { 
			false 
		} ifelse 
		stroke
	} ifelse
	1 setlinewidth_nlw
%?manual_end
} def
%?partend

%?touchdef baTouchButTstsys002
%?fn	baTouchButTstsys002
%?brief	touch button 80 x 80, switch to the graphical master testsystem, 
%?bbox	0 0 79 79
/baTouchButTstsys002 {
%?manual_beg
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea {
			/_mdown false store
			(start_project) (testsys) setsysparam
		} if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend

%?touchdef baTouchButTstsys003
%?fn	baTouchButTstsys003
%?brief	touch button 80 x 80, switch directly to the language page of the graphical master testsystem, 
%?bbox	0 0 79 79
/baTouchButTstsys003 {
%?manual_beg
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea {
			/_mdown false store
			(start_project) (testsys_language) setsysparam
		} if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend

%?touchdef baTouchButTstsys004
%?fn	baTouchButTstsys004
%?brief	touch button 80 x 80, switch directly to the tims and date page of the graphical master testsystem, 
%?bbox	0 0 79 79
/baTouchButTstsys004 {
%?manual_beg
	TouchAreaInv
	newpath
	6 4 moveto 
	70 9 5 270 360 arc 
	70 73 5 0 90 arc 
	6 73 5 90 180 arc 
	6 9 5 180 270 arc 
	eofill
	_mxposd _myposd itransform 
	newpath 
	0 0 moveto
	0 79 rlineto
	79 0 rlineto
	0 -79 rlineto 
	ineofill 
	/LX_InArea exch def
	/LX_Active false def
	LX_InArea _mstatus and {
		/LX_Active true store
	} if
	LX_Active not {
		TouchArea
		newpath
		9 1 moveto 
		73 6 5 270 360 arc 
		73 70 5 0 90 arc 
		9 70 5 90 180 arc 
		9 6 5 180 270 arc 
		eofill
	} if
	_mdown {	
		LX_InArea {
			/_mdown false store
			(start_project) (testsys_time) setsysparam
		} if
		LX_InArea
	} { 
		false 
	} ifelse 
	stroke
%?manual_end 
} def
%?partend


%?partdef baTouchString001
%?fn	baTouchString001
%?brief	touch text configurable, can be reseted by itself
%?bbox	-40 -20 39 19
/baTouchString001 {
	/idFontSelection  exch 	def		%?brief font		 				%?use INP %?type DINT %?dflt FSstdFont
	/idOrigin	exch 	def			%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idMark		exch 	def			%?brief activation mark: 0=no, 1= green frame, 2=green text, 3=blue area	%?use INP %?type DINT %?dflt 0
	/idDesign	exch 	def			%?brief design: 0=no, 1=frame, 2=underline	%?use INP %?type DINT %?dflt 0
	/isText		exch	def			%?brief actual content				%?use INP %?type STRI %?dflt (text)
	/ixActivated	exch 	def			%?brief TouchString is activated				%?use INP %?type BOOL %?dflt false
	/qxActivated 	false 	def			%?brief TouchString is activated				%?use OUT %?type BOOL %?dflt false
%?manual_beg
	/LD_X			0	def				% Länge des Touchfeldes
	/LD_Y			0	def				% Höhe des Touchfeldes
	/LD_XposVal		0	def				% X Position des Anzeige
	/LD_YposVal		0	def				% Y Position des Anzeige

	idFontSelection selectFont

	% Größe des Feldes Berechnen, incl. Festlegung Mindestbreite
	isText strw 10 add dup MDsymbolGrid 2 div lt { pop MDsymbolGrid 2 div } if
	/LD_X exch store
	/LD_Y strh 20 add store
	/LD_XposVal LD_X 2 div isText strw 2 div sub store
	/LD_YposVal LD_Y 2 div strh 2 div sub store

	matrix currentmatrix
	% Ursprung für Rahmen usw. versetzen
	idOrigin 1 lt { LD_X 2 div neg	LD_Y 2 div neg	translate } if
	idOrigin 1 eq { 0				0				translate } if
	idOrigin 2 eq { 0				LD_Y 2 div neg	translate } if
	idOrigin 3 eq { 0				LD_Y neg		translate } if
	idOrigin 4 eq { LD_X 2 div neg	LD_Y neg		translate } if
	idOrigin 5 eq { LD_X neg		LD_Y neg		translate } if
	idOrigin 6 eq { LD_X neg		LD_Y 2 div neg	translate } if
	idOrigin 7 eq { LD_X neg		0				translate } if
	idOrigin 8 ge { LD_X 2 div neg	0				translate } if

	% show design 2 (underline)
	idDesign 2 eq {				% draw underline
		% draw mark 2 (green text)
		currentcolor
		idMark 2 eq ixActivated and { Green } if
		LD_XposVal LD_YposVal 5 sub moveto
		isText strw 0 rlineto
		setcolor
	} if

	% draw mark 3 (blue area)
	idMark 3 eq ixActivated and {				% draw blue area
		currentcolor
		Blue
		0 0 LD_X LD_Y rectfill
		setcolor
	} if

	% touch area
	currentcolor
	matrix currentmatrix
	0 0 moveto
	LD_X MDsymbolGrid div LD_Y MDsymbolGrid div scale
	baTouchButton004
	dup ixActivated and {
		pop
		/qxActivated false store
	} {
		/qxActivated exch ixActivated or store
	} ifelse
	setmatrix
	setcolor

	% show string
	currentcolor
	% draw mark 2 (green text)
	idMark 2 eq ixActivated and { Green } if
	% positioning of the string
	LD_XposVal LD_YposVal moveto
	isText show_utf8
	% Cursor zeichnen
	ixActivated MXflashing and { (|) show_utf8 } if
	setcolor

	% show design 1 (frame)
	idDesign 1 eq {				% draw frame
		0 0 LD_X LD_Y rectstroke
	} if
	% draw mark 1 (green frame)
	currentcolor
	idMark 1 eq ixActivated and {
		3 setlinewidth
		Green
		0 0 LD_X LD_Y rectstroke
		1 setlinewidth
	} if
	setcolor

	setmatrix
%?manual_end 
	qxActivated
} def
%?partend

%?partdef baTouchString002
%?fn	baTouchString002
%?brief	touch trigger framed text (left, center) must be resetted by external
%?bbox	0 0 239 79
/baTouchString002 {
	/idFontSelection  exch 	def	%?brief font		 						%?use INP %?type DINT %?dflt FSstdFont
	/isText exch def			%?brief actual content						%?use INP %?type STRI %?dflt (text)
	/idMark	exch def			%?brief activation mark: 0=no, 1= green frame, 2=green text, 3=blue area	%?use INP %?type DINT %?dflt 0
	/idDesign  exch def			%?brief design: 0=no, 1=frame, 2=underline, 3=frame+cursor	%?use INP %?type DINT %?dflt 0
	/irScaleY exch def			%?brief scale Y (1 = 1 grid unit (80 hight)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def			%?brief scale X (1 = 1 grid unit (80 width)	%?use INP %?type REAL %?dflt 3.0
	/ixEnter exch def			%?brief key hit ENTER						%?use INP %?type BOOL %?dflt false
	/qxEnter false def			%?brief key hit ENTER						%?use OUT %?type BOOL %?dflt false
%?manual_beg
	/LD_X MDsymbolGrid irScaleX mul def
	/LD_Y MDsymbolGrid irScaleY mul def
	idDesign 1 eq 
	idDesign 3 eq or {
		idMark 1 eq {
			currentcolor
			3 setlinewidth
			Green
			2 2 LD_X 6 sub LD_Y 5 sub rectstroke
			1 setlinewidth
			setcolor
		} {
			idMark 3 eq {
				currentcolor
				Blue
				0 0 LD_X LD_Y rectfill
				setcolor
				2 2 LD_X 4 sub LD_Y 4 sub rectstroke
			} {
				2 2 LD_X 4 sub LD_Y 4 sub rectstroke
			} ifelse
		} ifelse 
	} if
	% show string
	idFontSelection selectFont
	12 LD_Y 2 div strh 2 div sub moveto
	isText show_utf8
	% Cursor zeichnen
	idDesign 3 eq MXflashing and { (|) show_utf8 } if
	% touch area
	0 0 moveto
	irScaleX irScaleY scale
	baTouchButton004
	/qxEnter exch store
	/qxEnter qxEnter ixEnter or store
%?manual_end 
	qxEnter
} def
%?partend

%?partdef baTouchString003
%?fn	baTouchString003
%?brief	touch text configurable with unit, can be reseted by itself, length can be adjusted
%?bbox	-40 -20 39 19
/baTouchString003 {
	/idFontSelection  exch 	def		%?brief font		 				%?use INP %?type DINT %?dflt FSstdFont
	/idUnit		exch 	def			%?brief unit selection				%?use INP %?type DINT %?dflt 0
	/idLength	exch 	def			%?brief length of the frame or area	%?use INP %?type DINT %?dflt 0
	/idOrigin	exch 	def			%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idMark		exch 	def			%?brief activation mark: 0=no, 1= green frame, 2=green text, 3=blue area	%?use INP %?type DINT %?dflt 0
	/idDesign	exch 	def			%?brief design: 0=no, 1=frame, 2=underline	%?use INP %?type DINT %?dflt 0
	/isText		exch	def			%?brief actual content				%?use INP %?type STRI %?dflt (text)
	/ixActivated	exch 	def			%?brief TouchString is activated				%?use INP %?type BOOL %?dflt false
	/qxActivated 	false 	def			%?brief TouchString is activated				%?use OUT %?type BOOL %?dflt false
%?manual_beg
	/LS_TextUnit 	()	def
	/LD_X	idLength	def				% Länge des Touchfeldes
	/LD_Y			0	def				% Höhe des Touchfeldes
	/LD_XposVal		0	def				% X Position des Anzeige
	/LD_YposVal		0	def				% Y Position des Anzeige

	idFontSelection selectFont
	
	/LS_TextUnit isText (|) strcat idUnit sp_set_unit strcat store

	% Größe des Feldes Berechnen, incl. Festlegung Mindestbreite
	idLength dup MDsymbolGrid 2 div lt { pop MDsymbolGrid 2 div } if
	LS_TextUnit strw 10 add dup 2 index gt { exch pop } { pop } ifelse
	/LD_X exch store
	/LD_Y strh 20 add store
	/LD_XposVal LD_X 2 div LS_TextUnit strw 2 div sub store
	/LD_YposVal LD_Y 2 div strh 2 div sub store

	matrix currentmatrix
	% Ursprung für Rahmen usw. versetzen
	idOrigin 1 lt { LD_X 2 div neg	LD_Y 2 div neg	translate } if
	idOrigin 1 eq { 0				0				translate } if
	idOrigin 2 eq { 0				LD_Y 2 div neg	translate } if
	idOrigin 3 eq { 0				LD_Y neg		translate } if
	idOrigin 4 eq { LD_X 2 div neg	LD_Y neg		translate } if
	idOrigin 5 eq { LD_X neg		LD_Y neg		translate } if
	idOrigin 6 eq { LD_X neg		LD_Y 2 div neg	translate } if
	idOrigin 7 eq { LD_X neg		0				translate } if
	idOrigin 8 ge { LD_X 2 div neg	0				translate } if

	% show design 2 (underline)
	idDesign 2 eq {				% draw underline
		% draw mark 2 (green text)
		currentcolor
		idMark 2 eq ixActivated and { Green } if
		LD_XposVal LD_YposVal 5 sub moveto
		LS_TextUnit strw 0 rlineto
		setcolor
	} if

	% draw mark 3 (blue area)
	idMark 3 eq ixActivated and {				% draw blue area
		currentcolor
		Blue
		0 0 LD_X LD_Y rectfill
		setcolor
	} if

	% touch area
	currentcolor
	matrix currentmatrix
	0 0 moveto
	LD_X MDsymbolGrid div LD_Y MDsymbolGrid div scale
	baTouchButton004
	dup ixActivated and {
		pop
		/qxActivated false store
	} {
		/qxActivated exch ixActivated or store 
	} ifelse
	setmatrix
	setcolor

	% show string
	currentcolor
	% draw mark 2 (green text)
	idMark 2 eq ixActivated and { Green } if
	% positioning of the string
	LD_XposVal LD_YposVal moveto
	isText show_utf8
	% Cursor zeichnen
	ixActivated MXflashing and { (|) show_utf8 } { (|) strw 0 rmoveto } ifelse
	% Einheit zeichnen
	idUnit sp_set_unit show_utf8
	setcolor

	% show design 1 (frame)
	idDesign 1 eq {				% draw frame
		0 0 LD_X LD_Y rectstroke
	} if
	% draw mark 1 (green frame)
	currentcolor
	idMark 1 eq ixActivated and {
		3 setlinewidth
		Green
		0 0 LD_X LD_Y rectstroke
		1 setlinewidth
	} if
	setcolor

	setmatrix
%?manual_end 
	qxActivated
} def
%?partend

%?partdef baTouchValue001
%?fn	baTouchValue001
%?brief	touch real value configurable, can be reseted by itself
%?bbox	-40 -20 39 19
/baTouchValue001 {
	/idFontSelection  exch 	def	%?brief font		 							%?use INP %?type DINT %?dflt FSstdFont
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idMark  exch 	def			%?brief activation mark: 0=no, 1= green frame, 2=green text, 3=blue area	%?use INP %?type DINT %?dflt 0
	/idDesign  exch 	def		%?brief design: 0=no, 1=frame, 2=underline		%?use INP %?type DINT %?dflt 0
	/irDeciNumb exch def		%?brief code of the shown decimal places		%?use INP %?type REAL %?dflt 2.1
	/irValue exch def			%?brief actual content							%?use INP %?type REAL %?dflt 0.0
	/ixActivated exch def			%?brief TouchString is activated							%?use INP %?type BOOL %?dflt false
	/qxActivated false def			%?brief TouchString is activated							%?use OUT %?type BOOL %?dflt false
%?manual_beg
	/LS_helps 	()	def			% String definieren
	/LS_Value 	()	def
	/LS_ValueMax 	()	def
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def
	/LD_X			0	def				% Länge des Touchfeldes
	/LD_Y			0	def				% Höhe des Touchfeldes
	/LD_XposVal		0	def				% X Position des Anzeige
	/LD_YposVal		0	def				% Y Position des Anzeige

	idFontSelection selectFont

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

 	% Anzuzeigenden Wert in einem String speichern
	/LS_Value irValue LS_helps LI_rightDigits ncvs store
	/LS_ValueMax irValue LS_helps LI_leftDigits LI_rightDigits nncvs store
	
	% Größe des Feldes Berechnen, incl. Festlegung Mindestbreite
	LS_ValueMax strw 10 add dup MDsymbolGrid 2 div lt { pop MDsymbolGrid 2 div } if
	/LD_X exch store
	/LD_Y strh 20 add store
	/LD_XposVal LD_X 2 div LS_Value strw 2 div sub store
	/LD_YposVal LD_Y 2 div strh 2 div sub store

	matrix currentmatrix
	% Ursprung für Rahmen usw. versetzen
	idOrigin 1 lt { LD_X 2 div neg	LD_Y 2 div neg	translate } if
	idOrigin 1 eq { 0				0				translate } if
	idOrigin 2 eq { 0				LD_Y 2 div neg	translate } if
	idOrigin 3 eq { 0				LD_Y neg		translate } if
	idOrigin 4 eq { LD_X 2 div neg	LD_Y neg		translate } if
	idOrigin 5 eq { LD_X neg		LD_Y neg		translate } if
	idOrigin 6 eq { LD_X neg		LD_Y 2 div neg	translate } if
	idOrigin 7 eq { LD_X neg		0				translate } if
	idOrigin 8 ge { LD_X 2 div neg	0				translate } if

	% show design 2 (underline)
	idDesign 2 eq {				% draw underline
		% draw mark 2 (green text)
		currentcolor
		idMark 2 eq ixActivated and { Green } if
		LD_XposVal LD_YposVal 5 sub moveto
		LS_Value strw 0 rlineto
		setcolor
	} if

	% draw mark 3 (blue area)
	idMark 3 eq ixActivated and {				% draw blue area
		currentcolor
		Blue
		0 0 LD_X LD_Y rectfill
		setcolor
	} if

	% touch area
	currentcolor
	matrix currentmatrix
	0 0 moveto
	LD_X MDsymbolGrid div LD_Y MDsymbolGrid div scale
	baTouchButton004
	dup ixActivated and {
		pop
		/qxActivated false store
	} {
		/qxActivated exch ixActivated or store
	} ifelse
	setmatrix
	setcolor

	% show string
	currentcolor
	% draw mark 2 (green text)
	idMark 2 eq ixActivated and { Green } if
	% positioning of the string
	LD_XposVal LD_YposVal moveto
	LS_Value show_utf8
	% Cursor zeichnen
	ixActivated MXflashing and { (|) show_utf8 } if
	setcolor

	% show design 1 (frame)
	idDesign 1 eq {				% draw frame
		0 0 LD_X LD_Y rectstroke
	} if
	% draw mark 1 (green frame)
	currentcolor
	idMark 1 eq ixActivated and {
		3 setlinewidth
		Green
		0 0 LD_X LD_Y rectstroke
		1 setlinewidth
	} if
	setcolor

	setmatrix
%?manual_end 
	qxActivated
} def
%?partend

%?partdef baTouchValue002
%?fn	baTouchValue002
%?brief	touch integer value configurable, can be reseted by itself
%?bbox	-40 -20 39 19
/baTouchValue002 {
	/idFontSelection  exch 	def	%?brief font		 				%?use INP %?type DINT %?dflt FSstdFont
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center	%?use INP %?type DINT %?dflt 0
	/idMark  exch 	def			%?brief mark: 0=no, 1= green frame, 2=green text	%?use INP %?type DINT %?dflt 0
	/idDesign  exch 	def		%?brief mark: 0=no, 1=frame, 2=underline, 3=blue area	%?use INP %?type DINT %?dflt 0
	/idValue exch def			%?brief actual content				%?use INP %?type DINT %?dflt 0
	/ixActivated exch def			%?brief TouchString is activated				%?use INP %?type BOOL %?dflt false
	/qxActivated false def			%?brief TouchString is activated				%?use OUT %?type BOOL %?dflt false
%?manual_beg
	ixActivated idValue cvr 1.0 idDesign idMark idOrigin idFontSelection
	baTouchValue001
	/qxActivated exch store 
	/qxActivated qxActivated ixActivated or store
%?manual_end 
	qxActivated
} def
%?partend

%?partdef baTouchValue003
%?fn	baTouchValue003
%?brief	touch real value with unit configurable, can be reseted by itself
%?bbox	-40 -20 39 19
/baTouchValue003 {
	/idUnit  exch 	def	%?brief unit selection		 							%?use INP %?type DINT %?dflt 0
	/idFontSelection  exch 	def	%?brief font		 							%?use INP %?type DINT %?dflt FSstdFont
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idMark  exch 	def			%?brief activation mark: 0=no, 1= green frame, 2=green text, 3=blue area	%?use INP %?type DINT %?dflt 0
	/idDesign  exch 	def		%?brief design: 0=no, 1=frame, 2=underline		%?use INP %?type DINT %?dflt 0
	/irDeciNumb exch def		%?brief code of the shown decimal places		%?use INP %?type REAL %?dflt 2.1
	/irValue exch def			%?brief actual content							%?use INP %?type REAL %?dflt 0.0
	/ixActivated exch def			%?brief TouchString is activated							%?use INP %?type BOOL %?dflt false
	/qxActivated false def			%?brief TouchString is activated							%?use OUT %?type BOOL %?dflt false
%?manual_beg

	/LS_helps 	()	def			% String definieren
	/LS_Value 	()	def
	/LS_ValueUnit 	()	def
	/LS_ValueMax 	()	def
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def
	/LD_X			0	def				% Länge des Touchfeldes
	/LD_Y			0	def				% Höhe des Touchfeldes
	/LD_XposVal		0	def				% X Position des Anzeige
	/LD_YposVal		0	def				% Y Position des Anzeige

	idFontSelection selectFont

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

 	% Anzuzeigenden Wert in einem String speichern
	/LS_Value irValue LS_helps LI_rightDigits ncvs store
	/LS_ValueUnit LS_Value (|) strcat idUnit sp_set_unit strcat store
	/LS_ValueMax irValue LS_helps LI_leftDigits LI_rightDigits nncvs (|) strcat idUnit sp_set_unit strcat store
	
	% Größe des Feldes Berechnen, incl. Festlegung Mindestbreite
	LS_ValueMax strw 10 add dup MDsymbolGrid 2 div lt { pop MDsymbolGrid 2 div } if
	/LD_X exch store
	/LD_Y strh 20 add store
	/LD_XposVal LD_X 2 div LS_ValueUnit strw 2 div sub store
	/LD_YposVal LD_Y 2 div strh 2 div sub store

	matrix currentmatrix
	% Ursprung für Rahmen usw. versetzen
	idOrigin 1 lt { LD_X 2 div neg	LD_Y 2 div neg	translate } if
	idOrigin 1 eq { 0				0				translate } if
	idOrigin 2 eq { 0				LD_Y 2 div neg	translate } if
	idOrigin 3 eq { 0				LD_Y neg		translate } if
	idOrigin 4 eq { LD_X 2 div neg	LD_Y neg		translate } if
	idOrigin 5 eq { LD_X neg		LD_Y neg		translate } if
	idOrigin 6 eq { LD_X neg		LD_Y 2 div neg	translate } if
	idOrigin 7 eq { LD_X neg		0				translate } if
	idOrigin 8 ge { LD_X 2 div neg	0				translate } if

	% show design 2 (underline)
	idDesign 2 eq {				% draw underline
		% draw mark 2 (green text)
		currentcolor
		idMark 2 eq ixActivated and { Green } if
		LD_XposVal LD_YposVal 5 sub moveto
		LS_ValueUnit strw 0 rlineto
		setcolor
	} if

	% draw mark 3 (blue area)
	idMark 3 eq ixActivated and {				% draw blue area
		currentcolor
		Blue
		0 0 LD_X LD_Y rectfill
		setcolor
	} if

	% touch area
	currentcolor
	matrix currentmatrix
	0 0 moveto
	LD_X MDsymbolGrid div LD_Y MDsymbolGrid div scale
	baTouchButton004
	dup ixActivated and {
		pop
		/qxActivated false store
	} {
		/qxActivated exch ixActivated or store
	} ifelse
	setmatrix
	setcolor

	% show string
	currentcolor
	% draw mark 2 (green text)
	idMark 2 eq ixActivated and { Green } if
	% positioning of the string
	LD_XposVal LD_YposVal moveto
	LS_Value show_utf8
	% Cursor zeichnen
	ixActivated MXflashing and { (|) show_utf8 } { (|) strw 0 rmoveto } ifelse
	% Einheit zeichnen
	idUnit sp_set_unit show_utf8
	setcolor

	% show design 1 (frame)
	idDesign 1 eq {				% draw frame
		0 0 LD_X LD_Y rectstroke
	} if
	% draw mark 1 (green frame)
	currentcolor
	idMark 1 eq ixActivated and {
		3 setlinewidth
		Green
		0 0 LD_X LD_Y rectstroke
		1 setlinewidth
	} if
	setcolor

	setmatrix
%?manual_end 
	qxActivated
} def
%?partend


%?partdef baPageLine001
%?fn baPageLine001
%?brief	stripline for horizontal separation of the touch buttons for page switch
%?bbox	0 0 959 79
/baPageLine001 {
%?manual_beg
	/idPageNumber exch def		%?brief number of the active page	%?use INP %?type DINT %?dflt 1
	/LDx MDsymbolGrid idPageNumber 1 sub mul def
	3 setlinewidth_nlw
	idPageNumber 0 eq {
		2 MDsymbolGrid 3 sub moveto
		MDscreenPixX 3 sub MDsymbolGrid 3 sub lineto
		stroke 
	} {
		2 MDsymbolGrid 3 sub moveto
		idPageNumber 1 ne {
			LDx 3 sub MDsymbolGrid 8 sub 5 90 0 arcn
		} if
		LDx 7 add 7 5 180 270 arc
		LDx MDsymbolGrid 8 sub add 7 5 -90 0 arc
		idPageNumber MDscreenPixX MDsymbolGrid div ne {
			LDx MDsymbolGrid 2 add add MDsymbolGrid 8 sub 5 180 90 arcn
		} if
		MDscreenPixX 3 sub MDsymbolGrid 3 sub lineto
		stroke 
	} ifelse
	1 setlinewidth_nlw
%?manual_end
} def
%?partend


%?partdef baPageLine002
%?fn baPageLine002
%?brief	stripline for free positioning
%?bbox	0 0 959 719
/baPageLine002 {
%?manual_beg
	/idY2 exch def	%?brief end point Y		%?use INP %?type DINT %?dflt 0
	/idX2 exch def	%?brief end point X		%?use INP %?type DINT %?dflt 0
	/idY1 exch def	%?brief start point Y	%?use INP %?type DINT %?dflt 0
	/idX1 exch def	%?brief start point X	%?use INP %?type DINT %?dflt 0
	3 setlinewidth_nlw
	LightGrey
	idX1 idY1 moveto
	idX2 idY2 lineto
	stroke
	1 setlinewidth_nlw
%?manual_end
} def
%?partend


%?partdef baPageLine003
%?fn baPageLine003
%?brief	stripline for free positioning with free linewidth
%?bbox	0 0 959 719
/baPageLine003 {
%?manual_beg
	/idY2 exch def	%?brief end point Y		%?use INP %?type DINT %?dflt 0
	/idX2 exch def	%?brief end point X		%?use INP %?type DINT %?dflt 0
	/idY1 exch def	%?brief start point Y	%?use INP %?type DINT %?dflt 0
	/idX1 exch def	%?brief start point X	%?use INP %?type DINT %?dflt 0
	/idLineWidth exch def	%?brief linewidth	%?use INP %?type DINT %?dflt 1

	idLineWidth setlinewidth_nlw
	idX1 idY1 moveto
	idX2 idY2 lineto
	stroke
	1 setlinewidth_nlw
%?manual_end
} def
%?partend

%?partdef baPageLine004
%?fn baPageLine004
%?brief	stripline for vertical separation of the touch buttons for page switch
%?bbox	0 0 79 719
/baPageLine004 {
%?manual_beg
	/idDummy exch def			%?brief dummy						%?use INP %?type REAL %?dflt 0.0
	/ixLeftColumn exch def		%?brief stripline at left column	%?use INP %?type BOOL %?dflt false
	/idMaxPageNumber exch def	%?brief maximum number of pages		%?use INP %?type DINT %?dflt 2
	/idPageNumber exch def		%?brief number of the active page	%?use INP %?type DINT %?dflt 1
	/LDy MDsymbolGrid idPageNumber 1 sub mul def
	3 setlinewidth_nlw
	ixLeftColumn {
		idPageNumber 1 eq {
			2 2 moveto
		} {
			MDsymbolGrid 3 sub 2 moveto
		} ifelse
		idPageNumber 1 gt idPageNumber idMaxPageNumber le and {
			MDsymbolGrid 8 sub LDy 3 sub 5 0 90 arc
			7 LDy 7 add 5 270 180 arcn
		} if
		idPageNumber 0 gt idPageNumber idMaxPageNumber lt and {
			7 LDy MDsymbolGrid 8 sub add 5 180 90 arcn
			MDsymbolGrid 8 sub LDy MDsymbolGrid 2 add add 5 270 360 arc
		} if
		idPageNumber idMaxPageNumber eq {
			2 idMaxPageNumber MDsymbolGrid mul 3 sub lineto
		} {
			MDsymbolGrid 3 sub idMaxPageNumber MDsymbolGrid mul 3 sub lineto
		} ifelse
	} {
		idPageNumber 1 eq {
			MDsymbolGrid 3 sub 2 moveto
		} {
			2 2 moveto
		} ifelse
		idPageNumber 1 gt idPageNumber idMaxPageNumber le and {
			7 LDy 3 sub 5 180 90 arcn
			MDsymbolGrid 8 sub LDy 7 add 5 270 360 arc
		} if
		idPageNumber 0 gt idPageNumber idMaxPageNumber lt and {
			MDsymbolGrid 8 sub LDy MDsymbolGrid 8 sub add 5 0 90 arc
			7 LDy MDsymbolGrid 2 add add 5 270 180 arcn
		} if
		idPageNumber idMaxPageNumber eq {
			MDsymbolGrid 3 sub idMaxPageNumber MDsymbolGrid mul 3 sub lineto
		} {
			2 idMaxPageNumber MDsymbolGrid mul 3 sub lineto
		} ifelse
	} ifelse
	stroke
	1 setlinewidth_nlw
%?manual_end
} def
%?partend

%?partdef baText001
%?fn baText001
%?brief	text with variable font, origin selectable
%?bbox	-40 -20 39 19
/baText001 {
%?manual_beg
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font	 %?use INP %?type DINT %?dflt FSstdFont
	/isText exch def			%?brief text 	 %?use INP %?type STRI %?dflt text
	idFontSelection selectFont	
	idOrigin 0 le { isText strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { isText strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { isText strw neg			strh neg		moveto } if
	idOrigin 6 eq { isText strw neg			strh 2 div neg	moveto } if
	idOrigin 7 eq { isText strw neg			0				moveto } if
	idOrigin 8 ge { isText strw 2 div neg	0				moveto } if
	isText show_utf8
%?manual_end
} def
%?partend

%?partdef baText002
%?fn baText002
%?brief	text with variable font, origin selectable, color selectable
%?bbox	-40 -20 39 19
/baText002 {
%?manual_beg
	/ixGreen exch def	%?brief activate green color %?use INP %?type BOOL %?dflt false
	/ixBlue exch def	%?brief activate blue color %?use INP %?type BOOL %?dflt false
	/ixYellow exch def	%?brief activate yellow color %?use INP %?type BOOL %?dflt false
	/ixRed exch def	%?brief activate red color %?use INP %?type BOOL %?dflt false
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font	 %?use INP %?type DINT %?dflt FSstdFont
	/isText exch def			%?brief text 	 %?use INP %?type STRI %?dflt text

	currentcolor
	ixGreen { Green } if
	ixBlue { Blue } if
	ixYellow { Yellow } if
	ixRed { Red } if
	
	idFontSelection selectFont	
	idOrigin 0 le { isText strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { isText strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { isText strw neg			strh neg		moveto } if
	idOrigin 6 eq { isText strw neg			strh 2 div neg	moveto } if
	idOrigin 7 eq { isText strw neg			0				moveto } if
	idOrigin 8 ge { isText strw 2 div neg	0				moveto } if
	isText show_utf8
	setcolor
%?manual_end
} def
%?partend

%?partdef baText003
%?fn baText003
%?brief	text with variable font, origin selectable, color selectable, maximum shown characters selectable
%?bbox	-40 -20 39 19
/baText003 {
%?manual_beg
	/idDummy exch def			%?brief dummy input for future definitions				%?use INP	%?type DINT	%?dflt 0
	/idmaxLength	exch 	def		%?brief maximum length of the shown string	%?use INP %?type DINT %?dflt 480
	/ixGreen exch def	%?brief activate green color %?use INP %?type BOOL %?dflt false
	/ixBlue exch def	%?brief activate blue color %?use INP %?type BOOL %?dflt false
	/ixYellow exch def	%?brief activate yellow color %?use INP %?type BOOL %?dflt false
	/ixRed exch def	%?brief activate red color %?use INP %?type BOOL %?dflt false
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font	 %?use INP %?type DINT %?dflt FSstdFont
	/isText exch def			%?brief text 	 %?use INP %?type STRI %?dflt text
	
	/LS_text isText def
	{
		LS_text strw idmaxLength le { exit } if
		/LS_text LS_text dup length 1 sub strdelpos store
	} loop

	currentcolor
	ixGreen { Green } if
	ixBlue { Blue } if
	ixYellow { Yellow } if
	ixRed { Red } if
	
	idFontSelection selectFont	
	idOrigin 0 le { LS_text strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_text strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_text strw neg			strh neg		moveto } if
	idOrigin 6 eq { LS_text strw neg			strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_text strw neg			0				moveto } if
	idOrigin 8 ge { LS_text strw 2 div neg	0				moveto } if
	LS_text show_utf8
	setcolor
%?manual_end
} def
%?partend


%?partdef baValueText001
%?fn baValueText001
%?brief	digital value with text prefix and postfix, origin selectable, signed/unsigned selectable, leading zero selectable
%?bbox	-59 0 60 39
/baValueText001 {
%?manual_beg
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font								%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active					%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active				%?use INP %?type BOOL %?dflt false
	/ixLeadZero exch def		%?brief show value with leading zero		%?use INP %?type BOOL %?dflt false
	/ixSigned exch def			%?brief show value signed					%?use INP %?type BOOL %?dflt false
	/isPostfix exch def			%?brief postfix (text to show after value)	%?use INP %?type STRI %?dflt ()
	/isPrefix exch def			%?brief prefix (text to show before value)	%?use INP %?type STRI %?dflt ()
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown					%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LS_text	()	def
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store


	% Numerischen Wert aufbereiten
	ixLeadZero {
		irValue LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	}{
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
	} ifelse
	ixSigned irValue 0 gt and {
		(+) exch strcat
	} if
	% gesamten Text mit prefix und postfix erstellen
	isPostfix strcat
	isPrefix exch strcat
	/LS_text exch store

	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LS_text strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_text strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_text strw neg			strh neg		moveto } if
	idOrigin 6 eq { LS_text strw neg			strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_text strw neg			0				moveto } if
	idOrigin 8 ge { LS_text strw 2 div neg	0				moveto } if
	idOrigin 9 ge {
		isPrefix strw
		ixLeadZero { (8) strw LI_leftDigits mul add } { LI_leftLength add } ifelse
		ixSigned { (+) strw add } if
		neg 0 moveto
	} if
	LS_text show_utf8

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueText002
%?fn baValueText002
%?brief	digital value with text prefix and unit, unit selectable, origin selectable, signed/unsigned selectable, leading zero selectable
%?bbox	-59 0 60 39
/baValueText002 {
%?manual_beg
	/idDummy exch def			%?brief dummy input for future definitions				%?use INP	%?type DINT	%?dflt 0
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font								%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active					%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active				%?use INP %?type BOOL %?dflt false
	/ixLeadZero exch def		%?brief show value with leading zero		%?use INP %?type BOOL %?dflt false
	/ixSigned exch def			%?brief show value signed					%?use INP %?type BOOL %?dflt false
	/idUnit exch def			%?brief unit f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 10
	/isPrefix exch def			%?brief prefix (text to show before value)	%?use INP %?type STRI %?dflt ()
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown					%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LS_unit	()	def
	/LS_text	()	def
	/LR_value	0.0	def
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	irValue idUnit
	sp_calc_imperial
	/LR_value exch store
	idUnit
	sp_set_unit
	/LS_unit exch store

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Anzuzeigende Stellen ermitteln
	LR_value irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Numerischen Wert aufbereiten
	ixLeadZero {
		LR_value LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	}{
		LR_value LS_helps LI_rightDigits ncvs			% in string umwandeln
	} ifelse
	ixSigned LR_value 0 gt and {
		(+) exch strcat
	} if
	% gesamten Text mit prefix und postfix erstellen
	LS_unit strcat
	isPrefix exch strcat
	/LS_text exch store

	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LS_text strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_text strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_text strw neg		strh neg		moveto } if
	idOrigin 6 eq { LS_text strw neg		strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_text strw neg		0				moveto } if
	idOrigin 8 ge { LS_text strw 2 div neg	0				moveto } if
	idOrigin 9 ge {
		isPrefix strw
		ixLeadZero { (8) strw LI_leftDigits mul add } { LI_leftLength add } ifelse
		ixSigned { (+) strw add } if
		neg 0 moveto
	} if
	LS_text show_utf8

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueText003
%?fn baValueText003
%?brief	digital value with text prefix and unit, color selectable, unit selectable, origin selectable, signed/unsigned selectable, leading zero selectable
%?bbox	-59 0 60 39
/baValueText003 {
%?manual_beg
	/idDummy exch def			%?brief dummy input for future definitions				%?use INP	%?type DINT	%?dflt 0
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font								%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active					%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active				%?use INP %?type BOOL %?dflt false
	/ixNormGreenActive exch def	%?brief normal color green active			%?use INP %?type BOOL %?dflt false
	/ixLeadZero exch def		%?brief show value with leading zero		%?use INP %?type BOOL %?dflt false
	/ixSigned exch def			%?brief show value signed					%?use INP %?type BOOL %?dflt false
	/idUnit exch def			%?brief unit f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 10
	/isPrefix exch def			%?brief prefix (text to show before value)	%?use INP %?type STRI %?dflt ()
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown					%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LS_unit	()	def
	/LS_text	()	def
	/LR_value	0.0	def
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	irValue idUnit
	sp_calc_imperial
	/LR_value exch store
	idUnit
	sp_set_unit
	/LS_unit exch store

	matrix currentmatrix
	currentcolor
	ixNormGreenActive { Green } if
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Anzuzeigende Stellen ermitteln
	LR_value irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Numerischen Wert aufbereiten
	ixLeadZero {
		LR_value LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	}{
		LR_value LS_helps LI_rightDigits ncvs			% in string umwandeln
	} ifelse
	ixSigned LR_value 0 gt and {
		(+) exch strcat
	} if
	% gesamten Text mit prefix und postfix erstellen
	LS_unit strcat
	isPrefix exch strcat
	/LS_text exch store

	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LS_text strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_text strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_text strw neg		strh neg		moveto } if
	idOrigin 6 eq { LS_text strw neg		strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_text strw neg		0				moveto } if
	idOrigin 8 ge { LS_text strw 2 div neg	0				moveto } if
	idOrigin 9 ge {
		isPrefix strw
		ixLeadZero { (8) strw LI_leftDigits mul add } { LI_leftLength add } ifelse
		ixSigned { (+) strw add } if
		neg 0 moveto
	} if
	LS_text show_utf8

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueText004
%?fn baValueText004
%?brief	digital value with text prefix, unit and postfix, color selectable, unit selectable, origin selectable, signed/unsigned selectable, leading zero selectable
%?bbox	-59 0 60 39
/baValueText004 {
%?manual_beg
	/idDummy exch def			%?brief dummy input for future definitions				%?use INP	%?type DINT	%?dflt 0
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font								%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active					%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active				%?use INP %?type BOOL %?dflt false
	/ixNormGreenActive exch def	%?brief normal color green active			%?use INP %?type BOOL %?dflt false
	/ixLeadZero exch def		%?brief show value with leading zero		%?use INP %?type BOOL %?dflt false
	/ixSigned exch def			%?brief show value signed					%?use INP %?type BOOL %?dflt false
	/isPostfix exch def			%?brief postfix (text to show after unit)	%?use INP %?type STRI %?dflt ()
	/idUnit exch def			%?brief unit f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 10
	/isPrefix exch def			%?brief prefix (text to show before value)	%?use INP %?type STRI %?dflt ()
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown					%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LS_unit	()	def
	/LS_text	()	def
	/LR_value	0.0	def
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	irValue idUnit
	sp_calc_imperial
	/LR_value exch store
	idUnit
	sp_set_unit
	/LS_unit exch store

	matrix currentmatrix
	currentcolor
	ixNormGreenActive { Green } if
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Anzuzeigende Stellen ermitteln
	LR_value irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Numerischen Wert aufbereiten
	ixLeadZero {
		LR_value LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	}{
		LR_value LS_helps LI_rightDigits ncvs			% in string umwandeln
	} ifelse
	ixSigned LR_value 0 gt and {
		(+) exch strcat
	} if
	% gesamten Text mit prefix, unit und postfix erstellen
	LS_unit strcat
	isPostfix strcat
	isPrefix exch strcat
	/LS_text exch store

	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LS_text strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_text strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_text strw neg		strh neg		moveto } if
	idOrigin 6 eq { LS_text strw neg		strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_text strw neg		0				moveto } if
	idOrigin 8 ge { LS_text strw 2 div neg	0				moveto } if
	idOrigin 9 ge {
		isPrefix strw
		ixLeadZero { (8) strw LI_leftDigits mul add } { LI_leftLength add } ifelse
		ixSigned { (+) strw add } if
		neg 0 moveto
	} if
	LS_text show_utf8

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baUnit001
%?fn baUnit001
%?brief	show selectable unit
%?bbox	-59 0 60 39
/baUnit001 {
%?manual_beg
	/idDummy exch def			%?brief dummy input for future definitions				%?use INP	%?type DINT	%?dflt 0
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/idFontSelection exch def	%?brief font								%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active					%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active				%?use INP %?type BOOL %?dflt false
	/idUnit exch def			%?brief unit f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 10

	/LS_unit	()	def

	idFontSelection selectFont

	idUnit
	sp_set_unit
	/LS_unit exch store

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LS_unit strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_unit strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_unit strw neg		strh neg		moveto } if
	idOrigin 6 eq { LS_unit strw neg		strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_unit strw neg		0				moveto } if
	idOrigin 8 ge { LS_unit strw 2 div neg	0				moveto } if
	LS_unit show_utf8

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValue001
%?fn baValue001
%?brief	digital value, origin at the comma
%?bbox	-59 0 60 39
/baValue001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/isUnit exch def			%?brief unit					%?use INP %?type STRI %?dflt ()
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	LI_leftLength neg 0 rmoveto
	% Numerischen Wert aufbereiten
	irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	irUnitScale dup scale
	isUnit show_utf8								% Einheit anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValue002
%?fn baValue002
%?brief	digital value, origin right, lower
%?bbox	-119 0 0 39
/baValue002 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/isUnit exch def			%?brief unit %?use INP %?type STRI %?dflt
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
	matrix currentmatrix
	irUnitScale dup scale
	isUnit strw irUnitScale mul						% Länge ermitteln
	1 add neg 0 translate							% Punkt zwischen Wert und Einheit
	1 0 moveto										% Anfangspunkt der Einheit
	isUnit show_utf8								% Einheit anzeigen
	0 0 moveto										% Punkt zwischen Wert und Einheit
	setmatrix
	-1 0 rmoveto									% ans Ende des Numerischen Wertes springen

	% Numerischen Wert aufbereiten
	irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
	dup strw										% Länge ermitteln
	neg 0 rmoveto
	show_utf8										% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValue003
%?fn baValue003
%?brief	digital value, origin left, lower
%?bbox	-59 0 60 39
/baValue003 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/isUnit exch def			%?brief unit %?use INP %?type STRI %?dflt
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	0 0 moveto
	% Numerischen Wert aufbereiten
	irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	irUnitScale dup scale
	isUnit show_utf8								% Einheit anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValue004
%?fn baValue004
%?brief	digital value without unit, origin at center, center
%?bbox	-59 0 60 39
/baValue004 {
%?manual_beg
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Numerischen Wert aufbereiten
	irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	dup strw 2 div neg strh 2 div neg moveto
	show_utf8										% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValue005
%?fn baValue005
%?brief	digital value with imperial unit calculation with unit shown selectable, origin selectable, leading zero selectable, signed selectable
%?bbox	-59 0 60 39
/baValue005 {
%?manual_beg
	/ixUnitShow exch def		%?brief show unit				%?use INP	%?type BOOL %?dflt false
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/ixLeadZero exch def		%?brief show value with leading zero		%?use INP %?type BOOL %?dflt false
	/ixSigned exch def			%?brief show value signed					%?use INP %?type BOOL %?dflt false
	/idUnit exch def			%?brief unit f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 10
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LR_value	0.0	def
	/LS_text	()	def
	/LS_unit	()	def
	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	irValue idUnit
	sp_calc_imperial
	/LR_value exch store
	idUnit
	sp_set_unit
	/LS_unit exch store

	matrix currentmatrix
	currentcolor

	% Anzuzeigende Stellen ermitteln
	LR_value irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Numerischen Wert aufbereiten
	ixLeadZero {
		LR_value LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	}{
		LR_value LS_helps LI_rightDigits ncvs			% in string umwandeln
	} ifelse
	ixSigned LR_value 0 gt and {
		(+) exch strcat
	} if
	/LS_text exch store

	% Einheit an den Text anhängen
	ixUnitShow { /LS_text LS_text LS_unit strcat store } if
	
	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LS_text strw 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0						0				moveto } if
	idOrigin 2 eq { 0						strh 2 div neg	moveto } if
	idOrigin 3 eq { 0						strh neg		moveto } if
	idOrigin 4 eq { LS_text strw 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LS_text strw neg		strh neg		moveto } if
	idOrigin 6 eq { LS_text strw neg		strh 2 div neg	moveto } if
	idOrigin 7 eq { LS_text strw neg		0				moveto } if
	idOrigin 8 ge { LS_text strw 2 div neg	0				moveto } if
	idOrigin 9 ge {
		ixLeadZero { (8) strw LI_leftDigits mul } { LI_leftLength } ifelse
		ixSigned { (+) strw add } if
		neg 0 moveto
	} if
	LS_text show_utf8										% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValue006
%?fn baValue006
%?brief	digital value with imperial unit calculation with unit shown selectable and scaleable, origin selectable, leading zero selectable, signed selectable
%?bbox	-59 0 60 39
/baValue006 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/ixUnitShow exch def		%?brief show unit				%?use INP	%?type BOOL %?dflt false
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 9=comma, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/ixLeadZero exch def		%?brief show value with leading zero		%?use INP %?type BOOL %?dflt false
	/ixSigned exch def			%?brief show value signed					%?use INP %?type BOOL %?dflt false
	/idUnit exch def			%?brief unit f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 10
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LR_unitOffset	2	def
	/LR_value	0.0	def
	/LR_width	0.0	def
	/LS_text	()	def
	/LS_unit	()	def
	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	irValue idUnit
	sp_calc_imperial
	/LR_value exch store
	idUnit
	sp_set_unit
	/LS_unit exch store

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Anzuzeigende Stellen ermitteln
	LR_value irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Numerischen Wert aufbereiten
	ixLeadZero {
		LR_value LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	}{
		LR_value LS_helps LI_rightDigits ncvs			% in string umwandeln
	} ifelse
	ixSigned LR_value 0 gt and {
		(+) exch strcat
	} if
	/LS_text exch store

	% Anzuzeigende Textbreite ermitteln	
	/LR_width LS_text strw store
	% Wenn die Einheit angezeigt wird, die skalierbare Einheit speziell ermitteln
	ixUnitShow {
		LR_unitOffset
		LS_unit strw irUnitScale mul add
		/LR_width LR_width 1 index add store pop
	} if
		
	% Text anzeigen
	% Koordinatenpunkt ermitteln
	idOrigin 0 le { LR_width 2 div neg	strh 2 div neg	moveto } if
	idOrigin 1 eq { 0					0				moveto } if
	idOrigin 2 eq { 0					strh 2 div neg	moveto } if
	idOrigin 3 eq { 0					strh neg		moveto } if
	idOrigin 4 eq { LR_width 2 div neg	strh neg		moveto } if
	idOrigin 5 eq { LR_width neg		strh neg		moveto } if
	idOrigin 6 eq { LR_width neg		strh 2 div neg	moveto } if
	idOrigin 7 eq { LR_width neg		0				moveto } if
	idOrigin 8 ge { LR_width 2 div neg	0				moveto } if
	idOrigin 9 ge {
		ixLeadZero { (8) strw LI_leftDigits mul } { LI_leftLength } ifelse
		ixSigned { (+) strw add } if
		neg 0 moveto
	} if
	LS_text show_utf8										% Wert anzeigen
	% Einheit nach dem Text anhängen
	ixUnitShow {
		LR_unitOffset 0 rmoveto
		irUnitScale dup scale
		LS_unit show_utf8 
	} if

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValue012
%?fn baValue012
%?brief	digital signed value, origin right, lower
%?bbox	-119 0 0 39
/baValue012 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/isUnit exch def			%?brief unit %?use INP %?type STRI %?dflt
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
	matrix currentmatrix
	irUnitScale dup scale
	isUnit strw irUnitScale mul						% Länge ermitteln
	1 add neg 0 translate							% Punkt zwischen Wert und Einheit
	1 0 moveto										% Anfangspunkt der Einheit
	isUnit show_utf8								% Einheit anzeigen
	0 0 moveto										% Punkt zwischen Wert und Einheit
	setmatrix
	-1 0 rmoveto									% ans Ende des Numerischen Wertes springen

	% Numerischen Wert aufbereiten
	irValue 0 gt {
		irValue LS_helps LI_rightDigits ncvs				% in string umwandeln
		(+) exch strcat
	} {
		irValue LS_helps LI_rightDigits ncvs				% in string umwandeln
	} ifelse
	dup strw										% Länge ermitteln
	neg 0 rmoveto
	show_utf8										% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValue022
%?fn baValue022
%?brief	digital value, origin right, lower with leading zero
%?bbox	-119 0 0 39
/baValue022 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/isUnit exch def			%?brief unit %?use INP %?type STRI %?dflt
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

	idFontSelection selectFont

	matrix currentmatrix

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
	matrix currentmatrix
	irUnitScale dup scale
	isUnit strw irUnitScale mul						% Länge ermitteln
	1 add neg 0 translate							% Punkt zwischen Wert und Einheit
	1 0 moveto										% Anfangspunkt der Einheit
	isUnit show_utf8								% Einheit anzeigen
	0 0 moveto										% Punkt zwischen Wert und Einheit
	setmatrix
	-1 0 rmoveto									% ans Ende des Numerischen Wertes springen

	% Numerischen Wert aufbereiten
	irValue LS_helps LI_leftDigits LI_rightDigits nncvs		% in string umwandeln
	dup strw										% Länge ermitteln
	neg 0 rmoveto
	show_utf8										% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueDist001
%?fn baValueDist001
%?brief	digital value for distance in [m] or [ft/in], origin at the comma
%?bbox	 -59 0 60 39
/baValueDist001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0 	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 0 moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Cursor vor das Komma setzen
	(.) strw 2 div
	neg 0 rmoveto

	MXchangeUnitDist {
		% Wenn im metrischen System Kommastellen angegeben werden, so werden im US-System feet und inch angezeigt, ansonsten nur feet

		irValue 39.37 mul								% Umrechnung in inch
		/LD_Input exch store							% Inch speichern
		% Numerischen Wert runden
		LD_Input cvi 0 eq {								% hier wird eine Division durch null verhindert: mod im else-Teil
			LD_Input cvi 0.5 ge { 1 } { 0 } ifelse
		} {
			LD_Input LD_Input cvi mod 0.5 ge {
				LD_Input cvi 1 add
			} {
				LD_Input cvi
			} ifelse
		} ifelse
		/LD_Input exch store							% Inch gerundet speichern
		
		% Numerischen Wert in feet und inch aufteilen
		LD_Input 12 div cvi								% ganze Feet ermitteln
		/LI_ValueFt exch store							% Feet speichern
		LD_Input LI_ValueFt 12 mul sub					% verbliebene Inch ermitteln
		/LI_ValueIn exch store							% Inch speichern

		% Wert anzeigen
		LI_rightDigits 0 gt {
			LI_ValueIn 0 lt LI_ValueFt 0 eq and {
				(-0)									% wenn ft=0 und die inch-Anzeige negativ ist muß das Vorzeichen bei den feet angezeigt werden (abfrage nur wenn ft 0 ist, sonst passt das Vorzeichen sowieso)
			} {
				LI_ValueFt LS_helps 0 ncvs				% in string umwandeln
			} ifelse
			dup strw			 						% stringlänge der feet-Anzeige
			neg 0 rmoveto
			show_utf8									% feet-Wert anzeigen
			(') show_utf8								% Einheit feet anzeigen
			(11) strw									% inch-Anzeige von hinten her positionieren, damit der Abstand zu feet immer gleich ist,egal ob 1 oder 11 inch angezeigt werden
			0 rmoveto
			LI_ValueIn abs LS_helps 0 ncvs				% in string umwandeln
			dup strw
			neg 0 rmoveto
			show_utf8									% inch-Wert anzeigen (ohne Vorzeichen, dieses wird bei den ft angezeigt)
			(") show_utf8								% Einheit inch anzeigen
		} {
			LI_ValueFt LS_helps 0 ncvs					% in string umwandeln
			dup strw									% stringlänge der feet-Anzeige ermitteln
			neg 0 rmoveto
			show_utf8									% feet-Wert anzeigen
			(') show_utf8								% Einheit feet anzeigen
		} ifelse
	} {
		LI_leftLength neg 0 rmoveto
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
	
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		matrix currentmatrix
		irUnitScale dup scale
		(m) show_utf8								% Einheit anzeigen
		setmatrix
		
	} ifelse
	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueDist002
%?fn baValueDist002
%?brief	digital value for distance in [m] or [ft/in], origin right, lower
%?bbox	 -119 0 0 39
/baValueDist002 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def		% wird hier nicht benötigt
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 0 moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	MXchangeUnitDist {
		% Wenn im metrischen System Kommastellen angegeben werden, so werden im US-System feet und inch angezeigt, ansonsten nur feet

		irValue 39.37 mul								% Umrechnung in inch
		/LD_Input exch store							% Inch speichern
		% Numerischen Wert runden
		LD_Input cvi 0 eq {								% hier wird eine Division durch null verhindert: mod im else-Teil
			LD_Input cvi 0.5 ge { 1 } { 0 } ifelse
		} {
			LD_Input LD_Input cvi mod 0.5 ge {
				LD_Input cvi 1 add
			} {
				LD_Input cvi
			} ifelse
		} ifelse
		/LD_Input exch store							% Inch gerundet speichern
		
		% Numerischen Wert in feet und inch aufteilen
		LD_Input 12 div cvi								% ganze Feet ermitteln
		/LI_ValueFt exch store							% Feet speichern
		LD_Input LI_ValueFt 12 mul sub					% verbliebene Inch ermitteln
		/LI_ValueIn exch store							% Inch speichern

		% Wert anzeigen
		LI_rightDigits 0 gt {
			LI_ValueIn 0 lt LI_ValueFt 0 eq and {
				(-0)									% wenn ft=0 und die inch-Anzeige negativ ist muß das Vorzeichen bei den feet angezeigt werden (abfrage nur wenn ft 0 ist, sonst passt das Vorzeichen sowieso)
			} {
				LI_ValueFt LS_helps 0 ncvs				% in string umwandeln
			} ifelse
			dup strw			 						% stringlänge der feet-Anzeige
			('11") strw add								% stringlänge der Einheiten und der inch-Anzeige
			neg 0 rmoveto
			show_utf8										% feet-Wert anzeigen
			(') show_utf8									% Einheit feet anzeigen
			(11) strw									% inch-Anzeige von hinten her positionieren, damit der abstand zu feet immer gleich ist,egal ob 1 oder 11 inch angezeigt werden
			0 rmoveto
			LI_ValueIn abs LS_helps 0 ncvs					% in string umwandeln
			dup strw
			neg 0 rmoveto
			show_utf8										% inch-Wert anzeigen
			(") show_utf8									% Einheit inch anzeigen
		} {
			LI_ValueFt LS_helps 0 ncvs					% in string umwandeln
			dup strw									% stringlänge der feet-Anzeige ermitteln
			(') strw add								% stringlänge der feet-Einheit addieren
			neg 0 rmoveto
			show_utf8										% feet-Wert anzeigen
			(') show_utf8									% Einheit feet anzeigen
		} ifelse
	} {
		% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
		matrix currentmatrix
		irUnitScale dup scale
		(m) strw irUnitScale mul						% Länge ermitteln
		1 add neg 0 translate							% Punkt zwischen Wert und Einheit
		1 0 moveto										% Anfangspunkt der Einheit
		(m) show_utf8								% Einheit anzeigen
		0 0 moveto										% Punkt zwischen Wert und Einheit
		setmatrix
		-1 0 rmoveto									% ans Ende des Numerischen Wertes springen

		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		dup strw										% Länge ermitteln
		neg 0 rmoveto
		show_utf8											% Wert anzeigen
	} ifelse
	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueDist003
%?fn	baValueDist003
%?brief	digital value for distance in [m] or [ft/in], origin left, lower
%?bbox	0 0 119 39
/baValueDist003 {
	
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 0 moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Cursor vor das Komma setzen
	(.) strw 2 div
	neg 0 rmoveto

	MXchangeUnitDist {
		% Wenn im metrischen System Kommastellen angegeben werden, so werden im US-System feet und inch angezeigt, ansonsten nur feet

		irValue 39.37 mul								% Umrechnung in inch
		/LD_Input exch store							% Inch speichern
		% Numerischen Wert runden
		LD_Input cvi 0 eq {								% hier wird eine Division durch null verhindert: mod im else-Teil
			LD_Input cvi 0.5 ge { 1 } { 0 } ifelse
		} {
			LD_Input LD_Input cvi mod 0.5 ge {
				LD_Input cvi 1 add
			} {
				LD_Input cvi
			} ifelse
		} ifelse
		/LD_Input exch store							% Inch gerundet speichern
		
		% Numerischen Wert in feet und inch aufteilen
		LD_Input 12 div cvi								% ganze Feet ermitteln
		/LI_ValueFt exch store							% Feet speichern
		LD_Input LI_ValueFt 12 mul sub					% verbliebene Inch ermitteln
		/LI_ValueIn exch store							% Inch speichern

		% Wert anzeigen
		LI_rightDigits 0 gt {
			LI_ValueIn 0 lt LI_ValueFt 0 eq and {
				(-0)									% wenn ft=0 und die inch-Anzeige negativ ist muß das Vorzeichen bei den feet angezeigt werden (abfrage nur wenn ft 0 ist, sonst passt das Vorzeichen sowieso)
			} {
				LI_ValueFt LS_helps 0 ncvs				% in string umwandeln
			} ifelse
			dup strw			 						% stringlänge der feet-Anzeige
			neg 0 rmoveto
			show_utf8									% feet-Wert anzeigen
			(') show_utf8								% Einheit feet anzeigen
			(11) strw									% inch-Anzeige von hinten her positionieren, damit der abstand zu feet immer gleich ist,egal ob 1 oder 11 inch angezeigt werden
			0 rmoveto
			LI_ValueIn abs LS_helps 0 ncvs					% in string umwandeln
			dup strw
			neg 0 rmoveto
			show_utf8									% inch-Wert anzeigen
			(") show_utf8								% Einheit inch anzeigen
		} {
			LI_ValueFt LS_helps 0 ncvs					% in string umwandeln
			dup strw									% stringlänge der feet-Anzeige ermitteln
			neg 0 rmoveto
			show_utf8									% feet-Wert anzeigen
			(') show_utf8								% Einheit feet anzeigen
		} ifelse
	} {
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
	
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		matrix currentmatrix
		irUnitScale dup scale
		(m) show_utf8								% Einheit anzeigen
		setmatrix
	} ifelse
	setcolor
	setmatrix
%?manual_end
	
} def
%?partend


%?partdef baValueDist004
%?fn	baValueDist004
%?brief	digital value for distance in [m] or [ft/in], origin left, center
%?bbox	0 0 119 39
/baValueDist004 {
	
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 strh 2 div neg moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Cursor vor das Komma setzen
	(.) strw 2 div
	neg 0 rmoveto

	MXchangeUnitDist {
		% Wenn im metrischen System Kommastellen angegeben werden, so werden im US-System feet und inch angezeigt, ansonsten nur feet

		irValue 39.37 mul								% Umrechnung in inch
		/LD_Input exch store							% Inch speichern
		% Numerischen Wert runden
		LD_Input cvi 0 eq {								% hier wird eine Division durch null verhindert: mod im else-Teil
			LD_Input cvi 0.5 ge { 1 } { 0 } ifelse
		} {
			LD_Input LD_Input cvi mod 0.5 ge {
				LD_Input cvi 1 add
			} {
				LD_Input cvi
			} ifelse
		} ifelse
		/LD_Input exch store							% Inch gerundet speichern
		
		% Numerischen Wert in feet und inch aufteilen
		LD_Input 12 div cvi								% ganze Feet ermitteln
		/LI_ValueFt exch store							% Feet speichern
		LD_Input LI_ValueFt 12 mul sub					% verbliebene Inch ermitteln
		/LI_ValueIn exch store							% Inch speichern

		% Wert anzeigen
		LI_rightDigits 0 gt {
			LI_ValueIn 0 lt LI_ValueFt 0 eq and {
				(-0)									% wenn ft=0 und die inch-Anzeige negativ ist muß das Vorzeichen bei den feet angezeigt werden (abfrage nur wenn ft 0 ist, sonst passt das Vorzeichen sowieso)
			} {
				LI_ValueFt LS_helps 0 ncvs				% in string umwandeln
			} ifelse
			show_utf8									% feet-Wert anzeigen
			(') show_utf8								% Einheit feet anzeigen
			(11) strw									% inch-Anzeige von hinten her positionieren, damit der abstand zu feet immer gleich ist,egal ob 1 oder 11 inch angezeigt werden
			0 rmoveto
			LI_ValueIn abs LS_helps 0 ncvs					% in string umwandeln
			dup strw
			neg 0 rmoveto
			show_utf8									% inch-Wert anzeigen
			(") show_utf8								% Einheit inch anzeigen
		} {
			LI_ValueFt LS_helps 0 ncvs					% in string umwandeln
			dup strw									% stringlänge der feet-Anzeige ermitteln
			neg 0 rmoveto
			show_utf8									% feet-Wert anzeigen
			(') show_utf8								% Einheit feet anzeigen
		} ifelse
	} {
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
	
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		matrix currentmatrix
		irUnitScale dup scale
		(m) show_utf8								% Einheit anzeigen
		setmatrix
	} ifelse
	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueDist005
%?fn baValueDist005
%?brief	digital value for distance in [cm] or [inch], origin right, lower
%?bbox	 -119 0 0 39
/baValueDist005 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def		% wird hier nicht benötigt
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	MXchangeUnitDist { /irValue irValue 2.54 div store } if	%unit conversion

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 0 moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	MXchangeUnitDist {
		% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
		(") strw										% Länge ermitteln
		2 add neg 0 translate							% Punkt zwischen Wert und Einheit
		2 0 moveto										% Punkt zum die Einheit schreiben
		(") show_utf8									% Einheit anzeigen
		-2 0 moveto										% ans Ende des Numerischen Wertes springen
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		dup strw										% Länge ermitteln
		neg 0 rmoveto
		show_utf8										% Wert anzeigen
	} {
		% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
		matrix currentmatrix
		irUnitScale dup scale
		(cm) strw irUnitScale mul						% Länge ermitteln
		1 add neg 0 translate							% Punkt zwischen Wert und Einheit
		1 0 moveto										% Anfangspunkt der Einheit
		(cm) show_utf8									% Einheit anzeigen
		0 0 moveto										% Punkt zwischen Wert und Einheit
		setmatrix
		-1 0 rmoveto									% ans Ende des Numerischen Wertes springen

		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		dup strw										% Länge ermitteln
		neg 0 rmoveto
		show_utf8										% Wert anzeigen
	} ifelse
	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueDist006
%?fn	baValueDist006
%?brief	digital value for distance in [cm] or [inch], origin left, lower
%?bbox	0 0 119 39
/baValueDist006 {
	
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	MXchangeUnitDist { /irValue irValue 2.54 div store } if	%unit conversion

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 0 moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Cursor vor das Komma setzen
	(.) strw 2 div
	neg 0 rmoveto

	MXchangeUnitDist {
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		(") show_utf8									% Einheit anzeigen		
	} {
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		matrix currentmatrix
		irUnitScale dup scale
		(cm) show_utf8								% Einheit anzeigen
		setmatrix
	} ifelse
	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueDist007
%?fn baValueDist007
%?brief	digital value for distance in [cm] or [inch], origin left, center
%?bbox	 0 0 119 39
/baValueDist007 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LI_ValueFt	0	def
	/LI_ValueIn	0	def
	/LD_Input	0	def

	MXchangeUnitDist { /irValue irValue 2.54 div store } if	%unit conversion

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	0 strh 2 div neg moveto

	% Anzuzeigende Stellen ermitteln
	irValue irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Cursor vor das Komma setzen
	(.) strw 2 div
	neg 0 rmoveto

	MXchangeUnitDist {
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		(") show_utf8									% Einheit anzeigen		
	} {
		% Numerischen Wert aufbereiten
		irValue LS_helps LI_rightDigits ncvs			% in string umwandeln
		show_utf8										% Wert anzeigen
		% Einheit anzeigen
		2 0 rmoveto										% Punkt zum die Einheit schreiben
		matrix currentmatrix
		irUnitScale dup scale
		(cm) show_utf8								% Einheit anzeigen
		setmatrix
	} ifelse
	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueDist008
%?fn	baValueDist008
%?brief	digital value for distance in [0.0 mm] or [.00 inch], origin at the comma
%?bbox	-20 -20 59 19
/baValueDist008 {
	
%?manual_beg
	/ixDummy1 exch def		%?brief dummy input	%?use INP %?type BOOL %?dflt false
	/ixDummy2 exch def		%?brief dummy input	%?use INP %?type BOOL %?dflt false
	/irDummy3 exch def		%?brief dummy input	%?use INP %?type REAL %?dflt 1.1
	/ixUnitShown exch def		%?brief show unit	%?use INP %?type BOOL %?dflt true
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren

	MXchangeUnitDist { /irValue irValue 2.54 div store } if	%unit conversion

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	0 0 moveto

	MXchangeUnitDist {
		% Cursor vor das Komma setzen
		ixUnitShown {
			(.) strw 2 div
		} {
			(.) strw 2 div (0) strw add
		} ifelse
		neg 0 rmoveto
		% Numerischen Wert aufbereiten
		(.) show_utf8									% comma zeichnen
		irValue 100 mul LS_helps 0 ncvs					% in string umwandeln
		show_utf8										% Wert anzeigen
		% Einheit anzeigen
		ixUnitShown {
			2 0 rmoveto										% Punkt zum die Einheit schreiben
			(") show_utf8									% Einheit anzeigen		
		} if
	} {
		% Cursor vor die Zahl setzen
		(.) strw 2 div (0) strw add
		neg 0 rmoveto
		% Numerischen Wert aufbereiten
		irValue LS_helps 1 ncvs							% in string umwandeln
		show_utf8										% Wert anzeigen
		% Einheit anzeigen
		ixUnitShown {
			2 0 rmoveto										% Punkt zum die Einheit schreiben
			matrix currentmatrix
			irUnitScale dup scale
			(mm) show_utf8								% Einheit anzeigen
			setmatrix
		} if
	} ifelse
	setcolor
	setmatrix
%?manual_end
	
} def
%?partend

%?partdef baValueLoad001
%?fn baValueLoad001
%?brief	digital value for load in [t] or [kip or lb/1000], origin at the comma
%?bbox	-59 0 60 39
/baValueLoad001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idUnitSelect exch def		%?brief selection of the unit: 1=kip, 2=lb, 3=lbx1000, 4=lb(/1000) %?use INP %?type DINT %?dflt 1
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LS_unit	(t)	def

	MXchangeUnitLoad {
		/LS_unit (kip) store
		idUnitSelect 2 eq { /LS_unit (lb) store } if
		idUnitSelect 3 eq { /LS_unit (lbx1000) store } if
		idUnitSelect 4 eq { /LS_unit (lb) store } if
	} if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitLoad {
		irValue 2.20462 mul
		idUnitSelect 2 eq {
			1000 mul								% Angabe in lb
		} if
	} {
		irValue
	} ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	MXchangeUnitLoad { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueLoad002
%?fn baValueLoad002
%?brief	digital value for load in [t] or [kip or lb/1000], origin right, lower
%?bbox	-119 0 0 39
/baValueLoad002 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idUnitSelect exch def		%?brief selection of the unit: 1=kip, 2=lb, 3=lbx1000 4=lb(/1000) %?use INP %?type DINT %?dflt 1
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(t)	def

	MXchangeUnitLoad {
		/LS_unit (kip) store
		idUnitSelect 2 eq { /LS_unit (lb) store } if
		idUnitSelect 3 eq { /LS_unit (lbx1000) store } if
		idUnitSelect 4 eq { /LS_unit (lb) store } if
	} if

	idFontSelection selectFont

	matrix currentmatrix

	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
	LS_unit strw										% Länge ermitteln
	2 add neg 0 translate							% Punkt zwischen Wert und Einheit
	2 0 moveto										% Punkt zum die Einheit schreiben

	matrix currentmatrix
	MXchangeUnitLoad { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix
	-2 0 moveto										% ans Ende des Numerischen Wertes springen

	% Numerischen Wert aufbereiten
	MXchangeUnitLoad {
		irValue 2.20462 mul
		idUnitSelect 2 eq {
			1000 mul								% Angabe in lb
		} if
	} {
		irValue
	} ifelse
	LS_helps LI_rightDigits ncvs			% in string umwandeln
	dup strw										% Länge ermitteln
	neg 0 rmoveto
	show_utf8											% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueLoad011
%?fn baValueLoad011
%?brief	digital value for load in [t] or [tn sh], origin at the comma
%?bbox	-59 0 60 39
/baValueLoad011 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_leftLength	0	def
	/LI_rightDigits	0	def
	/LS_unit	(t)	def

	MXchangeUnitLoad { /LS_unit (tn sh) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if
	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitLoad { irValue 1.10231 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	MXchangeUnitLoad { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueLoad012
%?fn baValueLoad012
%?brief	digital value for load in [t] or [tn sh], origin right, lower
%?bbox	-119 0 0 39
/baValueLoad012 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(t)	def

	MXchangeUnitLoad { /LS_unit (tn sh) store } if

	idFontSelection selectFont

	matrix currentmatrix

	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zwischen Zahlenwert und Einheit ermitteln
	LS_unit strw									% Länge ermitteln
	2 add neg 0 translate							% Punkt zwischen Wert und Einheit
	2 0 moveto										% Punkt zum die Einheit schreiben

	matrix currentmatrix
	MXchangeUnitLoad { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix
	-2 0 moveto										% ans Ende des Numerischen Wertes springen

	% Numerischen Wert aufbereiten
	MXchangeUnitLoad { irValue 1.10231 mul } { irValue } ifelse
	LS_helps LI_rightDigits ncvs			% in string umwandeln
	dup strw										% Länge ermitteln
	neg 0 rmoveto
	show_utf8											% Wert anzeigen

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueFlow001
%?fn baValueFlow001
%?brief	digital value for flow in [l/min] or [gal/min], origin at the comma
%?bbox	-59 0 60 39
/baValueFlow001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(l/min)	def

	MXchangeUnitVolume { /LS_unit (gal/min) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitVolume { irValue 0.26417 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	MXchangeUnitVolume { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueFlow002
%?fn baValueFlow002
%?brief	digital value for flow in [l/h] or [gal/h], origin at the comma
%?bbox	-59 0 60 39
/baValueFlow002 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(l/h)	def

	MXchangeUnitVolume { /LS_unit (gal/h) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitVolume { irValue 0.26417 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	MXchangeUnitVolume { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueSpeed001
%?fn baValueSpeed001
%?brief	digital value for speed in [m/s] or [mph], origin at the comma
%?bbox	-59 0 60 39
/baValueSpeed001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(m/s)	def

	MXchangeUnitSpeed { /LS_unit (mph) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitSpeed { irValue 2.23714 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	irUnitScale dup scale
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueSpeed002
%?fn baValueSpeed002
%?brief	digital value for speed in [m/s] or [kn], origin at the comma
%?bbox	-59 0 60 39
/baValueSpeed002 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(m/s)	def

	MXchangeUnitSpeed { /LS_unit (kn) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitSpeed { irValue 1.943844 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	irUnitScale dup scale
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValueSpeed003
%?fn baValueSpeed003
%?brief	digital value for speed in [m/min] or [ft/min], origin at the comma
%?bbox	-59 0 60 39
/baValueSpeed003 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(m/min)	def

	MXchangeUnitSpeed { /LS_unit (ft/min) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitSpeed { irValue 3.28084 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	irUnitScale dup scale
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueTemp001
%?fn baValueTemp001
%?brief	digital value for temperature in [°C] or [°F], origin at the comma
%?bbox	-59 0 60 39
/baValueTemp001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(Â°C)	def

	MXchangeUnitTemp { /LS_unit (Â°F) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitTemp { irValue 1.8 mul 32 add } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	irUnitScale dup scale
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend


%?partdef baValuePress001
%?fn baValuePress001
%?brief	digital value for pressure in [bar] or [psi], origin at the comma
%?bbox	-59 0 60 39
/baValuePress001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(bar)	def

	MXchangeUnitPress { /LS_unit (psi) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitPress { irValue 14.50377 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	irUnitScale dup scale
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValuePress002
%?fn baValuePress002
%?brief	digital value for pressure in [bar] (x.x) or [psi](xx) -> psi one decimal less, origin at the comma
%?bbox	-59 0 60 39
/baValuePress002 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(bar)	def

	MXchangeUnitPress { /LS_unit (psi) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitPress {
		/irDeciNumb irDeciNumb 1 add store
		irDeciNumb dup cvi mod 0 ne {
			/irDeciNumb irDeciNumb 0.1 sub store
			(8) strw 0 rmoveto						% Bei psi Anzeige wird ein Komma abgeschnitten und deshalb die Positionierung des Anzeigewertes nach rechts versetzt
			irDeciNumb dup cvi mod 0 eq { (.) strw 0 rmoveto } if
		} if
		irValue 14.50377 mul
	} {
		irValue
	} ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	irUnitScale dup scale
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baValueVolume001
%?fn baValueVolume001
%?brief	digital value for volume in [l] or [gal], origin at the comma
%?bbox	-59 0 60 39
/baValueVolume001 {
%?manual_beg
	/irUnitScale exch def		%?brief scale of the unit		%?use INP %?type REAL %?dflt 1.0
	/idFontSelection exch def	%?brief font					%?use INP %?type DINT %?dflt FSstdFont
	/ixErrorActive exch def		%?brief error color active		%?use INP %?type BOOL %?dflt false
	/ixWarnActive exch def		%?brief warning color active	%?use INP %?type BOOL %?dflt false
	/irDeciNumb exch def		%?brief code of the shown decimal places	%?use INP %?type REAL %?dflt 3.1
	/irValue exch def			%?brief value to be shown		%?use INP %?type REAL %?dflt 0

	/LS_helps 	()	def			% String definieren
	/LI_leftDigits	0	def
	/LI_rightDigits	0	def
	/LS_unit	(l)	def

	MXchangeUnitVolume { /LS_unit (gal) store } if

	idFontSelection selectFont

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Koordinaten-Punkt zur Anzeige des Wertes ermitteln
	(.) strw 2 div neg 0 moveto

	% Numerischen Wert aufbereiten
	MXchangeUnitVolume { irValue 0.26417 mul } { irValue } ifelse
	% Anzuzeigende Stellen ermitteln
	dup irDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store
	LI_leftLength neg 0 rmoveto
	LS_helps LI_rightDigits ncvs					% in string umwandeln
	show_utf8										% Wert anzeigen

	% Einheit anzeigen	
	2 0 rmoveto										% Punkt zum die Einheit schreiben
	matrix currentmatrix
	MXchangeUnitVolume { irUnitScale 0.75 mul dup scale } { irUnitScale dup scale } ifelse
	LS_unit show_utf8								% Einheit anzeigen
	setmatrix

	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baClock001
%?fn baClock001
%?brief	digital clock: 17:42:11
%?bbox	0 0 79 19
/baClock001 {
%?manual_beg
	/idFontSelection exch def	%?brief font				%?use INP %?type DINT %?dflt FSstdFont
	/ixSecDisp		 exch def	%?brief seconds displayed	%?use INP %?type BOOL %?dflt true
	
	gettime
	/L_hours exch def
	/L_minutes exch def
	/L_seconds exch def

	/LS_helps 	()	def			% String definieren
	/LX_xMax 	0	def			% maximale Breite eines Anzeigewertes

	idFontSelection selectFont

	matrix currentmatrix currentcolor

	% Zahlengrösse ermitteln
	(88) strw						% Länge ermitteln
	/LX_xMax exch store				% X-Wert speichern
	% Stunden anzeigen
	LX_xMax 0 translate				% Ursprung zum ersten Trennzeichen versetzen
	L_hours LS_helps 2 0 nncvs	% Stunden in String umwandeln
	dup strw						% Länge ermitteln
	neg 0 moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	% Minuten anzeigen
	0 0 moveto
	(:) show_utf8					% erstes Trennzeichen setzen
	LX_xMax 0 rmoveto
	currentpoint translate			% Ursprung zum zweiten Trennzeichen versetzen
	L_minutes LS_helps 2 0 nncvs	% Minuten in String umwandeln
	dup strw						% Länge ermitteln
	neg 0 moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	% Sekunden anzeigen
	0 0 moveto
	ixSecDisp {
		(:) show_utf8					% zweites Trennzeichen setzen
		LX_xMax 0 rmoveto
		currentpoint translate			% Ursprung hinter die Sekundenanzeige versetzen
		L_seconds LS_helps 2 0 nncvs	% Sekunden in String umwandeln
		dup strw						% Länge ermitteln
		neg 0 moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	} if

	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baClock002
%?fn baClock002
%?brief	analog clock
%?bbox	0 0 79 79
/baClock002 {
%?manual_beg
	/ixAmPm		exch def	%?brief a.m. or p.m. displayed	%?use INP %?type BOOL %?dflt true
	/ixSecDisp	exch def	%?brief seconds displayed		%?use INP %?type BOOL %?dflt true

	/LD_angle 0 store
	/L_hourAng 0 def
	/L_minAng 0 def
	/L_secAng 0 def
	
	% Uhrzeit holen
	gettime
	/L_hours exch def
	/L_minutes exch def
	/L_seconds exch def

	% Zeigerwinkel berechnen
	L_hours dup 12 ge { 12 sub } if
	-30 mul								% die Stunden in den Zeigerwinkel umrechnen (1 Stunde = 30°)
	L_minutes -0.5 mul add				% die Minuten in den Zeigerwinkel umrechnen (1 Minute = 0,5°)
	90 add 								% ausgehend von der Y-Achse
	/L_hourAng exch store
	L_minutes -6 mul						% die Minuten in den Zeigerwinkel umrechnen (1 Minute = 6°)
	L_seconds -0.1 mul add					% die Sekunden in den Zeigerwinkel umrechnen (1 Sekunde = 0,1°)
	90 add  								% ausgehend von der Y-Achse
	/L_minAng exch store
	L_seconds -6 mul						% die Sekunden in den Zeigerwinkel umrechnen (1 Sekunde = 6°)
	90 add  								% ausgehend von der Y-Achse
	/L_secAng exch store


	matrix currentmatrix
	40 40 translate
	% Ziffernblatt zeichnen
 	matrix currentmatrix
	currentcolor 
	3 setlinewidth
	32 0 moveto 
	0 0 32 0 360 arc 
	12 {
		LD_angle 90 mod 0 eq {
			25 0 moveto 31 0 lineto stroke		% 15 Minuten Skalenstrich
		} {
%			29 0 moveto 31 0 lineto stroke		% 5 Minuten Skalenstrich
		} ifelse
		30 rotate
		/LD_angle LD_angle 30 add store
	} repeat
	1 setlinewidth
	setcolor 
	setmatrix

	% a.m./p.m. zeichnen
	ixAmPm {
		matrix currentmatrix
		0 10 moveto
		MiniFont
		(a.m.) strw 2 div neg 0 rmoveto
		L_hours 12 ge { (p.m.) } { (a.m.) } ifelse
		show_utf8
		setmatrix
	} if

	% Zeiger zeichnen

	% Stundenzeiger zeichnen
	matrix currentmatrix
	currentcolor
	L_hourAng
	rotate 
	LightGrey
	%?plinebeg
	newpath 
	0 -4 moveto 
	24 0 lineto 
	0 4 lineto 
	-4 0 lineto 
	0 -4 lineto 
	eofill 
	%?plineend
	setcolor
	0 -4 moveto 
	24 0 lineto 
	0 4 lineto 
	-4 0 lineto 
	0 -4 lineto 
	setmatrix

	% Minutenzeiger zeichnen
	matrix currentmatrix
	currentcolor
	L_minAng
	rotate 
	%?plinebeg
	newpath 
	0 -2 moveto 
	30 0 lineto 
	0 2 lineto 
	-2 0 lineto 
	0 -2 lineto 
	eofill 
	%?plineend
	setcolor
	setmatrix

	% Sekundenzeiger zeichnen
	matrix currentmatrix
	ixSecDisp {
		L_secAng
		rotate 
		0 0 moveto 
		30 0 lineto 
		stroke 
	} if
	setmatrix

	setmatrix
%?manual_end
} def
%?partend

%?partdef baClock003
%?fn baClock003
%?brief	digital clock: 17:42:11; time has to be delivered
%?bbox	0 0 79 19
/baClock003 {
%?manual_beg
	/idFontSelection exch def	%?brief font				%?use INP %?type DINT %?dflt FSstdFont
	/ixSecDisp		 exch def	%?brief seconds displayed	%?use INP %?type BOOL %?dflt true
	/idValue_h		exch def	%?brief hours %?use INP %?type DINT %?dflt 0
	/idValue_m		exch def	%?brief minutes %?use INP %?type DINT %?dflt 0
	/idValue_s		exch def	%?brief seconds %?use INP %?type DINT %?dflt 0
	
	/L_hours idValue_h def
	/L_minutes idValue_m def
	/L_seconds idValue_s def

	/LS_helps 	()	def			% String definieren
	/LX_xMax 	0	def			% maximale Breite eines Anzeigewertes

	idFontSelection selectFont

	matrix currentmatrix currentcolor

	% Zahlengrösse ermitteln
	(88) strw						% Länge ermitteln
	/LX_xMax exch store				% X-Wert speichern
	% Stunden anzeigen
	LX_xMax 0 translate				% Ursprung zum ersten Trennzeichen versetzen
	L_hours LS_helps 2 0 nncvs	% Stunden in String umwandeln
	dup strw						% Länge ermitteln
	neg 0 moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	% Minuten anzeigen
	0 0 moveto
	(:) show_utf8					% erstes Trennzeichen setzen
	LX_xMax 0 rmoveto
	currentpoint translate			% Ursprung zum zweiten Trennzeichen versetzen
	L_minutes LS_helps 2 0 nncvs	% Minuten in String umwandeln
	dup strw						% Länge ermitteln
	neg 0 moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	% Sekunden anzeigen
	0 0 moveto
	ixSecDisp {
		(:) show_utf8					% zweites Trennzeichen setzen
		LX_xMax 0 rmoveto
		currentpoint translate			% Ursprung hinter die Sekundenanzeige versetzen
		L_seconds LS_helps 2 0 nncvs	% Sekunden in String umwandeln
		dup strw						% Länge ermitteln
		neg 0 moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	} if

	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baClock004
%?fn baClock004
%?brief	show digital time: hour:min:sec (e.g. countdown function)
%?bbox	0 0 79 19
/baClock004 {
%?manual_beg
	/idFontSelection exch def	%?brief font				%?use INP %?type DINT %?dflt FSstdFont
	/idOrigin		exch def	%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/ixHourDisp		exch def	%?brief hours displayed	%?use INP %?type BOOL %?dflt false
	/idTimeInSec	exch def	%?brief time in seconds		%?use INP %?type DINT %?dflt 0

	/L_hours 0 def
	/L_minutes 0 def
	/L_seconds 0 def
	/LS_helps 	()	def			% String definieren

	% Übergebene Sekunden aufschlüsseln
	/L_seconds idTimeInSec 60 mod store
	/L_minutes idTimeInSec 3600 mod 60 div cvi store
	/L_hours idTimeInSec 3600 div cvi store

	idFontSelection selectFont
	matrix currentmatrix currentcolor

	% Origin ermitteln
	ixHourDisp { /LS_helps (00:00:00) store } { /LS_helps (00:00) store } ifelse
	idOrigin 0 eq { LS_helps strw 2 div neg strh 2 div neg moveto } if
%	idOrigin 1 eq { 0 0 moveto } if															% muß nicht ausgeführt werden
	idOrigin 2 eq { 0 strh 2 div neg moveto } if
	idOrigin 3 eq { 0 strh neg moveto } if
	idOrigin 4 eq { LS_helps strw 2 div neg strh neg moveto } if
	idOrigin 5 eq { LS_helps strw neg strh neg moveto } if
	idOrigin 6 eq { LS_helps strw neg strh 2 div neg moveto } if
	idOrigin 7 eq { LS_helps strw neg 0 moveto } if
	idOrigin 8 eq { LS_helps strw 2 div neg 0 moveto } if

	% Zahlengrösse ermitteln
	ixHourDisp {
		% Stunden anzeigen
		L_hours LS_helps 2 0 nncvs	% Stunden in String umwandeln
		show_utf8
		(:) show_utf8				% Trennzeichen setzen
	} if
	% Minuten anzeigen
	L_minutes LS_helps 2 0 nncvs	% Minuten in String umwandeln
	show_utf8
	(:) show_utf8					% Trennzeichen setzen
	% Sekunden anzeigen
	L_seconds LS_helps 2 0 nncvs	% Sekunden in String umwandeln
	show_utf8

	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baClock005
%?fn baClock005
%?brief	digital clock: 17:42:11 with a.m. / p.m.
%?bbox	0 0 79 19
/baClock005 {
%?manual_beg
	/idFontSelection exch def	%?brief font				%?use INP %?type DINT %?dflt FSstdFont
	/ixShowSec		 exch def	%?brief show seconds	%?use INP %?type BOOL %?dflt true
	/ixShowAmPm		 exch def	%?brief show AM/PM by 12h format	%?use INP %?type BOOL %?dflt true
	/ix12hFormat	 exch def	%?brief 12h with AM/PM active	%?use INP %?type BOOL %?dflt true
	
	gettime
	/L_hours exch def
	/L_minutes exch def
	/L_seconds exch def

	/LS_helps 	()	def			% String definieren
	/LX_xMax 	0	def			% maximale Breite eines Anzeigewertes
	/LX_PM	false	def

	idFontSelection selectFont

	matrix currentmatrix currentcolor
	
	% AM / PM berechnungen
	ix12hFormat L_hours 12 ge and {
		/LX_PM true store
		/L_hours L_hours 12 sub store
		L_hours 0 eq { /L_hours 12 store } if
	} if
	
	L_seconds L_minutes L_hours ixShowSec idFontSelection baClock003

	ixShowAmPm ix12hFormat and {
		FSminiFont selectFont
		LX_PM { (p.m.) } { (a.m.) } ifelse
		currentpoint translate			% Ursprung hinter die Sekundenanzeige versetzen
		dup strwh						% Länge ermitteln
		neg exch neg exch moveto show_utf8			% um die Stringbreite nach links springen und den Wert anzeigen
	} if
	
	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baDate001
%?fn baDate001
%?brief	automatic digital date; 1:dd.mm.yyyy 2:yyyy.mm.dd 3:mm.dd.yyyy 11:dd-mm-yyyy 12:yyyy-mm-dd 13:mm-dd-yyyy 21:dd/mm/yyyy 22:yyyy/mm/dd 23:mm/dd/yyyy
%?bbox	0 0 99 19
/baDate001 {
%?manual_beg
	/idFontSelection exch def	%?brief font	%?use INP %?type DINT %?dflt FSstdFont
	/idFormatSelect exch def	%?brief select format (1: dd.mm.yyyy, 2: yyyy.mm.dd, 3: mm.dd.yyyy) %?use INP %?type DINT %?dflt 1

	getdate
	/L_year exch def
	/L_month exch def
	/L_day exch def

	/LS_helps 	()	def			% String definieren
	/LS_tag		(.)	def			% Trennzeichen für Datum

	idFontSelection selectFont

	matrix currentmatrix currentcolor

	idFormatSelect 10 gt idFormatSelect 20 le and { /LS_tag (-) store } if
	idFormatSelect 20 gt idFormatSelect 30 le and { /LS_tag (/) store } if

	idFormatSelect 1 eq idFormatSelect 11 eq or {
		% Tage anzeigen
		(88) strw 0 translate
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Monate anzeigen
		(88) strw 0 rmoveto
		currentpoint translate				% Ursprung zum zweiten Trennzeichen versetzen
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Jahre anzeigen
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		show_utf8
	} if
	
	idFormatSelect 2 eq idFormatSelect 12 eq or {
		% Jahre anzeigen
		(8888) strw 0 translate
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Monate anzeigen
		(88) strw 0 rmoveto
		currentpoint translate				% Ursprung zum zweiten Trennzeichen versetzen
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Tage anzeigen
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		show_utf8
	} if
	
	idFormatSelect 3 eq idFormatSelect 13 eq or {
		% Monate anzeigen
		(88) strw 0 translate
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Tage anzeigen
		(88) strw 0 rmoveto
		currentpoint translate				% Ursprung zum zweiten Trennzeichen versetzen
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Jahre anzeigen
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		show_utf8
	} if

	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baDate002
%?fn baDate002
%?brief	digital date (has to be delivered); 1:dd.mm.yyyy 2:yyyy.mm.dd 3:mm.dd.yyyy 11:dd-mm-yyyy 12:yyyy-mm-dd 13:mm-dd-yyyy 21:dd/mm/yyyy 22:yyyy/mm/dd 23:mm/dd/yyyy
%?bbox	0 0 99 19
/baDate002 {
%?manual_beg
	/idFontSelection exch def	%?brief font	%?use INP %?type DINT %?dflt FSstdFont
	/idFormatSelect exch def	%?brief select format (1: dd.mm.yyyy, 2: yyyy.mm.dd, 3: mm.dd.yyyy) %?use INP %?type DINT %?dflt 1
	/idValue_y exch def	%?brief year %?use INP %?type DINT %?dflt 0
	/idValue_m exch def	%?brief month %?use INP %?type DINT %?dflt 0
	/idValue_d exch def	%?brief day %?use INP %?type DINT %?dflt 0

	/L_year idValue_y def
	/L_month idValue_m def
	/L_day idValue_d def

	/LS_helps 	()	def			% String definieren
	/LS_tag		(.)	def			% Trennzeichen für Datum

	idFontSelection selectFont

	matrix currentmatrix currentcolor

	idFormatSelect 10 gt idFormatSelect 20 le and { /LS_tag (-) store } if
	idFormatSelect 20 gt idFormatSelect 30 le and { /LS_tag (/) store } if

	idFormatSelect 1 eq idFormatSelect 11 eq or {
		% Tage anzeigen
		(88) strw 0 translate
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Monate anzeigen
		(88) strw 0 rmoveto
		currentpoint translate				% Ursprung zum zweiten Trennzeichen versetzen
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Jahre anzeigen
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		show_utf8
	} if
	
	idFormatSelect 2 eq idFormatSelect 12 eq or {
		% Jahre anzeigen
		(8888) strw 0 translate
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Monate anzeigen
		(88) strw 0 rmoveto
		currentpoint translate				% Ursprung zum zweiten Trennzeichen versetzen
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Tage anzeigen
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		show_utf8
	} if
	
	idFormatSelect 3 eq idFormatSelect 13 eq or {
		% Monate anzeigen
		(88) strw 0 translate
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Tage anzeigen
		(88) strw 0 rmoveto
		currentpoint translate				% Ursprung zum zweiten Trennzeichen versetzen
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		dup strw							% Länge ermitteln
		neg 0 moveto show_utf8				% um die Stringbreite nach links springen und den Wert anzeigen
		0 0 moveto
		LS_tag show_utf8					% Trennzeichen setzen
		% Jahre anzeigen
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		show_utf8
	} if

	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baDate003
%?fn baDate003
%?brief	automatic digital date; separator selectable 1:yyyy-mm-dd , 2:dd.mm.yyyy, 3:mmm dd,yyyy
%?bbox	0 0 99 19
/baDate003 {
%?manual_beg
	/idFontSelection exch def	%?brief font	%?use INP %?type DINT %?dflt FSstdFont
	/idFormatSelect exch def	%?brief select format (1:yyyy-mm-dd , 2:dd.mm.yyyy, 3:mmm dd,yyyy) %?use INP %?type DINT %?dflt 1

	getdate
	/L_year exch def
	/L_month exch def
	/L_day exch def

	/LS_helps 	()	def			% String definieren
	/LS_month (Jan) def

	L_month 1 eq { /LS_month (Jan) store } if
	L_month 2 eq { /LS_month (Feb) store } if
	L_month 3 eq { /LS_month (Mar) store } if
	L_month 4 eq { /LS_month (Apr) store } if
	L_month 5 eq { /LS_month (May) store } if
	L_month 6 eq { /LS_month (Jun) store } if
	L_month 7 eq { /LS_month (Jul) store } if
	L_month 8 eq { /LS_month (Aug) store } if
	L_month 9 eq { /LS_month (Sep) store } if
	L_month 10 eq { /LS_month (Oct) store } if
	L_month 11 eq { /LS_month (Nov) store } if
	L_month 12 eq { /LS_month (Dec) store } if

	idFontSelection selectFont

	matrix currentmatrix currentcolor

	idFormatSelect 1 le {
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		(-) strcat
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		strcat		
		(-) strcat
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		strcat
		dup strwh 2 div neg exch 2 div neg exch moveto
		show_utf8
	} if
	
	idFormatSelect 2 eq {
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		(.) strcat
		L_month LS_helps 2 0 nncvs		% Monate in String umwandeln
		strcat		
		(.) strcat
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		strcat		
		dup strwh 2 div neg exch 2 div neg exch moveto
		show_utf8
	} if

	idFormatSelect 3 eq {
		LS_month
		( ) strcat
		L_day LS_helps 2 0 nncvs		% Tage in String umwandeln
		strcat		
		(, ) strcat
		L_year LS_helps 4 0 nncvs		% Jahre in String umwandeln
		strcat		
		dup strwh 2 div neg exch 2 div neg exch moveto
		0.9 0.9 scale
		show_utf8
	} if

	setcolor setmatrix
%?manual_end
} def
%?partend

%?partdef baShowSymbol001
%?fn	baShowSymbol001
%?brief	show any symbol by call the name
%?bbox	0 0 79 79
/baShowSymbol001 {
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/irDummy exch def	%?brief dummy input %?use INP %?type REAL %?dflt 0.00
%?manual_beg
	currentcolor
	isSymbolName cvx exec
	setcolor 
%?manual_end
} def
%?partend

%?partdef baShowSymbol002
%?fn	baShowSymbol002
%?brief	show 15 symbols by Number
%?bbox	0 0 79 79
/baShowSymbol002 {
	/irDummy exch def	%?brief dummy input %?use INP %?type REAL %?dflt 0.00
	/isSymbolName15 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName14 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName13 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName12 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName11 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName10 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName9 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName8 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName7 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName6 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName5 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName4 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName3 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName2 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/isSymbolName1 exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/irNumber	exch	def		%?brief Nummer des anzuzeigenden Symboles (Auswahl)	%?use INP	%?type REAL	%?dflt 0.00
%?manual_beg
	currentcolor
	irNumber 1 eq { isSymbolName1 cvx exec } if
	irNumber 2 eq { isSymbolName2 cvx exec } if
	irNumber 3 eq { isSymbolName3 cvx exec } if
	irNumber 4 eq { isSymbolName4 cvx exec } if
	irNumber 5 eq { isSymbolName5 cvx exec } if
	irNumber 6 eq { isSymbolName6 cvx exec } if
	irNumber 7 eq { isSymbolName7 cvx exec } if
	irNumber 8 eq { isSymbolName8 cvx exec } if
	irNumber 9 eq { isSymbolName9 cvx exec } if
	irNumber 10 eq { isSymbolName10 cvx exec } if
	irNumber 11 eq { isSymbolName11 cvx exec } if
	irNumber 12 eq { isSymbolName12 cvx exec } if
	irNumber 13 eq { isSymbolName13 cvx exec } if
	irNumber 14 eq { isSymbolName14 cvx exec } if
	irNumber 15 eq { isSymbolName15 cvx exec } if
	setcolor 
%?manual_end
} def
%?partend

%?partdef baSwitchSymbolColor001
%?fn	baSwitchSymbolColor001
%?brief	switch the color of any symbol by digital inputs
%?bbox	0 0 79 79
/baSwitchSymbolColor001 {
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/ixGreen exch def	%?brief activate green color %?use INP %?type BOOL %?dflt false
	/ixBlue exch def	%?brief activate blue color %?use INP %?type BOOL %?dflt false
	/ixYellow exch def	%?brief activate yellow color %?use INP %?type BOOL %?dflt false
	/ixRed exch def	%?brief activate red color %?use INP %?type BOOL %?dflt false
%?manual_beg
	currentcolor
	ixGreen { Green } if
	ixBlue { Blue } if
	ixYellow { Yellow } if
	ixRed { Red } if
	isSymbolName cvx exec
	setcolor 
%?manual_end
} def
%?partend

%?partdef baSwitchSymbolColor002
%?fn	baSwitchSymbolColor002
%?brief	switch the color of any symbol by one input
%?bbox	0 0 79 79
/baSwitchSymbolColor002 {
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/idColor exch def	%?brief activate any color %?use INP %?type DINT %?dflt 0
%?manual_beg
	currentcolor
	idColor sp_set_color
	isSymbolName cvx exec
	setcolor 
%?manual_end
} def
%?partend

%?partdef baSwitchSymbolColor003
%?fn	baSwitchSymbolColor003
%?brief	switch the background color of any symbol by digital inputs (symbol turns to black)
%?bbox	0 0 79 79
/baSwitchSymbolColor003 {
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/ixGreen exch def	%?brief activate green color %?use INP %?type BOOL %?dflt false
	/ixBlue exch def	%?brief activate blue color %?use INP %?type BOOL %?dflt false
	/ixYellow exch def	%?brief activate yellow color %?use INP %?type BOOL %?dflt false
	/ixRed exch def	%?brief activate red color %?use INP %?type BOOL %?dflt false
%?manual_beg
	currentcolor
	ixGreen ixBlue or ixYellow or ixRed or {
		ixGreen { Green } if
		ixBlue { Blue } if
		ixYellow { Yellow } if
		ixRed { Red } if
		newpath 
		6 1 moveto 
		73 6 5 270 360 arc 
		73 73 5 0 90 arc 
		6 73 5 90 180 arc 
		6 6 5 180 270 arc 
		eofill 
		Invisible
	} if
	isSymbolName cvx exec
	setcolor 
%?manual_end
} def
%?partend

%?partdef baSwitchSymbolColor004
%?fn	baSwitchSymbolColor004
%?brief	switch the color of any symbol by digital inputs, red is flashing automatically
%?bbox	0 0 79 79
/baSwitchSymbolColor004 {
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/ixGreen exch def	%?brief activate green color %?use INP %?type BOOL %?dflt false
	/ixBlue exch def	%?brief activate blue color %?use INP %?type BOOL %?dflt false
	/ixYellow exch def	%?brief activate yellow color %?use INP %?type BOOL %?dflt false
	/ixRed exch def	%?brief activate red color %?use INP %?type BOOL %?dflt false
%?manual_beg
	% Das weiße Symbol ist immer sichtbar. Ein Part bei dem das Symbol nur eingeblendet wird, wenn es auch eine Farbe erhält
	% (also nur wenn ein Fehler anliegt ist NICHT sinnvoll. Dieses Part ist dann im Lisual nie sichtbar. Eine Bearbeitung des
	% übergeordneten Parts oder des Projektes wird dadurch sehr erschwert bzw. fehleranfällig
	currentcolor
	ixGreen { Green } if
	ixBlue { Blue } if
	ixYellow { Yellow } if
	ixRed { Red true setflash } if
	isSymbolName cvx exec
	false setflash
	setcolor 
%?manual_end
} def
%?partend

%?partdef baSwitchSymbolColor005
%?fn	baSwitchSymbolColor005
%?brief	scalable part to switch the background color of any symbol by digital inputs (symbol turns to black)
%?bbox	0 0 239 159
/baSwitchSymbolColor005 {
	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/ixGreen exch def	%?brief activate green color %?use INP %?type BOOL %?dflt false
	/ixBlue exch def	%?brief activate blue color %?use INP %?type BOOL %?dflt false
	/ixYellow exch def	%?brief activate yellow color %?use INP %?type BOOL %?dflt false
	/ixRed exch def	%?brief activate red color %?use INP %?type BOOL %?dflt false
%?manual_beg
	currentcolor

	/LD_X2 MDsymbolGrid irScaleX mul 1 sub def
	/LD_Y2 MDsymbolGrid irScaleY mul 1 sub def
	/LD_X2Arc LD_X2 6 sub def
	/LD_Y2Arc LD_Y2 6 sub def

	ixGreen ixBlue or ixYellow or ixRed or {
		ixGreen { Green } if
		ixBlue { Blue } if
		ixYellow { Yellow } if
		ixRed { Red } if
		newpath 
		6 1 moveto 
		LD_X2Arc 6 5 270 360 arc 
		LD_X2Arc LD_Y2Arc 5 0 90 arc 
		6 LD_Y2Arc 5 90 180 arc 
		6 6 5 180 270 arc 
		eofill 
		Invisible
	} if
	LD_X2 MDsymbolGrid sub 2 div LD_Y2 MDsymbolGrid sub 2 div translate
	isSymbolName cvx exec
	setcolor 
%?manual_end
} def
%?partend

%?partdef baSwitchSymbolColor006
%?fn	baSwitchSymbolColor006
%?brief	switch the color of any symbol by specific integer number of the inputs
%?bbox	0 0 79 79
/baSwitchSymbolColor006 {
	/isSymbolName exch def	%?brief name of the symbol-part which has to be displayed %?use INP %?type STRI %?dflt (gsGeneral001)
	/idAcivationNumber exch def	%?brief activate symbol color by match of this number %?use INP %?type DINT %?dflt 0
	/idInvisible exch def	%?brief activate invisible (black color) %?use INP %?type DINT %?dflt 0
	/idWhite exch def	%?brief activate white color %?use INP %?type DINT %?dflt 0
	/idLightGrey exch def	%?brief activate light grey color %?use INP %?type DINT %?dflt 0
	/idGrey exch def	%?brief activate grey color %?use INP %?type DINT %?dflt 0
	/idLightBlue exch def	%?brief activate light blue color %?use INP %?type DINT %?dflt 0
	/idDarkGreen exch def	%?brief activate dark green color %?use INP %?type DINT %?dflt 0
	/idBrown exch def	%?brief activate brown color %?use INP %?type DINT %?dflt 0
	/idOrange exch def	%?brief activate orange color %?use INP %?type DINT %?dflt 0
	/idGreen exch def	%?brief activate green color %?use INP %?type DINT %?dflt 0
	/idBlue exch def	%?brief activate blue color %?use INP %?type DINT %?dflt 0
	/idYellow exch def	%?brief activate yellow color %?use INP %?type DINT %?dflt 0
	/idRed exch def	%?brief activate red color %?use INP %?type DINT %?dflt 0
%?manual_beg
	currentcolor
	idAcivationNumber idInvisible eq { Invisible } if
	idAcivationNumber idWhite eq { White } if
	idAcivationNumber idLightGrey eq { LightGrey } if
	idAcivationNumber idGrey eq { Grey } if
	idAcivationNumber idLightBlue eq { LightBlue } if
	idAcivationNumber idDarkGreen eq { DarkGreen } if
	idAcivationNumber idBrown eq { Brown } if
	idAcivationNumber idOrange eq { Orange } if
	idAcivationNumber idGreen eq { Green } if
	idAcivationNumber idBlue eq { Blue } if
	idAcivationNumber idYellow eq { Yellow } if
	idAcivationNumber idRed eq { Red } if
	isSymbolName cvx exec
	setcolor 
%?manual_end
} def
%?partend

%?partdef baBar001
%?fn baBar001
%?brief	normal bar with scale
%?bbox	0 0 79 159
/baBar001 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold (not underrun)	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/ixFineScale		exch	def		%?brief draw fine scale (1/10)							%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/irErrorValue		exch	def		%?brief threshold value for change to error color		%?use INP	%?type REAL	%?dflt 10.0
	/irWarnValue		exch	def		%?brief threshold value for change to warn color		%?use INP	%?type REAL	%?dflt 20.0
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue			exch	def		%?brief actual value									%?use INP	%?type REAL	%?dflt 0.0

	matrix currentmatrix
	10 10 translate

	ValueFont
	currentcolor
	ixWarnErrActive {
		irValue irWarnValue ge ixWarnHigher and
		irValue irWarnValue le ixWarnHigher not and
		or {
			Yellow
		} if
		irValue irErrorValue ge ixWarnHigher and
		irValue irErrorValue le ixWarnHigher not and
		or {
			Red
		} if
	} if

    0 0 idBarWide
	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	rectfill	
	stroke
	setcolor
	ixScaleActive {
		matrix currentmatrix
		idBarWide 5 add 0 translate				% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		idBarLength irMinValue irMaxValue idNumbScale ixFineScale idScaleAngle idDeciNumber false sp_drawScale001
		% Einheit Beschriftung
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0						% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
		setmatrix
	} if
	setmatrix
%?manual_end
} def
%?partend


%?partdef baBar002
%?fn baBar002
%?brief	two bars with one scale in the middle
%?bbox	0 0 159 159
/baBar002 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold (not underrun)	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/ixFineScale		exch	def		%?brief draw fine scale (1/10)							%?use INP	%?type BOOL	%?dflt false
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/irErrorValue		exch	def		%?brief threshold value for change to error color		%?use INP	%?type REAL	%?dflt 10.0
	/irWarnValue		exch	def		%?brief threshold value for change to warn color		%?use INP	%?type REAL	%?dflt 20.0
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue2			exch	def		%?brief actual value second bar							%?use INP	%?type REAL	%?dflt 0.0
	/irValue1			exch	def		%?brief actual value first bar							%?use INP	%?type REAL	%?dflt 0.0

	matrix
	currentmatrix
	80 10 translate

	ValueFont
	currentcolor
	ixWarnErrActive {
		irValue1 irWarnValue ge ixWarnHigher and
		irValue1 irWarnValue le ixWarnHigher not and
		or {
			Yellow
		} if
		irValue1 irErrorValue ge ixWarnHigher and
		irValue1 irErrorValue le ixWarnHigher not and
		or {
			Red
		} if
	} if

    -45 idBarWide sub 0 idBarWide
	idBarLength irMinValue irMaxValue irValue1 sp_scaleProc
	rectfill	
	stroke
    45 0 idBarWide
	idBarLength irMinValue irMaxValue irValue2 sp_scaleProc
	rectfill
	stroke
	setcolor
	ixScaleActive {
		idBarLength irMinValue irMaxValue idNumbScale ixFineScale idDeciNumber sp_draw2Scale001
		isUnit dup strw			% Länge der Beschriftung errechnen, X-Wert im stack lassen
		2 div neg idBarLength 8 add moveto		% zum Beschriftungspunkt springen (um Stringlänge halbe nach links)
		show_utf8
	} if
	% Einheit Beschriftung
	setmatrix
%?manual_end
} def
%?partend


%?partdef baBar003
%?fn baBar003
%?brief	bar with positive and negative direction
%?bbox	0 0 79 319
/baBar003 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold (not underrun)	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/ixFineScale		exch	def		%?brief draw fine scale (1/10)							%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/irErrorValue		exch	def		%?brief threshold value for change to error color		%?use INP	%?type REAL	%?dflt 10.0
	/irWarnValue		exch	def		%?brief threshold value for change to warn color		%?use INP	%?type REAL	%?dflt 20.0
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValueNeg			exch	def		%?brief actual value in negative direction				%?use INP	%?type REAL	%?dflt 0.0
	/irValue			exch	def		%?brief actual value in positive direction				%?use INP	%?type REAL	%?dflt 0.0

	matrix currentmatrix
	10 150 translate

	ValueFont
	currentcolor
	ixWarnErrActive {
		irValue irWarnValue ge ixWarnHigher and
		irValue irWarnValue le ixWarnHigher not and
		or {
			Yellow
		} if
		irValue irErrorValue ge ixWarnHigher and
		irValue irErrorValue le ixWarnHigher not and
		or {
			Red
		} if
	} if

    0 0 idBarWide
	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	rectfill	
	stroke
	setcolor
	ixScaleActive {
		matrix currentmatrix
		idBarWide 5 add 0 translate				% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		idBarLength irMinValue irMaxValue idNumbScale ixFineScale idScaleAngle idDeciNumber false sp_drawScale001
		% Einheit Beschriftung
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0					% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
		setmatrix
	} if

	% Negativer Balken
	currentcolor
	irValueNeg abs irWarnValue ge ixWarnHigher and
	irValueNeg abs irWarnValue le ixWarnHigher not and
	or {
		Yellow
	} if
	irValueNeg abs irErrorValue ge ixWarnHigher and
	irValueNeg abs irErrorValue le ixWarnHigher not and
	or {
		Red
	} if

    0 0 idBarWide
	idBarLength irMinValue irMaxValue irValueNeg abs sp_scaleProc
	neg rectfill	
	stroke
	setcolor
	ixScaleActive {
		matrix currentmatrix
		idBarWide 5 add 0 translate				% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		idBarLength irMinValue irMaxValue idNumbScale ixFineScale idScaleAngle idDeciNumber false sp_drawScaleNeg001
		setmatrix
	} if
	setmatrix
%?manual_end
} def
%?partend


%?partdef baBar004
%?fn	baBar004
%?brief	single or double bar with scale
%?bbox	0 0 79 159
/baBar004 {
	
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idFrameLinewidth	exch	def		%?brief linewidth of the frame							%?use INP	%?type DINT %?dflt 1
	/ixFrame			exch	def		%?brief draw frame										%?use INP	%?type BOOL	%?dflt false
	/idFontSelection	exch	def		%?brief font											%?use INP	%?type DINT %?dflt FSstdFont
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT	%?dflt 0
	/ixScaleLeft		exch	def		%?brief scale at the left side of the bar				%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/ixFineScale		exch	def		%?brief draw fine scale (1/10)							%?use INP	%?type BOOL	%?dflt false
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/irErrorValue		exch	def		%?brief threshold value for change to error color (1&2)	%?use INP	%?type REAL	%?dflt 10.0
	/irWarnValue		exch	def		%?brief threshold value for change to warn color (1&2)	%?use INP	%?type REAL	%?dflt 20.0
	/ixErrBar2Act		exch	def		%?brief bar 2 activate error color red					%?use INP	%?type BOOL	%?dflt false
	/ixWarnBar2Act		exch	def		%?brief bar 2 activate warn color yellow				%?use INP	%?type BOOL	%?dflt false
	/ixErrBar1Act		exch	def		%?brief bar 1 activate error color red					%?use INP	%?type BOOL	%?dflt false
	/ixWarnBar1Act		exch	def		%?brief bar 1 activate warn color yellow				%?use INP	%?type BOOL	%?dflt false
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/ixNormGreen		exch	def		%?brief color of the normal area green activated		%?use INP	%?type BOOL	%?dflt false
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue2			exch	def		%?brief actual value second bar							%?use INP	%?type REAL	%?dflt 0.0
	/irValue1			exch	def		%?brief actual value first bar							%?use INP	%?type REAL	%?dflt 0.0
	/ixDoubleBar		exch	def		%?brief activate double bar								%?use INP	%?type BOOL	%?dflt true
	
	/LR_smallBarWide 	0	def			% Balkenbreite bei Doppelbalken

	matrix currentmatrix_nlw
	ixScaleLeft {
		70 10 translate
	} {
		10 10 translate
	} ifelse

	% select optimized font for given font size
	idFontSelection selectFont

	currentcolor
	ixNormGreen { Green } if

	% Berechnung der Balkenbreite bei Doppelbalkenfunktion
	idBarWide 2 sub 2 div
	/LR_smallBarWide exch cvi store
	
	ixDoubleBar {
		currentcolor
		ixWarnErrActive {
			irValue2 irWarnValue ge ixWarnHigher and
			irValue2 irWarnValue le ixWarnHigher not and
			ixWarnBar2Act
			or or {
				Yellow
			} if
			irValue2 irErrorValue ge ixWarnHigher and
			irValue2 irErrorValue le ixWarnHigher not and
			ixErrBar2Act
			or or {
				Red
			} if
		} if
		0 0 LR_smallBarWide
		ixScaleLeft { neg } if
		idBarLength irMinValue irMaxValue irValue2 sp_scaleProc
		rectfill
		stroke
		setcolor
		currentcolor
		ixWarnErrActive {
			irValue1 irWarnValue ge ixWarnHigher and
			irValue1 irWarnValue le ixWarnHigher not and
			ixWarnBar1Act
			or or {
				Yellow
			} if
			irValue1 irErrorValue ge ixWarnHigher and
			irValue1 irErrorValue le ixWarnHigher not and
			ixErrBar1Act
			or 	or {
				Red
			} if
		} if
		ixScaleLeft {
			LR_smallBarWide 2 add neg 0 LR_smallBarWide neg
		} {
			LR_smallBarWide 2 add 0 LR_smallBarWide
		} ifelse
		idBarLength irMinValue irMaxValue irValue1 sp_scaleProc
		rectfill
		stroke
		setcolor
	} {
		currentcolor
		ixWarnErrActive {
			irValue1 irWarnValue ge ixWarnHigher and
			irValue1 irWarnValue le ixWarnHigher not and
			ixWarnBar1Act
			or or {
				Yellow
			} if
			irValue1 irErrorValue ge ixWarnHigher and
			irValue1 irErrorValue le ixWarnHigher not and
			ixErrBar1Act
			or or {
				Red
			} if
		} if
		0 0 idBarWide
		ixScaleLeft { neg } if
		idBarLength irMinValue irMaxValue irValue1 sp_scaleProc
		rectfill
		stroke
		setcolor
	} ifelse

	setcolor

	% Rahmen zeichnen
	ixFrame {
		idFrameLinewidth setlinewidth
		0 0 idBarWide
		ixScaleLeft { neg } if
		idBarLength rectstroke
		1 setlinewidth
	} if

	ixScaleActive {
		matrix currentmatrix_nlw
		idBarWide 5 add					% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		ixScaleLeft { neg } if
		0 translate
		idBarLength irMinValue irMaxValue idNumbScale ixFineScale idScaleAngle idDeciNumber ixScaleLeft sp_drawScale001
		% Einheit Beschriftung
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0						% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
		setmatrix_nlw
	} if
	setmatrix_nlw
%?manual_end
	
} def
%?partend

%?partdef baBar005
%?fn baBar005
%?brief	configurable bar, without scale, frame selectable
%?bbox	0 0 39 159
/baBar005 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idDesign			exch 	def		%?brief design: 0=closed bar, 1=horizontal lines, 2=vertical lines, 3=pointer at actual value	%?use INP %?type DINT %?dflt 0
	/ixFrame			exch	def		%?brief draw frame							%?use INP	%?type BOOL	%?dflt false
	/ixErrorActive		exch	def		%?brief activate error color red			%?use INP	%?type BOOL	%?dflt false
	/ixWarnActive		exch	def		%?brief activate warn color yellow			%?use INP	%?type BOOL	%?dflt false
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold (not at underrun)	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated		%?use INP	%?type BOOL	%?dflt false
	/idBarLength		exch	def		%?brief length of the bar [pixel]			%?use INP	%?type DINT	%?dflt 160
	/idBarWide			exch	def		%?brief width of the bar [pixel]			%?use INP	%?type DINT	%?dflt 40
	/irErrorValue		exch	def		%?brief threshold value for change to error color	%?use INP	%?type REAL	%?dflt 100.0
	/irWarnValue		exch	def		%?brief threshold value for change to warn color	%?use INP	%?type REAL	%?dflt 90.0
	/irMaxValue			exch	def		%?brief value at maximum					%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum					%?use INP	%?type REAL	%?dflt 0.0
	/irValue			exch	def		%?brief actual value				%?use INP	%?type REAL	%?dflt 0.0

	/L_actX 0 def
	/L_actY 0 def
	/L_maxY 0 def

	matrix currentmatrix

	currentcolor
	ixWarnErrActive {
		irValue irWarnValue ge ixWarnHigher and
		irValue irWarnValue le ixWarnHigher not and
		ixWarnActive
		or or {
			Yellow
		} if
		irValue irErrorValue ge ixWarnHigher and
		irValue irErrorValue le ixWarnHigher not and
		ixErrorActive
		or or {
			Red
		} if
	} if

	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	/L_maxY exch store

	idDesign 0 le { 0 0 idBarWide L_maxY rectfill } if
	idDesign 1 eq {
		{
			L_actY L_maxY ge { exit } if
			0 L_actY moveto
			idBarWide L_actY lineto
			/L_actY L_actY 2 add store
		} loop
	} if
	idDesign 2 eq {
		{
			L_actX idBarWide ge { exit } if
			L_actX 0 moveto L_actX L_maxY lineto
			/L_actX L_actX 2 add store
		} loop
	} if
	idDesign 3 eq {
		currentcolor
		Grey
		newpath
		idBarWide L_maxY 2 add moveto			% Schattierung des Zeiger zeichnen
		0 L_maxY lineto
		idBarWide L_maxY 2 sub lineto
		idBarWide L_maxY 2 add lineto
		eofill
		setcolor
		idBarWide L_maxY 2 add moveto			% Schattierung des Zeiger zeichnen
		0 L_maxY lineto
		idBarWide L_maxY 2 sub lineto
		stroke
	} if
	idDesign 4 eq {
		currentcolor
		Grey
		newpath
		0 L_maxY 2 add moveto			% Schattierung des Zeiger zeichnen
		idBarWide L_maxY lineto
		0 L_maxY 2 sub lineto
		0 L_maxY 2 add lineto
		eofill
		setcolor
		0 L_maxY 2 add moveto			% Schattierung des Zeiger zeichnen
		idBarWide L_maxY lineto
		0 L_maxY 2 sub lineto
		stroke
	} if

	setcolor
	% Rahmen zeichnen
	ixFrame {
		0 0 idBarWide idBarLength rectstroke
	} if
	setmatrix
%?manual_end
} def
%?partend


%?partdef baBar006
%?fn	baBar006
%?brief	configurable bar, frame selectable, normal color green selectable
%?bbox	0 0 79 159
/baBar006 {
	
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idFrameLinewidth	exch	def		%?brief linewidth of the frame							%?use INP	%?type DINT %?dflt 1
	/ixFrame			exch	def		%?brief draw frame										%?use INP	%?type BOOL	%?dflt false
	/idFontSelection	exch	def		%?brief font											%?use INP	%?type DINT %?dflt FSstdFont
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/ixScaleLeft		exch	def		%?brief scale at the left side of the bar				%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/ixFineScale		exch	def		%?brief draw fine scale (1/10)							%?use INP	%?type BOOL	%?dflt false
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/irErrorValueLow	exch	def		%?brief threshold value for change to error color at underrun	%?use INP	%?type REAL	%?dflt 10.0
	/irWarnValueLow		exch	def		%?brief threshold value for change to warn color at underrun	%?use INP	%?type REAL	%?dflt 20.0
	/irErrorValueHigh	exch	def		%?brief threshold value for change to error color at overrun	%?use INP	%?type REAL	%?dflt 100.0
	/irWarnValueHigh	exch	def		%?brief threshold value for change to warn color at overrun		%?use INP	%?type REAL	%?dflt 90.0
	/ixErrorActive		exch	def		%?brief activate error color red						%?use INP	%?type BOOL	%?dflt false
	/ixWarnActive		exch	def		%?brief activate warn color yellow						%?use INP	%?type BOOL	%?dflt false
	/ixWarnLower		exch	def		%?brief warning or error at underrun of the threshold	%?use INP	%?type BOOL	%?dflt false
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/ixNormGreen		exch	def		%?brief color of the normal area green activated		%?use INP	%?type BOOL	%?dflt false
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue			exch	def		%?brief actual value									%?use INP	%?type REAL	%?dflt 0.0

	matrix currentmatrix_nlw
	ixScaleLeft {
		70 10 translate
	} {
		10 10 translate
	} ifelse

	% select optimized font for given font size
	idFontSelection selectFont

	currentcolor
	ixNormGreen { Green } if
	ixWarnErrActive {
		irValue irWarnValueHigh ge ixWarnHigher and
		irValue irWarnValueLow le ixWarnLower and
		ixWarnActive
		or or {
			Yellow
		} if
		irValue irErrorValueHigh ge ixWarnHigher and
		irValue irErrorValueLow le ixWarnLower and
		ixErrorActive
		or or {
			Red
		} if
	} if

	0 0 idBarWide
	ixScaleLeft { neg } if
	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	rectfill	
	stroke
	setcolor
	% Rahmen zeichnen
	ixFrame {
		idFrameLinewidth setlinewidth
		0 0 idBarWide
		ixScaleLeft { neg } if
		idBarLength rectstroke
		1 setlinewidth
	} if
	% Skalierung zeichnen
	ixScaleActive {
		matrix currentmatrix_nlw
		idBarWide 5 add					% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		ixScaleLeft { neg } if
		0 translate
		idBarLength irMinValue irMaxValue idNumbScale ixFineScale idScaleAngle idDeciNumber ixScaleLeft sp_drawScale001
		% Einheit Beschriftung
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0						% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
		setmatrix_nlw
	} if	
	setmatrix_nlw
%?manual_end
	
} def
%?partend

%?partdef baBar007
%?fn baBar007
%?brief	bar with configurable single sections, without scale, frames selectable
%?bbox	0 0 39 159
/baBar007 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idDesign			exch 	def		%?brief design: 0=filled rectangle sections, 1=filled rounded sections, 2=1 with colored frames	%?use INP %?type DINT %?dflt 1
	/ixFrame			exch	def		%?brief draw frame					%?use INP	%?type BOOL	%?dflt false
	/ixErrorActive		exch	def		%?brief activate error color red	%?use INP	%?type BOOL	%?dflt false
	/ixWarnActive		exch	def		%?brief activate warn color yellow	%?use INP	%?type BOOL	%?dflt false
	/idNumbSect			exch 	def		%?brief number of maximum shown sektions	%?use INP	%?type DINT %?dflt 6
	/idBarLength		exch	def		%?brief length of the bar [pixel]	%?use INP	%?type DINT	%?dflt 160
	/idBarWide			exch	def		%?brief width of the bar [pixel]	%?use INP	%?type DINT	%?dflt 40
	/irMaxValue			exch	def		%?brief value at maximum			%?use INP	%?type REAL	%?dflt 6.0
	/irMinValue			exch	def		%?brief value at minimum			%?use INP	%?type REAL	%?dflt 0.0
	/irValue			exch	def		%?brief actual value				%?use INP	%?type REAL	%?dflt 0.0

	/L_maxY 0 def
	/L_actY 0 def
	/L_helpX 5 def		% Hilfsvariable fürs curveto
	/L_helpY 0 def		% Hilfsvariable fürs curveto 
	/L_sectY 15 def		% Stärke einer Sektion bzw. Abstand zwischen den Sektionen
	
% Beschreibung: Die Anzeige besteht aus mehreren Sektionen. Wenn der Rahmen vorgewählt wird,
% so wird bei jenen Sektionen, die durch den anzuzeigenden Wert noch nicht dargestellt werden,
% der Rahmen dieser gezeichnet.
% Die Anzahl der Sektionen kann am Eingang übergeben werden. Die Stärke bzw. der Abstand der
% Sektionen ergibt sich dann durch die Anzahl der Sektionen und die übergebene Gesamtbalkenlänge.

	matrix currentmatrix
	currentcolor
	ixWarnActive { Yellow } if
	ixErrorActive { Red } if

	% Gesamtanzahl der Sektionen und somit den wahren Sektionsabstand und Stärke berechnen (Damit die letzte Sektion auch wirklich )
	idBarLength idNumbSect 2 mul 1 sub div
	/L_sectY exch store

	% aktuellen Balkenwert in pixel berechnen
	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	/L_maxY exch store

	% Balken zeichnen
	{
		L_actY idBarLength ge { exit } if					% Schleife bis ans Balkenende weiterlaufen, damit auch die nicht gefüllten gezeichnet werden (Rahmen)
		ixFrame not L_actY L_maxY ge and { exit } if		% Schleife beim aktuellen Balkenwert abbrechen, damit die nicht gefüllten nicht gezeichnet werden (kein Rahmen)
		/L_helpY L_actY L_sectY add store					% Hilfsvariabel für Strichposition
		idDesign 0 eq {
			0 L_actY idBarWide L_sectY
			L_actY L_maxY lt { rectfill } { rectstroke } ifelse		% Rechteck ausfüllen oder zeichnen
		} if
		idDesign 1 eq {
			newpath 
			L_helpX L_actY moveto
			0 L_actY 0 L_helpY L_helpX L_helpY curveto
			idBarWide L_helpX sub L_helpY lineto
			idBarWide L_helpY idBarWide L_actY idBarWide L_helpX sub L_actY curveto
			L_helpX L_actY lineto
			L_actY L_maxY lt { eofill } { stroke } ifelse		% Pfad ausfüllen oder zeichnen
		} if
		idDesign 2 eq {
			newpath 
			L_helpX L_actY moveto
			currentcolor
			L_actY 0 eq { Blue } if										% unterstes Balkenelement Blau zeichnen
			L_actY L_sectY idNumbSect 2 mul 2 sub mul eq { Red } if		% oberstes Balkenelement Rot zeichnen
			0 L_actY 0 L_helpY L_helpX L_helpY curveto
			idBarWide L_helpX sub L_helpY lineto
			idBarWide L_helpY idBarWide L_actY idBarWide L_helpX sub L_actY curveto
			L_helpX L_actY lineto
			L_actY L_maxY lt { eofill } { stroke } ifelse		% Pfad ausfüllen oder zeichnen
			setcolor
		} if
		/L_actY L_actY L_sectY 2 mul add store
	} loop
	setcolor
	setmatrix
%?manual_end
} def
%?partend

%?partdef baBar008
%?fn baBar008
%?brief	pointer with scale
%?bbox	0 0 79 159
/baBar008 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/ixScaleLeft		exch	def		%?brief scale at the left side of the bar				%?use INP	%?type BOOL	%?dflt false
	/ixFineScale		exch	def		%?brief draw fine scale (1/10)							%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/idFontSelUnit		exch	def		%?brief font for digital value and unit					%?use INP %?type DINT %?dflt FSminiFont
	/idFontSelScale		exch	def		%?brief font for scale numbers							%?use INP %?type DINT %?dflt FSminiFont
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/idDesign			exch	def		%?brief design of the scale (linewidth ...)				%?use INP	%?type DINT	%?dflt 13
	/idColorHigh		exch	def		%?brief color for the high value scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 4
	/idColorLow			exch	def		%?brief color for the low value scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 2
	/idColor			exch	def		%?brief color for the middle scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 1
	/irHigherWarn		exch	def		%?brief value for the beginning of the high value colored scale line	%?use INP	%?type REAL	%?dflt 90.0
	/irLowerWarn		exch	def		%?brief value for the end of the low value colored scale line	%?use INP	%?type REAL	%?dflt 10.0
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue			exch	def		%?brief actual value									%?use INP	%?type REAL	%?dflt 0.0

	/LW_poiSize 2 def
	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	/L_maxY exch def

	matrix currentmatrix_nlw
	currentcolor

	ixScaleLeft {
		70 10 translate
	} {
		10 10 translate
	} ifelse
	
	ixScaleLeft {
		currentcolor
		idDesign 10 le { Grey } { /LW_poiSize 3 store } ifelse
		newpath
		0 L_maxY LW_poiSize add moveto			% Schattierung des Zeiger zeichnen
		idBarWide neg L_maxY lineto
		0 L_maxY LW_poiSize sub lineto
		0 L_maxY LW_poiSize add lineto
		eofill
		setcolor
		0 L_maxY LW_poiSize add moveto
		idBarWide neg L_maxY lineto
		0 L_maxY LW_poiSize sub lineto
		stroke
	} {
		currentcolor
		idDesign 10 le { Grey } { /LW_poiSize 3 store } ifelse
		newpath
		0 L_maxY LW_poiSize add moveto			% Schattierung des Zeiger zeichnen
		idBarWide L_maxY lineto
		0 L_maxY LW_poiSize sub lineto
		0 L_maxY LW_poiSize add lineto
		eofill
		setcolor
		0 L_maxY LW_poiSize add moveto
		idBarWide L_maxY lineto
		0 L_maxY LW_poiSize sub lineto
		stroke
	} ifelse

	setcolor

	% Skala zeichnen
	matrix currentmatrix
	idBarWide 2 add					% ACHTUNG: Skalenabstand wird hier mit 2 festgelegt
	ixScaleLeft { neg } if
	0 translate
	idFontSelScale selectFont
	idBarLength irMinValue irMaxValue irLowerWarn irHigherWarn idNumbScale idDeciNumber ixFineScale idScaleAngle ixScaleLeft ixScaleActive idDesign idColor idColorLow idColorHigh sp_drawScale002
	ixScaleActive {
		% Einheit Beschriftung
		idFontSelUnit selectFont
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0						% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
	} if
	setmatrix
	setmatrix_nlw
%?manual_end
} def
%?partend

%?partdef baBar009
%?fn	baBar009
%?brief	configurable bar, frame selectable, normal color green selectable, Fine-Scale selectable
%?bbox	0 0 79 159
/baBar009 {
	
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idFrameLinewidth	exch	def		%?brief linewidth of the frame							%?use INP	%?type DINT %?dflt 1
	/ixFrame			exch	def		%?brief draw frame										%?use INP	%?type BOOL	%?dflt false
	/idFontSelection	exch	def		%?brief font											%?use INP	%?type DINT %?dflt FSstdFont
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/ixScaleLeft		exch	def		%?brief scale at the left side of the bar				%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/ixNormalFineScale	exch	def		%?brief fine-scale line length like normal lines		%?use INP	%?type BOOL	%?dflt false
	/idFineScale		exch	def		%?brief number of the fine-scale fields					%?use INP	%?type DINT	%?dflt 10
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 120
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/ixNumScaleActive	exch	def		%?brief numerical scale shown							%?use INP	%?type BOOL	%?dflt true
	/idNumbScale		exch	def		%?brief number of the scale fields						%?use INP	%?type DINT	%?dflt 4
	/irErrorValueLow	exch	def		%?brief threshold value for change to error color at underrun	%?use INP	%?type REAL	%?dflt 10.0
	/irWarnValueLow		exch	def		%?brief threshold value for change to warn color at underrun	%?use INP	%?type REAL	%?dflt 20.0
	/irErrorValueHigh	exch	def		%?brief threshold value for change to error color at overrun	%?use INP	%?type REAL	%?dflt 100.0
	/irWarnValueHigh	exch	def		%?brief threshold value for change to warn color at overrun		%?use INP	%?type REAL	%?dflt 90.0
	/ixErrorActive		exch	def		%?brief activate error color red						%?use INP	%?type BOOL	%?dflt false
	/ixWarnActive		exch	def		%?brief activate warn color yellow						%?use INP	%?type BOOL	%?dflt false
	/ixWarnLower		exch	def		%?brief warning or error at underrun of the threshold	%?use INP	%?type BOOL	%?dflt false
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/ixNormGreen		exch	def		%?brief color of the normal area green activated		%?use INP	%?type BOOL	%?dflt false
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at minimum								%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue			exch	def		%?brief actual value									%?use INP	%?type REAL	%?dflt 0.0

	matrix currentmatrix_nlw
	ixScaleLeft {
		70 10 translate
	} {
		10 10 translate
	} ifelse

	% select optimized font for given font size
	idFontSelection selectFont

	currentcolor
	ixNormGreen { Green } if
	ixWarnErrActive {
		irValue irWarnValueHigh ge ixWarnHigher and
		irValue irWarnValueLow le ixWarnLower and
		ixWarnActive
		or or {
			Yellow
		} if
		irValue irErrorValueHigh ge ixWarnHigher and
		irValue irErrorValueLow le ixWarnLower and
		ixErrorActive
		or or {
			Red
		} if
	} if

	0 0 idBarWide
	ixScaleLeft { neg } if
	idBarLength irMinValue irMaxValue irValue sp_scaleProc
	rectfill	
	stroke
	setcolor
	% Rahmen zeichnen
	ixFrame {
		idFrameLinewidth setlinewidth
		0 0 idBarWide
		ixScaleLeft { neg } if
		idBarLength rectstroke
		1 setlinewidth
	} if
	% Skalierung zeichnen
	ixScaleActive {
		matrix currentmatrix_nlw
		idBarWide 5 add					% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		ixScaleLeft { neg } if
		0 translate
		idBarLength irMinValue irMaxValue idNumbScale idFineScale idScaleAngle idDeciNumber ixScaleLeft ixNumScaleActive ixNormalFineScale sp_drawScale003
		% Einheit Beschriftung
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0						% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
		setmatrix_nlw
	} if	
	setmatrix_nlw
%?manual_end
	
} def
%?partend

%?partdef baBar010
%?fn	baBar010
%?brief	logarithmic configurable bar, frame selectable, normal color green selectable
%?bbox	0 0 79 159
/baBar010 {
	
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idFrameLinewidth	exch	def		%?brief linewidth of the frame							%?use INP	%?type DINT %?dflt 1
	/ixFrame			exch	def		%?brief draw frame										%?use INP	%?type BOOL	%?dflt false
	/idFontSelection	exch	def		%?brief font											%?use INP	%?type DINT %?dflt FSstdFont
	/idDeciNumber		exch	def		%?brief number of the decimal places of the scale		%?use INP	%?type DINT		%?dflt 0
	/ixScaleLeft		exch	def		%?brief scale at the left side of the bar				%?use INP	%?type BOOL	%?dflt false
	/idScaleAngle		exch	def		%?brief angle of the scale text							%?use INP	%?type DINT	%?dflt 0.0
	/ixScaleActive		exch	def		%?brief draw scale										%?use INP	%?type BOOL	%?dflt true
	/idBarLength		exch	def		%?brief length of the bar [pixel]						%?use INP	%?type DINT	%?dflt 200
	/idBarWide			exch	def		%?brief width of the bar [pixel]						%?use INP	%?type DINT	%?dflt 15
	/ixNumFineScaleActive	exch	def		%?brief numerical finescale shown					%?use INP	%?type BOOL	%?dflt true
	/ixNumScaleActive	exch	def		%?brief numerical scale shown							%?use INP	%?type BOOL	%?dflt true
	/irErrorValueLow	exch	def		%?brief threshold value for change to error color at underrun	%?use INP	%?type REAL	%?dflt 1.0
	/irWarnValueLow		exch	def		%?brief threshold value for change to warn color at underrun	%?use INP	%?type REAL	%?dflt 2.0
	/irErrorValueHigh	exch	def		%?brief threshold value for change to error color at overrun	%?use INP	%?type REAL	%?dflt 50.0
	/irWarnValueHigh	exch	def		%?brief threshold value for change to warn color at overrun		%?use INP	%?type REAL	%?dflt 40.0
	/ixErrorActive		exch	def		%?brief activate error color red						%?use INP	%?type BOOL	%?dflt false
	/ixWarnActive		exch	def		%?brief activate warn color yellow						%?use INP	%?type BOOL	%?dflt false
	/ixWarnLower		exch	def		%?brief warning or error at underrun of the threshold	%?use INP	%?type BOOL	%?dflt false
	/ixWarnHigher		exch	def		%?brief warning or error at overrun of the threshold	%?use INP	%?type BOOL	%?dflt true
	/ixWarnErrActive	exch	def		%?brief warning or error at threshold activated			%?use INP	%?type BOOL	%?dflt false
	/ixNormGreen		exch	def		%?brief color of the normal area green activated		%?use INP	%?type BOOL	%?dflt false
	/irMaxValue			exch	def		%?brief value at maximum								%?use INP	%?type REAL	%?dflt 50.0
	/isUnit				exch	def		%?brief unit											%?use INP	%?type STRI	%?dflt ???
	/irValue			exch	def		%?brief actual value									%?use INP	%?type REAL	%?dflt 0.0

	matrix currentmatrix_nlw
	ixScaleLeft {
		70 10 translate
	} {
		10 10 translate
	} ifelse

	% select optimized font for given font size
	idFontSelection selectFont

	% berechne logarithmischen Skalierungsfaktor (es wird immer 1 dazuaddiert, da der log von 1 gleich 0 ist)
	/LDlogFact idBarLength irMaxValue 1 add log div def

	currentcolor
	ixNormGreen { Green } if
	ixWarnErrActive {
		irValue irWarnValueHigh ge ixWarnHigher and
		irValue irWarnValueLow le ixWarnLower and
		ixWarnActive
		or or {
			Yellow
		} if
		irValue irErrorValueHigh ge ixWarnHigher and
		irValue irErrorValueLow le ixWarnLower and
		ixErrorActive
		or or {
			Red
		} if
	} if

	% Balkenwert logarithmisch skalieren
	irValue irMaxValue le { irValue } { irMaxValue } ifelse
	/LRvalue exch 1 add log LDlogFact mul def
		
	0 0 idBarWide
	ixScaleLeft { neg } if
	LRvalue
	rectfill	
	stroke
	setcolor
	% Rahmen zeichnen
	ixFrame {
		idFrameLinewidth setlinewidth
		0 0 idBarWide
		ixScaleLeft { neg } if
		idBarLength rectstroke
		1 setlinewidth
	} if
	% Skalierung zeichnen
	ixScaleActive {
		matrix currentmatrix_nlw
		idBarWide 5 add					% ACHTUNG: Skalenabstand wird hier mit 5 festgelegt
		ixScaleLeft { neg } if
		0 translate
		idBarLength irMaxValue idScaleAngle idDeciNumber ixScaleLeft ixNumScaleActive ixNumFineScaleActive sp_drawScale004
		% Einheit Beschriftung
		0 idBarLength 10 add translate
		idScaleAngle rotate
		isUnit strw
		2 div neg 0						% Textlänge auswerten, dann für y den wert NULL auf den stack legen
		moveto							% zum Textursprung springen
		isUnit show_utf8
		setmatrix_nlw
	} if	
	setmatrix_nlw
%?manual_end
	
} def
%?partend

%?partdef baMessage001
%?fn baMessage001
%?brief	part for the message page, selectable: messages per page, newest message on top or bottom, inclusive turn-push-control-unit
%?bbox	0 0 959 559
/baMessage001 {
%?manual_beg
	/idScroll				exch	def		%?brief change by turning the control unit -1 / 0 / +1	%?use INP	%?type DINT	%?dflt 0
	/ixPressAckn			exch	def		%?brief push of the control unit					 	%?use INP	%?type BOOL	%?dflt false
	/ixScrollActive			exch	def		%?brief turn-push control unit function active			%?use INP	%?type BOOL	%?dflt false
	/idMsgNumPerPage		exch	def		%?brief number of the shown messages per page			%?use INP	%?type DINT	%?dflt 3
	/qdScroll				0		def		%?brief changed turning function of the control unit	%?use OUT	%?type DINT	%?dflt 0
	/qxScrollAckn			false	def		%?brief push of the control unit done					%?use OUT	%?type BOOL	%?dflt false
	/qxScrollFocusExt		false	def		%?brief focus of control unit outside the message part	%?use OUT	%?type BOOL	%?dflt false
	
	% Variablen zur Message
	/LSmsgText () def				% Message-Text
	/LXmsgValid false def			% ist dieser Index relevant (gibt es diesen index)
	/LXmsgAvail false def			% ist Message mit diesem Index relevant (ist die dazugehörige Message relevant)
	/LXmsgActive false def			% ist Message noch aktiv
	/LXmsgAckn false def			% wurde Message bereits quittiert

	% Variablen
	/LXlastMsgScrAct false def		% steht die Auswahl des Dreh-Drück auf der letzten Message?
	/LDcounter 0 def				% Message Zähler pro Seite
	/LDmsgCountBef 0 def			% Message Zähler auf vorhergehenden Seite
	/LDredCountBef 0 def			% Zähler der nicht quitierten und noch vorhandenen Messages auf vorhergehenden Seiten
	/LDmsgCountAft 0 def			% Message Zähler auf Folgeseiten
	/LDredCountAft 0 def			% Zähler der nicht quitierten und noch vorhandenen Messages auf folgenden Seiten
	/LDlastActIndex 0 def			% Index der letzten Message der aktuellen Seite
	/LDmsgActIndex 0 def			% aktueller Message Index
	/LDmsgNexFirIndex 0 def			% erster Index der Anzeigeseite nach dem Blättern
	/LDbarPosition 0 def			% Anfangspunkt des Positionsbalken
	/LDbarLength 0 def				% Länge des Positionsbalken
	/LDbarWide 60 def				% Balkenbreite des Positionsbalken
	/LDbarAreaY 236 def				% Größe des Balkenfeldes Y in Pixel
	/LDmsgLineLen 600 def			% maximale Zeilenlänge einer Message
	/LDmsgLines 5 def				% Anzahl der Messages pro Seite
	/LDmsgPixelStep 80 def			% Anzahl Pixel in Y pro Message
	/LDx1 -5 def					% linker Rand der Touchumrandung (Abstand)
	/LDy1 -1 def					% oberer Rand der Touchumrandung (Abstand)
	/LDyMsg 0 def					% Y-Position der aktuellen Message
	
	% Definitionen
	/LDmsgAreaX MDmaxMsgPixX def	% Größe des Messagefeldes X in Pixel
	/LDmsgAreaY MDmaxMsgPixY def	% Größe des Messagefeldes Y in Pixel
	/LDsymGrid MDsymbolGrid def		% Größe des Symbolrasters in Pixel

	% Font
	MXsetBigMsgFont {
		MsgBigFont
		/idMsgNumPerPage idMsgNumPerPage 1 sub store				% Wenn der Big Font verwendet wird, so wird automatisch eine Message pro Seite weniger eingeblendet
	} {
		MsgFont
	} ifelse

	% Berechnungen für die Texteinblendung
	idMsgNumPerPage 1 lt { /idMsgNumPerPage 1 store } if
	idMsgNumPerPage 15 gt { /idMsgNumPerPage 15 store } if
	/LDmsgLineLen LDmsgAreaX LDsymGrid sub LDsymGrid 2 div sub 20 sub store		% Textlänge = Gesamtbreite - Pfeiltaste - Statussymbol - Randabstand
	/LDmsgPixelStep LDmsgAreaY idMsgNumPerPage div cvi store		% Schrittbreite einer Message zur nächsten
	/LDmsgLines LDmsgPixelStep 5 sub strhl neg div cvi store		% mindestend 5 pixel Abstand zwischen den Messages (diese werden in die Pixelanzahl pro Message miteingerechnet)
	% Berechnungen für die Touchumrandung und Text-Abstand (immer relativ ausgehend vom Ursprung links oben der aktuellen Textanzeige)
	/LDx1 LDsymGrid 2 div 10 add store								% X Abstand des Textes zum Rand (Achtung auf Statusbalken)
	/LDy1 0 store											% Y Abstand des Textes zum Rand
	/LDxtouch LDmsgAreaX LDsymGrid 10 add sub store				% Länge der Touchumrandung
	/LDytouch LDmsgPixelStep 3 sub store					% Höhe der Touchumrandung


	matrix currentmatrix currentcolor

	0 0 translate
	% Positionierung für die erste Message
	1 LDmsgAreaY 1 sub translate							% Startpunkt oberhalb der ersten Zeile, Cursorposition für Rahmen
	0 0 moveto												% Startpunkt (ACHTUNG: Cursorpunkt für Textanzeige siehe sp_showMsgVar)


	% DREH - DRÜCK

	% Berechnungen für Dreh-Drückfunktion
	ixScrollActive {
		idScroll 0 gt {
			/MDmsgScrollCounter MDmsgScrollCounter 1 add store
			/qdScroll idScroll 1 sub store
			} if
		idScroll 0 lt {
			/MDmsgScrollCounter MDmsgScrollCounter 1 sub store
			/qdScroll idScroll 1 add store
		} if

		% Wenn es nur eine Messageseite gibt, muß durch Dreh-Drück nicht weitergeschoben werden.		
		MDmsgScrollCounter idMsgNumPerPage le MDmsgScrollCounter MDmsgValidNr gt and {			% wenn es nur eine (die erste) Messageseite gibt
			MDmsgScrollCounter MDmsgValidNr 1 add eq {
				/MXscrollOnMsgSym true store				% Die Auswahl steht auf dem Symbol der Message-Seite
				/MDmsgScrollCounter 0 store					% Aktuellen Scrollindex auf 0 stellen -> Focus auf dem Symbol Messageseite
			} if
		} if
		% Verschieben der gesamten Messageanzeige um eine Message zurück
		MXscrollOnMsgSym not MDmsgScrollCounter 1 lt and {
			/LDmsgActIndex MDfirstActIndex store
			{
				/LDmsgActIndex LDmsgActIndex 1 add store
				LDmsgActIndex MDmsgHighIndex gt {
					/MXscrollOnMsgSym true store				% Auswahl steht auf dem Symbol der Message-Seite
					/MDmsgScrollCounter 0 store					% Aktuellen Scrollindex auf 0 stellen -> Focus auf dem Symbol Messageseite
					exit
				} if
				LDmsgActIndex getmessageinfo						% Message von der Steuerung holen
				dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
					/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
					/LXmsgAvail exch store							% Message für diesen Client relevant
					pop pop
					LXmsgValid LXmsgAvail and {
						/MDmsgScrollCounter MDmsgScrollCounter 1 add store
						/MDfirstActIndex LDmsgActIndex store
						MDmsgScrollCounter 1 ge {
							exit
						} if
					} if
					MDfirstActIndex MDmsgHighIndex gt {				% Wenn die Auswahl auf der obersten Msg steht und weiter nach oben gerdeht wurde (also der geünschte Index höher wäre als der höchste der Anzeige)
						exit
					} if
				} {
					pop pop pop pop									% Message ist noch nicht valid, kann also noch nicht ausgewertet werden; übergebene Parameter vom stack löschen
					exit
				} ifelse
			} loop
		} if
		% Verschieben der gesamten Messageanzeige um eine Message vor
		/LDcounter 0 store
		MDmsgScrollCounter idMsgNumPerPage gt {						% Die Dreh-Drück-Auswahl soll weiterspringen und steht schon auf der untersten Message die angezeigt wird
			/LDmsgActIndex MDfirstActIndex store
			{
				/LDmsgActIndex LDmsgActIndex 1 sub store
				LDmsgActIndex getmessageinfo						% Message von der Steuerung holen
				dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
					/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
					/LXmsgAvail exch store							% Message für diesen Client relevant
					pop pop
					LXmsgValid LXmsgAvail and {
						/LDcounter LDcounter 1 add store				
						LDcounter 1 eq { /LDmsgNexFirIndex LDmsgActIndex store } if				% vorher zweite angezeigte Message in Zwischenspeicher
						/MXmsgShowTop false store												% keinesfalls kann nun mehr der Show Top true sein
						LDmsgActIndex MDmsgLowIndex ge LDcounter idMsgNumPerPage ge and {		% Messages wurden um 1 weitergeschoben
							/MDmsgScrollCounter MDmsgScrollCounter 1 sub store
							/MDfirstActIndex LDmsgNexFirIndex store								% vorher zweite angezeigte Message zur jetzigen ersten machen
							exit
						} if
						LDmsgActIndex MDmsgLowIndex lt LDcounter idMsgNumPerPage le and {		% aktuelle Seite würde nicht mehr voll nach dem weiterschieben
							/MXscrollOnMsgSym true store			% Auswahl steht auf dem Symbol der Message-Seite
							/MDmsgScrollCounter 0 store				% Aktuellen Scrollindex auf 0 stellen -> Focus auf dem Symbol Messageseite
							exit
						} if
					} if
					LDmsgActIndex MDmsgLowIndex lt {				% Wenn die Auswahl auf der untersten Msg steht und weiter nach unten gerdeht wurde (also der geünschte Index kleiner wäre als der niedrigste der Anzeige)
						/MXscrollOnMsgSym true store				% Auswahl steht auf dem Symbol der Message-Seite
						/MDmsgScrollCounter 0 store					% Aktuellen Scrollindex auf 0 stellen -> Focus auf dem Symbol Messageseite
						exit
					} if
				} {
					pop pop pop pop									% Message ist noch nicht valid, kann also noch nicht ausgewertet werden; übergebene Parameter vom stack löschen
					exit
				} ifelse
			} loop
		} if

		% Die Auswahl der Dreh-Drückfunktion wird von extern wieder ins Messagepart übernommen:
		MXscrollOnMsgSym MDmsgScrollCounter 1 eq and {
			/MXscrollOnMsgSym false store
			/MDfirstActIndex MDmsgHighIndex store
			/MXmsgShowTop true store
		} if
		MXscrollOnMsgSym MDmsgScrollCounter -1 eq and {
			/MXscrollOnMsgSym false store
			/LDcounter 0 store
			% Check der letzten Messages um die letzte Messageseite zu füllen
			/LDmsgActIndex MDmsgLowIndex store					% hier wird von der aktuellen Seite um idMsgNumPerPage zurückgesucht
			{
		 		% aktuellen Message Index für nächsten Schleifendurchlauf erhöhen, da hier von der aktuellen Seite bis zur obersten Message zurückgesucht wird (Messages davor haben den höheren Index)
				LDmsgActIndex getmessageinfo						% Message von der Steuerung holen
				dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
					/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
					/LXmsgAvail exch store							% Message für diesen Client relevant
					pop pop											% überflüssige Info vom stack löschen, da dieser hier nicht benötigt wird
					% Index der zum Zurückblättern suchen
					LXmsgValid LXmsgAvail and {
						/LDcounter LDcounter 1 add store
						/MDfirstActIndex LDmsgActIndex store
					} if
					% Schleife abbrechen wenn die Indexes für die letzte Seite gefunden wurden
					LDcounter idMsgNumPerPage ge {
						exit
					} if
				} {
					pop pop pop pop
					exit												% Schleife abbrechen, wenn die Message nicht valid übergeben wurde
				} ifelse
				% Schleife abbrechen, wenn keine weiteren Messages mehr vorhanden sind
				LDmsgActIndex MDmsgHighIndex ge {
					exit
				} if
				/LDmsgActIndex LDmsgActIndex 1 add store
			} loop
			/MDmsgScrollCounter LDcounter store							% Anzahl der Messages auf dieser Seite in den Scrollcounrter schreiben, damit dieser auf der letzten Message steht
			MDmsgHighIndex MDfirstActIndex eq {
				/MXmsgShowTop true store
			} {
				/MXmsgShowTop false store
			} ifelse
		} if

		% Kontrolle ob auf der aktuellen Messageseite aktuell noch soviele Messages angezeigt werden, wie die Nummer der Dreh-Drückauswahl den Focus hat
		/LDcounter 0 store
		/LDmsgActIndex MDfirstActIndex store
		{
			LDmsgActIndex getmessageinfo						% Message von der Steuerung holen
			dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
				/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
				/LXmsgAvail exch store							% Message für diesen Client relevant
				pop pop
				LXmsgValid LXmsgAvail and {
					/LDcounter LDcounter 1 add store				
					LDmsgActIndex MDmsgLowIndex le LDcounter idMsgNumPerPage le and {		% aktuelle Seite ist nicht mehr voll
						MDmsgScrollCounter LDcounter gt {
							/MXscrollOnMsgSym true store			% Auswahl steht auf dem Symbol der Message-Seite
							/MDmsgScrollCounter 0 store				% Aktuellen Scrollindex auf 0 stellen -> Focus auf dem Symbol Messageseite
						} if
						exit
					} if
				} if
				LDmsgActIndex MDmsgLowIndex lt {				% Wenn die Auswahl auf der untersten Msg steht und weiter nach unten gerdeht wurde (also der geünschte Index kleiner wäre als der niedrigste der Anzeige)
					exit
				} if
			} {
				pop pop pop pop									% Message ist noch nicht valid, kann also noch nicht ausgewertet werden; übergebene Parameter vom stack löschen
				exit
			} ifelse
			/LDmsgActIndex LDmsgActIndex 1 sub store
		} loop

		/qxScrollFocusExt MXscrollOnMsgSym store
		
	} if


	%Messages
	
	% Wenn keine Messages angezeigt werden
	MDmsgValidNr 0 eq {
		/MDfirstActIndex 0 store
		LDx1 strhl moveto
		(0 Messages) show_utf8
	} if
	MDmsgValidNr -1 eq {
		/MDfirstActIndex 0 store
		LDx1 strhl moveto
		(waiting for Message Information) show_utf8
	} if

	% Aktueller MessageIndex auf den Startwert setzen
	/LDmsgActIndex MDmsgHighIndex store
	/LDlastActIndex LDmsgActIndex store
	/LDcounter 0 store

	% Bei fehlerhaftem Index diesen zurücksetzen und die Messages von Anfang an anzeigen
	MDfirstActIndex 0 eq MDfirstActIndex MDmsgHighIndex gt or {
		/MDfirstActIndex MDmsgHighIndex store
	} if
	MDfirstActIndex MDmsgLowIndex lt {
		/MDfirstActIndex MDmsgLowIndex store
	} if

	MXmsgShowTop {
		/MDfirstActIndex MDmsgHighIndex store
	} if

	% Messages zur Anzeige für das aktuelle Blatt suchen (Messages auf den darüberliegenden Blättern durchchecken, um an den benötigten Index der aktuellen Seite zu kommen)
	{
		LDmsgActIndex getmessagetext						% Message von der Steuerung holen
		dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
			/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
			/LXmsgAvail exch store							% Message für diesen Client relevant
			/LXmsgActive exch store							% Fehler noch vorhanden
			/LXmsgAckn exch store							% Fehler bereits quittiert
			/LSmsgText exch store							% Fehlertext

			LXmsgValid LXmsgAvail and {
				/LDlastActIndex LDmsgActIndex store			% Letzten gültigen Messageindex speichern
				LDmsgActIndex MDfirstActIndex gt {			% check der Messages vor der aktuellen Anzeige (aber nicht wenn die oberste Seite (auf der die neueste Message sich oben einschiebt) angezeigt wird)
					/LDmsgCountBef LDmsgCountBef 1 add store										% Gesamtanzahl der vor der aktuellen Anzeige liegenden Messages speichern
					LXmsgAckn not { /LDredCountBef LDredCountBef 1 add store } if	% Zähler der nicht quittierten Meldungen erhöhen
				} if
			} if
			% Aktuell anzuzeigender Messageindex wurde nicht erreicht
			LDmsgActIndex MDmsgLowIndex lt {
				/MDfirstActIndex LDlastActIndex store		% aktuell anzuzeigender Messageindex auf den zuletzt gültigen setzen
			} if
			% Aktuell anzuzeigende Message wurde erreicht, Message anzeigen
			LDmsgActIndex MDfirstActIndex le LXmsgValid LXmsgAvail and and {
				% Position für die Anzeige der aktuellen Message setzen
				/LDyMsg LDmsgPixelStep LDcounter mul neg store
				0 LDyMsg moveto
				% Index aktualisieren
				/LDcounter LDcounter 1 add store				% Zähler der relevanten Messages die angezeigt werden erhöhen
				/LDlastActIndex LDmsgActIndex store				% Index der aktuell letzten Message dieser Seite speichern
				LDcounter 1 eq LDmsgCountBef 0 eq and {			% auf der ersten Seite ist die neueste Message immer die erste, auf den folgeseiten bleibt die Anzeige gleich, auch wenn darüber zusätzlich eine neuere Message erscheint
					/MDfirstActIndex LDmsgActIndex store		% auf der aktuellen Seite ist immer die neueste Message die erste
				} if
				% Farbauswahl zur Rahmenanzeige
 				currentcolor
%  				LXmsgActive LXmsgAckn and { LightGrey } if
 				LXmsgAckn not { Red } if
				0 LDyMsg LDxtouch LDytouch neg rectstroke
				% Symbolfläche zur Statusanzeige
				LXmsgActive not LXmsgAckn not and {
					0 LDyMsg LDsymGrid 2 div LDytouch neg rectstroke
				} {
				0 LDyMsg LDsymGrid 2 div LDytouch neg rectfill
				} ifelse
				setcolor
 				% Symbol einblenden
 				currentcolor
 				LXmsgValid LXmsgAvail and { Invisible } if
				LXmsgAckn not {
	 				matrix currentmatrix
					0 LDyMsg LDmsgPixelStep 2 div LDsymGrid 4 div add sub translate
					sp_basicsym003
					setmatrix
 				} if
				LXmsgAckn {
					matrix currentmatrix
					0 LDyMsg LDmsgPixelStep 4 div LDsymGrid 4 div add sub translate
					sp_basicsym003
					setmatrix
					matrix currentmatrix
					0 LDyMsg LDmsgPixelStep 4 div 3 mul LDsymGrid 4 div 5 sub add sub translate
					sp_basicsym002
					setmatrix
				} if
 				setcolor
				% Textanzeige der Message
				LDx1 LDy1 neg LDyMsg add moveto
				LSmsgText LDmsgLines LDmsgLineLen sp_showMsgVar	% Anzeige der Message mittels Unterfunktion
				% Dreh-Drück: Ausgewählte Message für Dreh-Drückfunktion bestimmen und Rahmen für Dreh-Drückfunktion zeichnen
				matrix currentmatrix currentcolor
				Green
				3 setlinewidth
				ixScrollActive MDmsgScrollCounter LDcounter eq and {
					2 LDyMsg 2 sub LDxtouch 4 sub LDytouch 4 sub neg rectstroke
					ixPressAckn idScroll 0 eq and {
						LDmsgActIndex setmessageack
						/qxScrollAckn true store
					} {
						/qxScrollAckn false store
					} ifelse
				} if
				1 setlinewidth
				setcolor setmatrix 
				% Touch für diese Message kontrollieren
				0 LDyMsg moveto
 				_mdown {
 					_mxposd _myposd itransform
 					newpath 0 LDytouch neg rlineto LDxtouch 0 rlineto 0 LDytouch rlineto ineofill			% Touchbereich festlegen: hinterlässt true oder false auf dem stack
 				} {
 					false										% keine Touchscreen-Berührung
				} ifelse {										% die Touchfunktion hinterlässt true oder false auf dem stack, deswegen liegt nach dem ifelse ein boolscher Wert auf dem stack
					LDmsgActIndex setmessageack
				} if
			} if
			% aktuellen Message index für nächsten Schleifendurchlauf vermindern
			/LDmsgActIndex LDmsgActIndex 1 sub store
			% Schleife abbrechen, wenn die Seite voll ist, oder keine weiteren Messages mehr vorhanden sind
			LDcounter idMsgNumPerPage ge LDmsgActIndex MDmsgLowIndex lt or {
				exit
			} if
		} {
			pop pop pop pop pop								% Message ist noch nicht valid, kann also noch nicht ausgewertet werden; übergebene Parameter vom stack löschen
			exit
		} ifelse
	} loop
	setcolor setmatrix

	% TOUCH

	% Messages quittieren und weiterblättern auf der Message Seite
	% Variablen zurücksetzen, wenn die Message-Seite verändert wird (bei jedem Touch auf dieser Seite!)

	% Startwerte neu setzen
	/LDcounter 0 store
	/LDmsgActIndex MDmsgHighIndex store
	% Page up
	MDfirstActIndex MDmsgHighIndex lt {
		% Check der Messages auf den davorliegenden Seiten um zurückblättern zu können
		/LDmsgActIndex MDfirstActIndex store					% hier wird von der aktuellen Seite um idMsgNumPerPage zurückgesucht
		{
	 		% aktuellen Message Index für nächsten Schleifendurchlauf erhöhen, da hier von der aktuellen Seite bis zur obersten Message zurückgesucht wird (Messages davor haben den höheren Index)
			/LDmsgActIndex LDmsgActIndex 1 add store
			LDmsgActIndex getmessageinfo						% Message von der Steuerung holen
			dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
				/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
				/LXmsgAvail exch store							% Message für diesen Client relevant
				pop pop											% überflüssige Info vom stack löschen, da dieser hier nicht benötigt wird
				% Index der zum Zurückblättern suchen
				LXmsgValid LXmsgAvail and {
					/LDcounter LDcounter 1 add store
					/LDmsgNexFirIndex LDmsgActIndex store
				} if
				% Schleife abbrechen wenn die Indexes zum zurückblättern gefunden wurden
				LDcounter idMsgNumPerPage ge {
					exit
				} if
			} {
				pop pop pop pop
				exit												% Schleife abbrechen, wenn die Message nicht valid übergeben wurde
			} ifelse
			% Schleife abbrechen, wenn keine weiteren Messages mehr vorhanden sind
			LDmsgActIndex MDmsgHighIndex ge {
				exit
			} if
		} loop

		% Symbol
		matrix currentmatrix currentcolor
		LDmsgAreaX LDsymGrid sub LDmsgAreaY LDsymGrid sub translate
		baTouchButton001 {
			/MDfirstActIndex LDmsgNexFirIndex store					% Anfangsindex des nächsten Blattes setzen
		} if
		setcolor setmatrix
	} if
	matrix currentmatrix currentcolor
	% Farbumschaltung des Symbols
	LDredCountBef 0 gt { Red } if
	LDmsgAreaX LDmsgAreaY translate
	180 rotate
	sp_basicsym001													% Pfeil Zeichnen
	setcolor setmatrix

	% Startwerte neu setzen
	/LDcounter 0 store
	/LDmsgActIndex MDmsgLowIndex store
	% Page down
	LDlastActIndex MDmsgLowIndex gt MDmsgValidNr idMsgNumPerPage gt and {
		% Check der Messages auf den nachfolgenden Seiten für den Farbwechsel des Symboles
		/LDmsgActIndex LDlastActIndex store
		{
	 		% aktuellen Message Index für nächsten Schleifendurchlauf verringern
			/LDmsgActIndex LDmsgActIndex 1 sub store
			LDmsgActIndex getmessageinfo						% Message von der Steuerung holen
			dup {												% Kontrolle, ob die Antwort der Funktion bereits "valid" ist
				/LXmsgValid exch store							% valid: Messageinformation ist übertragen worden und kann gechecked werden
				/LXmsgAvail exch store							% Message für diesen Client relevant
				/LXmsgActive exch store							% Fehler noch vorhanden
				/LXmsgAckn exch store							% Fehler bereits quittiert
				% Kontrolle ob nicht quitierte Messages vorhanden sind
				LXmsgValid LXmsgAvail and {
					/LDcounter LDcounter 1 add store
					LDcounter 1 eq { /LDmsgNexFirIndex LDmsgActIndex store } if						% ersten der nachfolgenden Messages speichern, da dieser der ersten nach dem Weiterblättern sein wird
					/LDmsgCountAft LDmsgCountAft 1 add store										% Gesamtanzahl der vor der aktuellen Anzeige liegenden Messages speichern
					LXmsgAckn not { /LDredCountAft LDredCountAft 1 add store } if		% Zähler der nicht quittierten Meldungen erhöhen
				} if
			} {
				pop pop pop pop
				exit												% Schleife abbrechen, wenn die Message nicht valid übergeben wurde
			} ifelse
			% Schleife abbrechen, wenn keine weiteren Messages mehr vorhanden sind
			LDmsgActIndex MDmsgLowIndex le {
				exit
			} if
		} loop
				
		% Symbol
		matrix currentmatrix currentcolor
		LDmsgAreaX LDsymGrid sub 0 translate
		baTouchButton001 {
			/MDfirstActIndex LDmsgNexFirIndex store					% Anfangsindex des nächsten Blattes setzen
		} if
		setcolor setmatrix
	} if
	matrix currentmatrix currentcolor
	% Farbumschaltung des Symbols
	LDredCountAft 0 gt { Red } if
	LDmsgAreaX LDsymGrid sub 0 translate
	sp_basicsym001
	setcolor setmatrix

	% check ob aktuell die neuesten Messages angezeigt werden, oder ob eine darunterliegende Seite mit älteren Messages angezeigt wird
	MDfirstActIndex MDmsgHighIndex eq {
		/MXmsgShowTop true store
	} {
		/MXmsgShowTop false store
	} ifelse


	% BALKEN

	% Positionsbalken zeichnen
	matrix currentmatrix currentcolor
	LDmsgAreaX LDsymGrid 10 sub sub LDmsgAreaY LDsymGrid 1 add sub translate			% Koordinatenursprung Position auf Balkenrahmen links oben
	/LDbarWide LDsymGrid 20 sub store
 	/LDbarAreaY LDmsgAreaY LDsymGrid 2 mul 4 add sub store								% Rahmenhöhe ist Msg-Area minus zwei Pfeilsymbole minus Abstand
	LightGrey
 	0 0 LDbarWide LDbarAreaY 2 add neg rectstroke
	% Berechnen der Balkenlänge und der Balkenposition
	MDmsgValidNr idMsgNumPerPage gt LDmsgCountBef 0 gt or {
		/LDbarLength LDbarAreaY MDmsgValidNr div idMsgNumPerPage mul store				% Balkenlänge über die Message Gesamanzahl herausrechnen
		/LDbarPosition LDmsgCountBef idMsgNumPerPage div LDbarLength mul 2 add store	% Balkenposition im Verhältnis LDbarLength/MDmsgValidNr = LDbarPosition/LDmsgCountBef herausrechnen; Ursprung ist links oben: deshalb nochmals vom Gesamtbereich abziehen (und 2 pixel Abstand vom Rahmen)
		LDbarPosition LDbarLength add LDbarAreaY gt {
			/LDbarLength LDbarAreaY LDbarPosition sub store								% Korrektur der Balkenlänge, wenn die angezeigte Seite nicht mit Messages voll ist
		} if
	} {
 		/LDbarLength LDbarAreaY 2 sub store												% wenn nur eine Seite angezeigt wird füllt der Balken alles, Rahmen und Abstand zum Rahmen oben und unten abziehen
 		/LDbarPosition 2 store															% Balkenursprung ist links oben, Rahmen und Absatnd zum Rahmen abziehen
	} ifelse
	% Balken zeichnen
	LightGrey
	2 LDbarPosition neg LDbarWide 4 sub LDbarLength neg rectfill
	setcolor setmatrix	


	% OUTPUT
	
	% Ausgangsvariablen
	qxScrollFocusExt																	% Ausgangsvariable auf den stack legen
	qxScrollAckn																		% Ausgangsvariable auf den stack legen
	qdScroll																			% Ausgangsvariable auf den stack legen
	
%?manual_end

} def
%?partend


%?partdef baRoundDisplay001
%?fn baRoundDisplay001
%?brief	round display unit with configurable numerical and graphical scale
%?bbox	-80 -80 79 79
/baRoundDisplay001 {
%?manual_beg
	% Variablen werden beginnend mit der niedrigsten Priorität aufgelistet
	/idDeciNumbDig		exch	def		%?brief number of the decimal points of the digital displayed value		%?use INP %?type DINT %?dflt 0
	/ixShowDigValue		exch	def		%?brief digital value in the middle shown						%?use INP	%?type BOOL	%?dflt true
	/idRadius			exch	def		%?brief outer radius of the scale lines							%?use INP	%?type DINT	%?dflt 70
	/ixScaleOuter		exch	def		%?brief numerical scale outside the scale lines (not inside)	%?use INP	%?type BOOL	%?dflt false
	/idAngleRange		exch	def		%?brief angle of the scale (positive is counterclockwise)		%?use INP	%?type DINT		%?dflt -270
	/idAngleBegin		exch	def		%?brief angle of the scale line start point (0 degree = X-axis)	%?use INP	%?type DINT		%?dflt 225
	/idDeciNumber		exch	def		%?brief number of the decimal points of the numerical scale		%?use INP	%?type DINT		%?dflt 0
	/idFontSelUnit		exch	def		%?brief font for digital value and unit							%?use INP %?type DINT %?dflt FSminiFont
	/idFontSelScale		exch	def		%?brief font for scale numbers									%?use INP %?type DINT %?dflt FSminiFont
	/irNumbScale		exch	def		%?brief number of the scale fields								%?use INP	%?type REAL	%?dflt 4.0
	/ixScaleActive		exch	def		%?brief show numerical scale									%?use INP	%?type BOOL	%?dflt true
	/idDesign			exch	def		%?brief design of the scale (linewidth ...)						%?use INP	%?type DINT	%?dflt 1
	/idColorHigh		exch	def		%?brief color for the high value scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 4
	/idColorLow			exch	def		%?brief color for the low value scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 2
	/idColor			exch	def		%?brief color for the middle scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 1
	/irHigherWarn		exch	def		%?brief value for the beginning of the high value colored scale line	%?use INP	%?type REAL	%?dflt 90.0
	/irLowerWarn		exch	def		%?brief value for the end of the low value colored scale line	%?use INP	%?type REAL	%?dflt 10.0
	/irMaxValue			exch	def		%?brief value at the end of the scale							%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at the beginning of the scale						%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit													%?use INP	%?type STRI	%?dflt ???
	/ixShortNeedle		exch	def		%?brief round display without center and with short needle 		%?use INP	%?type BOOL	%?dflt false
	/irValue			exch	def		%?brief value													%?use INP	%?type REAL	%?dflt 0.0

	/L_ValAng idAngleBegin def			% Winkelwert des Zeigers
	/L_AngBlock 10 def					% Winkelwert an dem der Zeiger ausserhalb der Skala zum Anschlag kommt
	/L_ValAng 0 def
	/LD_ValRange 0 def
	/LS_helps () def
	/LD_Help 0 def

	matrix currentmatrix

	% Skalierung
	idFontSelScale selectFont
	irMinValue irMaxValue irLowerWarn irHigherWarn irNumbScale 5 idAngleBegin idAngleRange idDeciNumber idRadius 0 ixScaleOuter ixScaleActive idDesign idColor idColorLow idColorHigh sp_drawScaleArc001			% Skalierung des Zeigerdisplay zeichnen

	% Zeiger zeichnen
	matrix currentmatrix
	
	% Zeigerwinkel berechnen
	/LD_ValRange irMaxValue irMinValue sub irNumbScale cvi div irNumbScale mul store				% Wertebereich der gesamten Skala herausrechnen wenn z.B. eine Skalenteileung mit einem Kommawert übergeben wurde
	/L_ValAng idAngleBegin irValue irMinValue sub idAngleRange mul LD_ValRange div add store		% Achtung auf Berechnungsreihenfolge wegen Rundungsfehlern durch virtual oversize
	% Skalenbereichsunter- und überschreitung abfangen
	idAngleRange 0 lt {
		L_ValAng idAngleBegin L_AngBlock add gt { /L_ValAng idAngleBegin L_AngBlock add store } if
		L_ValAng idAngleBegin idAngleRange add L_AngBlock sub lt { /L_ValAng idAngleBegin idAngleRange add L_AngBlock sub store } if
	} { 
		L_ValAng idAngleBegin L_AngBlock sub lt { /L_ValAng idAngleBegin L_AngBlock sub store } if
		L_ValAng idAngleBegin idAngleRange add L_AngBlock add gt { /L_ValAng idAngleBegin idAngleRange add L_AngBlock add store } if
	} ifelse

	idDesign 4 eq { 3 setlinewidth } if
	
	ixShortNeedle {
		% Zeiger zeichnen
		matrix currentmatrix
		L_ValAng rotate					% Zeiger rotieren
		ixScaleOuter { /LD_Help idRadius 30 sub store } { /LD_Help idRadius 40 sub store } ifelse
		currentcolor
		Grey
		newpath
		LD_Help -3 moveto						% Schattierung des Zeiger zeichnen
		idRadius 5 sub 0 lineto
		LD_Help 3 lineto
		LD_Help -3 lineto
		eofill
		setcolor
		LD_Help -3 moveto						% Zeiger zeichnen
		idRadius 5 sub 0 lineto
		LD_Help 3 lineto
		stroke
		setmatrix
	} {
		% Einheit
		idFontSelUnit selectFont
		isUnit dup strw					% Länge der Beschriftung errechnen
		2 div neg strh moveto				% zum Beschriftungspunkt springen (um Stringlänge halbe nach links)
		show_utf8
	
		% digitaler Wert
		ixShowDigValue {
			irValue
			LS_helps idDeciNumbDig ncvs					% Anzeigewert in String umwandeln
			dup strw						% Länge der Beschriftung errechnen
			2 div neg strhl moveto			% zum Beschriftungspunkt springen (um Stringlänge halbe nach links)
			show_utf8
		} if

		% Zeiger zeichnen
		matrix currentmatrix
		L_ValAng rotate					% Zeiger rotieren
		currentcolor
		Grey
		newpath
		0 -3 moveto						% Schattierung des Zeiger zeichnen
		idRadius 5 sub 0 lineto
		0 3 lineto
		-3 0 lineto
		0 -3 lineto
		eofill
		setcolor
		0 -3 moveto						% Zeiger zeichnen
		idRadius 5 sub 0 lineto
		0 3 lineto
		-3 0 lineto
		0 -3 lineto
		stroke
		setmatrix
	} ifelse
	1 setlinewidth
	setmatrix
	setmatrix

%?manual_end
} def
%?partend

%?partdef baRoundDisplay002
%?fn baRoundDisplay002
%?brief	round display unit with segment of a circle
%?bbox	-80 -80 79 79
/baRoundDisplay002 {
%?manual_beg
	/idDeciNumbDig		exch	def		%?brief number of the decimal points of the digital displayed value		%?use INP %?type DINT %?dflt 0
	/ixShowDigValue		exch	def		%?brief digital value in the middle shown						%?use INP	%?type BOOL	%?dflt true
	/idRadius			exch	def		%?brief outer radius of the scale lines							%?use INP	%?type DINT	%?dflt 70
	/ixScaleOuter		exch	def		%?brief numerical scale outside the scale lines (not inside)	%?use INP	%?type BOOL	%?dflt false
	/idAngleRange		exch	def		%?brief angle of the scale (positive is counterclockwise)		%?use INP	%?type DINT		%?dflt -360
	/idAngleBegin		exch	def		%?brief angle of the scale line start point (0 degree = X-axis)	%?use INP	%?type DINT		%?dflt 90
	/idDeciNumber		exch	def		%?brief number of the decimal points of the numerical scale		%?use INP	%?type DINT		%?dflt 0
	/idFontSelUnit		exch	def		%?brief font for digital value and unit							%?use INP %?type DINT %?dflt FSminiFont
	/idFontSelScale		exch	def		%?brief font for scale numbers									%?use INP %?type DINT %?dflt FSminiFont
	/irNumbScale		exch	def		%?brief number of the scale fields								%?use INP	%?type REAL	%?dflt 12.0
	/ixScaleActive		exch	def		%?brief show numerical scale									%?use INP	%?type BOOL	%?dflt true
	/idDesign			exch	def		%?brief design of the scale (linewidth ...)						%?use INP	%?type DINT	%?dflt 1
	/idColor			exch	def		%?brief color for the middle scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red	%?use INP	%?type DINT	%?dflt 1
	/irMaxValue			exch	def		%?brief value at the end of the scale							%?use INP	%?type REAL	%?dflt 60.0
	/irMinValue			exch	def		%?brief value at the beginning of the scale						%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit													%?use INP	%?type STRI	%?dflt ???
	/irValue			exch	def		%?brief value													%?use INP	%?type REAL	%?dflt 0.0

	/L_ValAng idAngleBegin def			% Winkelwert des Zeigers
	/L_ValAng 0 def
	/LD_ValRange 0 def
	/LS_helps () def
	/LD_Help 0 def

	matrix currentmatrix

	% Winkel berechnen
	/LD_ValRange irMaxValue irMinValue sub irNumbScale cvi div irNumbScale mul store				% Wertebereich der gesamten Skala herausrechnen wenn z.B. eine Skalenteileung mit einem Kommawert übergeben wurde
	/L_ValAng idAngleBegin irValue irMinValue sub idAngleRange mul LD_ValRange div add store		% Achtung auf Berechnungsreihenfolge wegen Rundungsfehlern durch virtual oversize

	% Kreissektor zeichnen
	currentcolor
	idColor sp_set_color
%	Grey
	newpath
	0 0 moveto
	idAngleRange 0 lt { 0 0 idRadius idAngleBegin L_ValAng arcn } { 0 0 idRadius idAngleBegin L_ValAng arc } ifelse
	0 0 lineto
	eofill
	setcolor
	0 0 moveto
	idAngleRange 0 lt { 0 0 idRadius idAngleBegin L_ValAng arcn } { 0 0 idRadius idAngleBegin L_ValAng arc } ifelse
	0 0 lineto
	stroke
	
	% Einheit
	idFontSelUnit selectFont
	isUnit dup strw					% Länge der Beschriftung errechnen
	2 div neg 15 moveto				% zum Beschriftungspunkt springen (um Stringlänge halbe nach links)
	show_utf8

	% digitaler Wert
	ixShowDigValue {
		irValue
		LS_helps idDeciNumbDig ncvs					% Anzeigewert in String umwandeln
		dup strw						% Länge der Beschriftung errechnen
		2 div neg -25 moveto			% zum Beschriftungspunkt springen (um Stringlänge halbe nach links)
		show_utf8
	} if

	% Skalierung zeichnen
	idFontSelScale selectFont
	irMinValue irMaxValue irMinValue irMaxValue irNumbScale 5 idAngleBegin idAngleRange idDeciNumber idRadius 0 ixScaleOuter ixScaleActive idDesign 0 0 0 sp_drawScaleArc001			% Skalierung zeichnen
	setmatrix

%?manual_end
} def
%?partend

%?partdef baRoundDisplay003
%?fn baRoundDisplay003
%?brief	round display unit with configurable numerical and graphical scale, configurable fine scale
%?bbox	-80 -80 79 79
/baRoundDisplay003 {
%?manual_beg
	/idDeciNumbDig		exch	def		%?brief number of the decimal points of the digital displayed value		%?use INP %?type DINT %?dflt 0
	/ixShowDigValueUnit	exch	def		%?brief digital value and unit shown in the middle				%?use INP	%?type BOOL	%?dflt true
	/idRadius			exch	def		%?brief outer radius of the scale lines							%?use INP	%?type DINT	%?dflt 70
	/idRadiusScale		exch	def		%?brief Radius of the numerical Scale (0=standard)				%?use INP	%?type DINT	%?dflt 0
	/idAngleRange		exch	def		%?brief angle of the scale (positive is counterclockwise)		%?use INP	%?type DINT		%?dflt -270
	/idAngleBegin		exch	def		%?brief angle of the scale line start point (0 degree = X-axis)	%?use INP	%?type DINT		%?dflt 225
	/idDeciNumber		exch	def		%?brief number of the decimal points of the numerical scale		%?use INP	%?type DINT		%?dflt 0
	/idFontSelUnit		exch	def		%?brief font for digital value and unit							%?use INP %?type DINT %?dflt FSminiFont
	/idFontSelScale		exch	def		%?brief font for scale numbers									%?use INP %?type DINT %?dflt FSminiFont
	/irNumbFineScale	exch	def		%?brief number of the fine scale fields per scale field			%?use INP	%?type DINT	%?dflt 2
	/irNumbScale		exch	def		%?brief number of the scale fields								%?use INP	%?type REAL	%?dflt 4.0
	/ixDigValueHoriz	exch	def		%?brief show digital Value and Unit in horizontal position		%?use INP	%?type BOOL	%?dflt false
	/idDesign			exch	def		%?brief design of the scale (linewidth ...)						%?use INP	%?type DINT	%?dflt 1
	/idColorHigh		exch	def		%?brief color for the high value scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 4
	/idColorLow			exch	def		%?brief color for the low value scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 2
	/idColor			exch	def		%?brief color for the middle scale line: 0=neutral, 1=green, 2=blue, 3=yellow, 4=red, 5=grau, 6= hellgrau	%?use INP	%?type DINT	%?dflt 1
	/irHigherWarn		exch	def		%?brief value for the beginning of the high value colored scale line	%?use INP	%?type REAL	%?dflt 90.0
	/irLowerWarn		exch	def		%?brief value for the end of the low value colored scale line	%?use INP	%?type REAL	%?dflt 10.0
	/irMaxValue			exch	def		%?brief value at the end of the scale							%?use INP	%?type REAL	%?dflt 100.0
	/irMinValue			exch	def		%?brief value at the beginning of the scale						%?use INP	%?type REAL	%?dflt 0.0
	/isUnit				exch	def		%?brief unit													%?use INP	%?type STRI	%?dflt ???
	/idRadiusNdlBegin	exch	def		%?brief inner radius for needle (0=full needle is drawn)		%?use INP	%?type DINT	%?dflt 0
	/irValue			exch	def		%?brief value													%?use INP	%?type REAL	%?dflt 0.0

	/L_ValAng idAngleBegin def			% Winkelwert des Zeigers
	/L_AngBlock 5 def					% Winkelwert an dem der Zeiger ausserhalb der Skala zum Anschlag kommt
	/L_ValAng 0 def
	/LD_ValRange 0 def
	/LS_helps () def
	/LD_RadBeg 0 def
	/LX_ScaleActive true def
	/LX_FatNeedle false store

	matrix currentmatrix

	idRadiusScale 0 ge {
		/LX_ScaleActive true store
	} {
		/LX_ScaleActive false store
	} ifelse

	% Design
	idDesign 10 gt {
		/idDesign idDesign 10 sub store
		/LX_FatNeedle true store
	} if

	% Skalierung
	idFontSelScale selectFont
	idRadiusScale 0 lt { /idRadiusScale idRadius 30 sub store } if			% definiere den Standardradius der Skalierung
	irMinValue irMaxValue irLowerWarn irHigherWarn irNumbScale irNumbFineScale idAngleBegin idAngleRange idDeciNumber idRadius idRadiusScale false LX_ScaleActive idDesign idColor idColorLow idColorHigh
	sp_drawScaleArc001											% Skalierung des Zeigerdisplay zeichnen

	matrix currentmatrix
	
	% Einheit und Digitalwert zeichnen
	ixShowDigValueUnit {
		% Einheit
		idFontSelUnit selectFont
		ixDigValueHoriz {
			(X) strw strh 2 div neg moveto						% Einheit rechts angezeigt
		} {
			isUnit strw 2 div neg strh moveto					% Einheit oben angezeigt
		} ifelse
		isUnit show_utf8
	
		% digitaler Wert
		irValue
		LS_helps idDeciNumbDig ncvs		% Anzeigewert in String umwandeln

		ixDigValueHoriz {
			dup strw (X) strw add neg strh 2 div neg moveto		% Digitalwert links angezeigt
		} {
			dup strw 2 div neg strhl moveto						% Digitalwert unten angezeigt
		} ifelse
		show_utf8
	} if

	% Zeiger zeichnen

	% inneren Radius des Zeigerbeginnes abfangen
	idRadiusNdlBegin idRadius gt { /LD_RadBeg idRadius store } { /LD_RadBeg idRadiusNdlBegin store } ifelse
	
	% Zeigerwinkel berechnen
	1 setlinewidth
	irNumbScale 0 eq { /irNumbScale 1 store } if
	/LD_ValRange irMaxValue irMinValue sub irNumbScale cvi div irNumbScale mul store				% Wertebereich der gesamten Skala herausrechnen wenn z.B. eine Skalenteileung mit einem Kommawert übergeben wurde
	/L_ValAng idAngleBegin irValue irMinValue sub idAngleRange mul LD_ValRange div add store		% Achtung auf Berechnungsreihenfolge wegen Rundungsfehlern durch virtual oversize
	% Skalenbereichsunter- und überschreitung abfangen
	idAngleRange 0 lt {
		L_ValAng idAngleBegin L_AngBlock add gt { /L_ValAng idAngleBegin L_AngBlock add store } if
		L_ValAng idAngleBegin idAngleRange add L_AngBlock sub lt { /L_ValAng idAngleBegin idAngleRange add L_AngBlock sub store } if
	} { 
		L_ValAng idAngleBegin L_AngBlock sub lt { /L_ValAng idAngleBegin L_AngBlock sub store } if
		L_ValAng idAngleBegin idAngleRange add L_AngBlock add gt { /L_ValAng idAngleBegin idAngleRange add L_AngBlock add store } if
	} ifelse
	matrix currentmatrix
	L_ValAng rotate					% Zeiger rotieren
	currentcolor
	LX_FatNeedle {
		Grey 
		newpath
		LD_RadBeg -5 moveto						% Schattierung des Zeiger zeichnen
		idRadius 5 sub 0 lineto
		LD_RadBeg 5 lineto
		idRadiusNdlBegin 0 le { LD_RadBeg 5 sub 0 lineto } if
		LD_RadBeg -5 lineto
		eofill
		setcolor
		3 setlinewidth
		LD_RadBeg -5 moveto						% Zeiger zeichnen
		idRadius 5 sub 0 lineto
		LD_RadBeg 5 lineto
		idRadiusNdlBegin 0 le { LD_RadBeg 5 sub 0 lineto } if
		LD_RadBeg -5 lineto
		stroke
	} {
		idDesign 3 le { Grey } if				% Bei Design ab 4 keine Farbumschaltung für die Füllung des Zeiger
		newpath
		LD_RadBeg -3 moveto						% Schattierung des Zeiger zeichnen
		idRadius 5 sub 0 lineto
		LD_RadBeg 3 lineto
		idRadiusNdlBegin 0 le { LD_RadBeg 3 sub 0 lineto } if
		LD_RadBeg -3 lineto
		eofill
		setcolor
		LD_RadBeg -3 moveto						% Zeiger zeichnen
		idRadius 5 sub 0 lineto
		LD_RadBeg 3 lineto
		idRadiusNdlBegin 0 le { LD_RadBeg 3 sub 0 lineto } if
		LD_RadBeg -3 lineto
		stroke
	} ifelse
	setmatrix
	1 setlinewidth
	setmatrix
	setmatrix

%?manual_end
} def
%?partend

%?partdef baBubble001
%?fn baBubble001
%?brief	circular bubble level
%?bbox	0 0 79 79
/baBubble001 {
%?manual_beg
	/irScaleY	exch	def		%?brief maximum positive Y angle	%?use INP	%?type REAL	%?dflt 5.0
	/irScaleX	exch	def		%?brief maximum positive X angle	%?use INP	%?type REAL	%?dflt 5.0
	/irYpos	exch	def			%?brief Y angle						%?use INP	%?type REAL	%?dflt 0.0
	/irXpos	exch	def			%?brief X angle						%?use INP	%?type REAL	%?dflt 0.0

	matrix currentmatrix_nlw currentcolor
	
	/L_Xpos 0 def
	/L_Ypos 0 def
	/L_MaxX	39 def
	/L_MaxY	39 def
	/L_radBub 5 def
	/L_radOneDeg 8 def

	LightGrey

	% Rahmen zeichnen
	1 1 77 77 rectstroke
	% Fadenkreuz zeichnen
	39 39 translate
	-38 0 moveto 39 0 lineto
	0 -38 moveto 0 39 lineto
	/L_radOneDeg L_MaxX irScaleX div round store
	L_radOneDeg 0 moveto 0 0 L_radOneDeg 0 360 arc stroke 
%	L_radOneDeg 2 mul 0 moveto 0 0 L_radOneDeg 2 mul 0 360 arc stroke 
	L_radOneDeg 3 mul 0 moveto 0 0 L_radOneDeg 3 mul 0 360 arc stroke 
%	L_radOneDeg 4 mul 0 moveto 0 0 L_radOneDeg 4 mul 0 360 arc stroke 
	setcolor
	currentcolor
	
	irXpos irScaleX gt {
		/irScaleX irXpos exch store
	} if
	irYpos irScaleY gt {
		/irScaleY irYpos exch store
	} if

	/L_Xpos irXpos irScaleX div L_MaxX mul store
	/L_Ypos irYpos irScaleY div L_MaxY mul store
	L_Xpos L_radBub add L_Ypos moveto
	L_Xpos L_Ypos L_radBub 0 360 arc stroke

	setcolor setmatrix_nlw
%?manual_end
} def
%?partend

%?partdef baBubble002
%?fn	baBubble002
%?brief	circular bubble level with absolut angle, scaleable
%?bbox	0 0 79 79
/baBubble002 {
	
%?manual_beg
	/idDummy exch def	%?brief dummy %?use INP %?type REAL %?dflt 0.0
	/ixShowXYang	exch	def	%?brief anzeige X und Y Winkel %?use INP %?type BOOL %?dflt false
	/ixShowAbsAng	exch	def	%?brief anzeige absoluter Winkel %?use INP %?type BOOL %?dflt false
	/ixCursor1Err	exch	def	%?brief cursor 1 Errorfarbe %?use INP %?type BOOL %?dflt false
	/ixCursor1Warn	exch	def	%?brief cursor 1 Warnfarbe %?use INP %?type BOOL %?dflt false
	/irMax	exch	def		%?brief maximaler Winkelwert	%?use INP	%?type REAL	%?dflt 5
	/irScale	exch	def		%?brief scale X and Y (1 = grid unit)		%?use INP	%?type REAL	%?dflt 1
	/irAbsAngle1 exch def		%?brief absolute position			%?use INP	%?type REAL %?dfl 0.00
	/irYang1	exch	def		%?brief Y-position des 1. Cursor	%?use INP	%?type REAL	%?dflt 0
	/irXang1	exch	def		%?brief X-position des 1. Cursor	%?use INP	%?type REAL	%?dflt 0
	/idCursorForm1	exch	def		%?brief 1. Cursor-form: 0 nicht aktiv, 1 quadrat, 2 kreuz, 3 kreis	%?use INP	%?type DINT	%?dflt 0

	matrix currentmatrix currentcolor

	/L_Range 35 def
	/L_Xposition 0 def
	/L_Yposition 0 def
	/L_size 5 def
	/L_radOneDeg 8 def
	/L_showCursor false def
	/L_help 10 def
	/LS_helps () def

	irScale 2 gt {
		/L_size L_size 2 mul store
	} if

	% Berechnung der Randkoordinaten
	/L_Range MDsymbolGrid irScale mul 2 div 5 sub store

	% Ursprung Koordinatensystem setzen
	MDsymbolGrid irScale mul 2 div dup translate

	LightGrey

	% Libellenringe zeichnen
	/L_radOneDeg L_Range irMax div round store
	irScale 1 gt {
		L_radOneDeg 0 moveto 0 0 L_radOneDeg 0 360 arc stroke 
		L_radOneDeg 3 mul 0 moveto 0 0 L_radOneDeg 3 mul 0 360 arc stroke 
		L_radOneDeg 5 mul 0 moveto 0 0 L_radOneDeg 5 mul 0 360 arc stroke 
		/L_help L_radOneDeg store
	} {
		L_radOneDeg 2 mul 0 moveto 0 0 L_radOneDeg 2 mul 0 360 arc stroke 
		L_radOneDeg 4 mul 0 moveto 0 0 L_radOneDeg 4 mul 0 360 arc stroke 
		/L_help L_radOneDeg 2 mul store
	} ifelse

	% Fadenkreuz zeichnen
	ixShowAbsAng ixShowXYang and {
		L_help neg 0 moveto
		L_Range neg 0 lineto stroke
		L_help 0 moveto
		L_Range 0 lineto stroke
		0 L_help neg moveto
		0 L_Range neg lineto stroke
		0 L_help moveto
		0 L_Range lineto stroke
	} {
		L_Range neg 0 moveto
		L_Range 0 lineto stroke
		0 L_Range neg moveto
		0 L_Range lineto stroke
	} ifelse
	
	setcolor
	currentcolor

	% Winkelanzeige
	ixShowXYang {
		MiniFont
		L_Range 3 sub 3 moveto
		(Â°) strw neg 0 rmoveto
		irXang1 LS_helps 1 1 nncvs 
		dup strw neg 0 rmoveto
		show_utf8										% Wert anzeigen
		(Â°) show_utf8									% Einheit anzeigen
		-3 L_Range neg 5 add moveto
		(Â°) strw neg 0 rmoveto
		irYang1 LS_helps 1 1 nncvs 
		dup strw neg 0 rmoveto
		show_utf8										% Wert anzeigen
		(Â°) show_utf8									% Einheit anzeigen
	} if 
	
	% Berechnen der Cursorposition
	/L_Xposition irXang1 irMax div L_Range mul store 
	/L_Yposition irYang1 irMax div L_Range mul store 

	ixShowXYang {
		L_Xposition L_Range lt L_Xposition L_Range neg gt and L_Yposition L_Range lt L_Yposition L_Range neg gt and and
		/L_showCursor exch store
	} {
		/L_showCursor true store
		L_Xposition L_Range gt { /L_Xposition L_Range store } if
		L_Xposition L_Range neg lt { /L_Xposition L_Range neg store } if
		L_Yposition L_Range gt { /L_Yposition L_Range store } if
		L_Yposition L_Range neg lt { /L_Yposition L_Range neg store } if
	} ifelse

	% Anzeige des Absolutwinkels
	ixShowAbsAng {
		ixShowXYang {
			irAbsAngle1 1 gt irAbsAngle1 -1 lt or {
				MiniFont
				irAbsAngle1 LS_helps 1 1 nncvs 
				dup strwh 2 div neg exch 2 div neg exch moveto
				(Â°) strw neg 0 rmoveto
				show_utf8										% Wert anzeigen
				(Â°) show_utf8									% Einheit anzeigen
			} if
		} {
			StdFont
			irAbsAngle1 LS_helps 1 1 nncvs 
			L_Xposition L_Range 2 div gt L_Yposition L_Range 0.75 mul neg lt and {
				L_Range neg L_Range neg moveto
			} { 
				dup strw L_Range exch sub L_Range neg moveto
				(Â°) strw neg 0 rmoveto
			} ifelse
			show_utf8										% Wert anzeigen
			(Â°) show_utf8									% Einheit anzeigen
		} ifelse
	} if

	% Cursor
	ixCursor1Warn { Yellow } if
	ixCursor1Err { Red } if
	
	3 setlinewidth
		
	L_showCursor {
		L_Xposition L_Yposition moveto
		idCursorForm1 1 eq { L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto L_size 2 mul 0 rlineto 0 L_size 2 mul neg rlineto L_size 2 mul neg 0 rlineto stroke } if
		idCursorForm1 2 eq { L_size neg 0 rmoveto L_size 2 mul 0 rlineto L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto stroke } if
		idCursorForm1 3 eq { L_Xposition L_size add L_Yposition moveto L_Xposition L_Yposition L_size 0 360 arc stroke } if
	} if

	1 setlinewidth
	setcolor
	% Rahmen zeichnen
	/L_Range L_Range 3 add store
	L_Range neg dup L_Range 2 mul dup rectstroke

	setmatrix
%?manual_end
	
} def
%?partend


%?partdef baTouchKbd001
%?fn	baTouchKbd001
%?brief	numerical keyboard used for positive integer numbers 0 ... xmax
%?bbox	0 0 239 319
/baTouchKbd001 {
	/idNumber	exch	def		%?brief value (actual content) 									%?use INP %?type DINT	%?dflt 0
	/idMaxNumber exch def		%?brief max. value (value is limited between 0 <= x <= xmax) 	%?use INP %?type DINT	%?dflt 999
	/qxEnter false def			%?brief key enter pressed 										%?use OUT %?type BOOL 	%?dflt false
	/qdNumber	0		def		%?brief value (new content) 									%?use OUT %?type DINT	%?dflt 0
%?manual_beg
	%check border low
	idNumber 0 lt {
		/idNumber 0 store
	} if
	%check border high
	qdNumber idMaxNumber le {
		/qdNumber idNumber store
	} { 
		/qdNumber idMaxNumber store
	} ifelse
	%temporary variables
	/L_helpS () def
	/LDnumIn -1 def
	%draw keyboard keys and handle mouse events
	currentcolor
	matrix currentmatrix
	0 0 translate
	baTouchButton001 { /LDnumIn 0 store } if
	setmatrix
	matrix currentmatrix
	0 80 translate
	baTouchButton001 { /LDnumIn 1 store } if
	setmatrix
	matrix currentmatrix
	80 80 translate
	baTouchButton001 { /LDnumIn 2 store } if
	setmatrix
	matrix currentmatrix
	160 80 translate
	baTouchButton001 { /LDnumIn 3 store } if
	setmatrix
	matrix currentmatrix
	0 160 translate
	baTouchButton001 { /LDnumIn 4 store } if
	setmatrix
	matrix currentmatrix
	80 160 translate
	baTouchButton001 { /LDnumIn 5 store } if
	setmatrix
	matrix currentmatrix
	160 160 translate
	baTouchButton001 { /LDnumIn 6 store } if
	setmatrix
	matrix currentmatrix 
	0 240 translate
	baTouchButton001 { /LDnumIn 7 store } if
	setmatrix
	matrix currentmatrix
	80 240 translate
	baTouchButton001 { /LDnumIn 8 store } if
	setmatrix
	matrix currentmatrix
	160 240 translate
	baTouchButton001 { /LDnumIn 9 store } if
	setmatrix
	setcolor
	% calculation of actual number (new number)
	LDnumIn 0 ge {
		/LD_tmp qdNumber 10 mul LDnumIn add def
		 LD_tmp idMaxNumber le {
			/qdNumber LD_tmp store
		} {
			/MXfailureBeep true store
		} ifelse
	} if
	% handle key BACKSPACE
	currentcolor
	matrix currentmatrix
	80 0 translate
	baTouchButton001 {
		/qdNumber qdNumber 10 div cvi store
	} if
	setmatrix
	setcolor
	% handle key ENTER
	currentcolor
	matrix currentmatrix
	160 0 translate
	baTouchButton001
 	/qxEnter exch store
	setmatrix
	setcolor
	% draw keyboard numbers
	BigFatFont
	120 40 moveto (â) sp_textCenterCenter
	200 40 moveto (â²) sp_textCenterCenter
	40 40 moveto (0) sp_textCenterCenter
	40 120 moveto (1) sp_textCenterCenter
	120 120 moveto (2) sp_textCenterCenter
	200 120 moveto (3) sp_textCenterCenter
	40 200 moveto (4) sp_textCenterCenter
	120 200 moveto (5) sp_textCenterCenter
	200 200 moveto (6) sp_textCenterCenter
	40 280 moveto (7) sp_textCenterCenter
	120 280 moveto (8) sp_textCenterCenter
	200 280 moveto (9) sp_textCenterCenter
	% store output values on stack
	qxEnter
	qdNumber
%?manual_end
} def
%?partend


%?partdef baTouchKbd002
%?fn	baTouchKbd002
%?brief	numerical keyboard used for positive real numbers 0.0 ... xmax (by Norbert Krimbacher)
%?bbox	0 0 319 319
/baTouchKbd002 {
	/MEM_Init	exch def		%?brief internal: store init 											%?use STATIC 	%?type BOOL %?dflt false
	/MEM_DecimalPoint exch def	%?brief internal: input decade position (1 --> first decimal place)	%?use STATIC 	%?type DINT %?dflt 0
	/MEM_Comma	exch def		%?brief comma pressed by the user										%?use STATIC	%?type BOOL %?dflt false
	/irNumber	exch	def		%?brief actual value													%?use INP	%?type REAL	%?dflt 0.0
	/irMinNumber exch def		%?brief min. value (value is limited by x >= xmin)						%?use INP	%?type REAL	%?dflt 0.0
	/irMaxNumber exch def		%?brief max. value (value is limited by x <= xmax)						%?use INP	%?type REAL	%?dflt 999.9
	/idMaxDecCount exch def		%?brief max. number of decimal places									%?use INP	%?type DINT	%?dflt 2
	/qxEnter false def			%?brief enter key pressed												%?use OUT 	%?type BOOL %?dflt false
	/qrNumber	0.0		def		%?brief modificated value												%?use OUT	%?type REAL	%?dflt 0.0
	/qsNumber () def			%?brief modificated value (as string)									%?use OUT	%?type STRI %?dflt (0.00)
%?manual_beg
	%check border low
	irNumber 0.0 lt {
		/irNumber 0.0 store
	} if
	%check border high
	qrNumber irMaxNumber le {
		/qrNumber irNumber store
	} { 
		/qrNumber irMaxNumber store
	} ifelse
	%check borders of numbers of decimal places
	/qxEnter false store
	idMaxDecCount 2 gt {
		/idMaxDecCount 2 store
	} if
	idMaxDecCount 0 lt {
		/idMaxDecCount 0 store
	} if
	%deactive comma selection if number of decimal points is zero
	idMaxDecCount 0 eq {
		/MEM_Comma false store
	} if
	%initial condition (analyse actual number)
	MEM_Init not {
		/MEM_Init true store

		%round number to max. count of digits
		/qrNumber qrNumber 100 mul cvi 100 div store

		qrNumber sp_getDeciPoint
		/MEM_DecimalPoint exch store
		MEM_DecimalPoint 0 eq { /MEM_Comma false store } { /MEM_Comma true store } ifelse
	} if
	%temporary variables
	/L_helpS () def
	/LDnumIn -1 def
	%draw keyboard keys and handle mouse events
	currentcolor
	matrix currentmatrix
	0 0 translate
	2 1 baTouchButton003 { /LDnumIn 0 store } if
	setmatrix
	matrix currentmatrix
	0 80 translate
	baTouchButton001 { /LDnumIn 1 store } if
	setmatrix
	matrix currentmatrix
	80 80 translate
	baTouchButton001 { /LDnumIn 2 store } if
	setmatrix
	idMaxDecCount 0 ne {
		matrix currentmatrix
		160 0 translate
		baTouchButton001 { /MEM_Comma true store } if
		setmatrix
	} if
	matrix currentmatrix
	160 80 translate
	baTouchButton001 { /LDnumIn 3 store } if
	setmatrix
	matrix currentmatrix
	0 160 translate
	baTouchButton001 { /LDnumIn 4 store } if
	setmatrix
	matrix currentmatrix
	80 160 translate
	baTouchButton001 { /LDnumIn 5 store } if
	setmatrix
	matrix currentmatrix
	160 160 translate
	baTouchButton001 { /LDnumIn 6 store } if
	setmatrix
	matrix currentmatrix 
	0 240 translate
	baTouchButton001 { /LDnumIn 7 store } if
	setmatrix
	matrix currentmatrix
	80 240 translate
	baTouchButton001 { /LDnumIn 8 store } if
	setmatrix
	matrix currentmatrix
	160 240 translate
	baTouchButton001 { /LDnumIn 9 store } if
	setmatrix
	setcolor
	%calculate new number
	/LD_number qrNumber cvi def
	/LD_fraction qrNumber LD_number sub 100 mul cvi def
	/LS_number () def
	/LS_fraction () def
	/LS_number LD_number LS_number 0 ncvs store
	/LS_fraction LD_fraction LS_fraction 2 0 nncvs store
	% handling of numerical key hit
	LDnumIn -1 ne {
		MEM_Comma {
			MEM_DecimalPoint 1 eq idMaxDecCount 1 gt and {
				/LD_fraction LD_fraction LDnumIn add store
				/LS_fraction LD_fraction LS_fraction 0 ncvs store
				/MEM_DecimalPoint 2 store
			} if
			MEM_DecimalPoint 0 eq idMaxDecCount 0 gt and {
				/LD_fraction LD_fraction LDnumIn 10 mul add store
				/LS_fraction LD_fraction LS_fraction 0 ncvs store
				/MEM_DecimalPoint 1 store
			} if
		} {
			LD_number 10 mul LDnumIn add irMaxNumber le {
				/LD_number LD_number 10 mul LDnumIn add store
				/LS_number LD_number LS_number 0 ncvs store
			} {
				/MXfailureBeep true store
			} ifelse
		} ifelse
	} if
	% handling of key hit BACKSPACE
	currentcolor
	matrix currentmatrix
	240 160 translate
	1 2 baTouchButton003 {
		MEM_Comma {
			MEM_DecimalPoint 0 eq {
				/MEM_Comma false store
			} if
			MEM_DecimalPoint 1 eq {
				/LD_fraction 0 store
				/LS_fraction () store
				/MEM_DecimalPoint 0 store
			} if
			MEM_DecimalPoint 2 eq {
				/LD_fraction LD_fraction 10 div cvi 10 mul store
				/LS_fraction LD_fraction LS_fraction 2 0 nncvs store
				/MEM_DecimalPoint 1 store
			} if
		} {
			/LD_number LD_number 10 div cvi store
		} ifelse
	} if
	setmatrix
	setcolor
	% handling of key ENTER
	currentcolor
	matrix currentmatrix
	240 0 translate
 	1 2 baTouchButton003 {
 		/qxEnter true store
		/MEM_Init false store
	} if
	setmatrix
	setcolor
	% calculation of output number
	/qrNumber LD_number LD_fraction 100 div add store
	% set output variables
	qxEnter {
		qrNumber irMinNumber lt {
			/qrNumber irMinNumber store
			qrNumber sp_getDeciPoint
			/MEM_DecimalPoint exch store
			MEM_DecimalPoint 0 eq { /MEM_Comma false store } { /MEM_Comma true store } ifelse
		} if
	} if
	% set output variable (string)
	/LD_number qrNumber cvi store
	/LD_fraction qrNumber LD_number sub 100 mul cvi store
	/qsNumber () store
	/LS_fraction () store
	/qsNumber LD_number qsNumber 0 ncvs store
	MEM_Comma {
		/qsNumber qsNumber (.) strcat store
		MEM_DecimalPoint 1 eq {
			/LS_fraction LD_fraction 10 div cvi LS_fraction 0 ncvs store
			/qsNumber qsNumber LS_fraction strcat store
		} if
		MEM_DecimalPoint 2 eq {
			/LS_fraction LD_fraction LS_fraction 2 0 nncvs store
			/qsNumber qsNumber LS_fraction strcat store
		} if
	} if
	% show keyboard symbols
	/xpos 40 def
	BigFatFont 
	xpos 40 moveto (0) sp_textCenterCenter
	xpos 120 moveto	(1) sp_textCenterCenter
	xpos 200 moveto	(4) sp_textCenterCenter
	xpos 280 moveto	(7) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 120 moveto	(2) sp_textCenterCenter
	xpos 200 moveto	(5) sp_textCenterCenter
	xpos 280 moveto	(8) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 40 moveto	(.) sp_textCenterCenter
	xpos 120 moveto	(3) sp_textCenterCenter
	xpos 200 moveto	(6) sp_textCenterCenter
	xpos 280 moveto	(9) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 240 moveto	(â) sp_textCenterCenter
	xpos 80 moveto (â²) sp_textCenterCenter
	% store values on stack
	qxEnter
	qrNumber
	qsNumber
	MEM_Init
	MEM_DecimalPoint
	MEM_Comma
%?manual_end
} def
%?partend

%?partdef baTouchKbd003
%?fn	baTouchKbd003
%?brief	numerical keyboard used for real numbers +/- 0.0 ... xmax (no storage internally)
%?bbox	0 0 239 399
/baTouchKbd003 {
	/MEM_Negative	exch def	%?brief number is negative											%?use STATIC	%?type BOOL %?dflt false
	/MEM_Comma		exch def	%?brief comma pressed by the user									%?use STATIC	%?type BOOL %?dflt false
	/MEM_DecimalPoint exch def	%?brief input decade position (1 --> first decimal place)			%?use STATIC 	%?type DINT %?dflt 0.0
	/irNumber		exch def	%?brief actual value												%?use INP		%?type REAL	%?dflt 0
	/irMinNumber	exch def	%?brief min. value (value is limited by x >= xmin)					%?use INP		%?type REAL	%?dflt -999.99
	/irMaxNumber	exch def	%?brief max. value (value is limited by x <= xmax)					%?use INP		%?type REAL	%?dflt 999.99
	/idMaxDecCount	exch def	%?brief max. number of decimal places								%?use INP		%?type DINT	%?dflt 2
	/ixInit			exch def	%?brief initialize keyboard (should be active for only one scan)	%?use INP		%?type BOOL	%?dflt false
	/qxEnter 	false	def		%?brief enter key pressed											%?use OUT 		%?type BOOL %?dflt false
	/qrNumber	0.0		def		%?brief modificated value real										%?use OUT		%?type REAL	%?dflt 0.0
	/qsNumber	()		def		%?brief modificated value (as string)								%?use OUT		%?type STRI %?dflt (0.00)
%?manual_beg
	/LS_help () def
	/LR_help 0 def
	/LD_numIn -1 def
	/LD_fraction 0 def
	/LD_number 0 def
	/LS_number () def

	% check borders of numbers of decimal places
	/qxEnter false store
	idMaxDecCount 2 gt { /idMaxDecCount 2 store } if
	idMaxDecCount 0 lt { /idMaxDecCount 0 store } if
	% deactive comma selection if number of decimal points is zero
	idMaxDecCount 0 eq { /MEM_Comma false store } if
	% initial condition (analyse actual number)
	ixInit {
		% remember init value for ESC Button				(nicht über statische gelöst, da dies nachträglich eingebaut wurde und die Schnittstelle nicht geändert werden soll)
		/LR_initNumTouKbd003 irNumber def
		% get informations
		irNumber 0 lt { /MEM_Negative true store } { /MEM_Negative false store } ifelse
		irNumber sp_getDeciPoint
		/MEM_DecimalPoint exch store
		MEM_DecimalPoint 0 eq { /MEM_Comma false store } { /MEM_Comma true store } ifelse
	} if
	% draw background
	matrix currentmatrix
	currentcolor
	Invisible
	0 0 translate
	1 1 238 398 rectfill
	setcolor
	setmatrix
	% draw keyboard keys and handle mouse events
	currentcolor
	matrix currentmatrix
	0 0 translate
	baTouchButton001 { /LD_numIn 0 store } if
	setmatrix
	matrix currentmatrix
	0 80 translate
	baTouchButton001 { /LD_numIn 1 store } if
	setmatrix
	matrix currentmatrix
	80 80 translate
	baTouchButton001 { /LD_numIn 2 store } if
	setmatrix
	matrix currentmatrix
	160 80 translate
	baTouchButton001 { /LD_numIn 3 store } if
	setmatrix
	matrix currentmatrix
	0 160 translate
	baTouchButton001 { /LD_numIn 4 store } if
	setmatrix
	matrix currentmatrix
	80 160 translate
	baTouchButton001 { /LD_numIn 5 store } if
	setmatrix
	matrix currentmatrix
	160 160 translate
	baTouchButton001 { /LD_numIn 6 store } if
	setmatrix
	matrix currentmatrix 
	0 240 translate
	baTouchButton001 { /LD_numIn 7 store } if
	setmatrix
	matrix currentmatrix
	80 240 translate
	baTouchButton001 { /LD_numIn 8 store } if
	setmatrix
	matrix currentmatrix
	160 240 translate
	baTouchButton001 { /LD_numIn 9 store } if
	setmatrix
	matrix currentmatrix
	80 0 translate
	baTouchButton001 { /MEM_Comma true store } if
	setmatrix
	setcolor
	% calculate new number
	/LD_number irNumber cvi store
	/LD_fraction irNumber LD_number sub 100 mul cvi store
	/LS_number () store
	/LS_number LD_number LS_number 0 ncvs store
	% handling of numerical key hit
	LD_numIn -1 ne {
		MEM_Comma {
			MEM_DecimalPoint 1 eq idMaxDecCount 1 gt and {
				MEM_Negative { 
					/LD_fraction LD_fraction LD_numIn sub store
				} {
					/LD_fraction LD_fraction LD_numIn add store
				} ifelse
				/MEM_DecimalPoint 2 store
			} if
			MEM_DecimalPoint 0 eq idMaxDecCount 0 gt and {
				MEM_Negative { 
					/LD_fraction LD_fraction LD_numIn 10 mul sub store
				} {
					/LD_fraction LD_fraction LD_numIn 10 mul add store
				} ifelse
				/MEM_DecimalPoint 1 store
			} if
		} {
			MEM_Negative { 
				LD_number 10 mul LD_numIn sub dup irMinNumber ge {
					/LD_number exch store
					/LS_number LD_number LS_number 0 ncvs store
				} {
					pop
					/MXfailureBeep true store
				} ifelse
			} {
				LD_number 10 mul LD_numIn add dup irMaxNumber le {
					/LD_number exch store
					/LS_number LD_number LS_number 0 ncvs store
				} {
					pop
					/MXfailureBeep true store
				} ifelse
			} ifelse
		} ifelse
	} if
	% handling of key hit PLUS/MINUS
	currentcolor
	matrix currentmatrix
	80 320 translate
	baTouchButton001
	irMinNumber 0 lt and {
		/LD_number LD_number neg store
		/LD_fraction LD_fraction neg store
		MEM_Negative { 
			/MEM_Negative false store
		} {
			/MEM_Negative true store
		} ifelse
	} if
	setmatrix
	setcolor
	% handling of key hit BACKSPACE
	currentcolor
	matrix currentmatrix
	160 320 translate
	baTouchButton001 {
		MEM_Comma {
			MEM_DecimalPoint 0 eq {
				/MEM_Comma false store
			} if
			MEM_DecimalPoint 1 eq {
				/LD_fraction 0 store
				/MEM_DecimalPoint 0 store
			} if
			MEM_DecimalPoint 2 eq {
				/LD_fraction LD_fraction 10 div cvi 10 mul store
				/MEM_DecimalPoint 1 store
			} if
		} {
			/LD_number LD_number 10 div cvi store
		} ifelse
	} if
	setmatrix
	setcolor

	% handling of key ENTER				(ACHTUNG: muss vor der Berechnung von qrNumber stehen)
	currentcolor
	matrix currentmatrix
	160 0 translate
	baTouchButton001 {
 		/qxEnter true store
	} if
	setmatrix
	setcolor

	% calculation of output number
	/qrNumber LD_number LD_fraction 100 div add store
	% set output variables
	qxEnter {
		qrNumber irMinNumber lt {
			/qrNumber irMinNumber store
			qrNumber sp_getDeciPoint
			/MEM_DecimalPoint exch store
			MEM_DecimalPoint 0 eq { /MEM_Comma false store } { /MEM_Comma true store } ifelse
		} if
		qrNumber irMaxNumber gt {
			/qrNumber irMaxNumber store
			qrNumber sp_getDeciPoint
			/MEM_DecimalPoint exch store
			MEM_DecimalPoint 0 eq { /MEM_Comma false store } { /MEM_Comma true store } ifelse
		} if
	} if

	% set output variable (string)
	/qsNumber () store
	MEM_Comma {
		MEM_DecimalPoint 0 eq {
			qrNumber 0 eq MEM_Negative and {
				/qsNumber (-0) store
			} {
				/qsNumber qrNumber qsNumber 0 ncvs store
			} ifelse
			/qsNumber qsNumber (.) strcat store
		} if
		MEM_DecimalPoint 1 eq {
			qrNumber 0 eq MEM_Negative and {
				/qsNumber (-0.0) store
			} {
				/qsNumber qrNumber qsNumber 1 ncvs store
			} ifelse
		} if
		MEM_DecimalPoint 2 eq {
			qrNumber 0 eq MEM_Negative and {
				/qsNumber (-0.00) store
			} {
				/qsNumber qrNumber qsNumber 2 ncvs store
			} ifelse
		} if
	} {
		qrNumber 0 eq MEM_Negative and { /qsNumber (-0) store }
		{ /qsNumber qrNumber qsNumber 0 ncvs store } ifelse
	} ifelse

	% handling of key ESC				(ACHTUNG: muss am Schluss stehen, nach der Berechnung von qrNumber)
	currentcolor
	matrix currentmatrix
	0 320 translate
	baTouchButton001 {
 		/qrNumber LR_initNumTouKbd003 store
 		/qxEnter true store
	} if
	setmatrix
	setcolor

	% show keyboard symbols
	/xpos 40 def
	BigFatFont 
	xpos 40 moveto (0) sp_textCenterCenter
	xpos 120 moveto	(1) sp_textCenterCenter
	xpos 200 moveto	(4) sp_textCenterCenter
	xpos 280 moveto	(7) sp_textCenterCenter
	xpos 360 moveto	(â) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 40 moveto	(.) sp_textCenterCenter
	xpos 120 moveto	(2) sp_textCenterCenter
	xpos 200 moveto	(5) sp_textCenterCenter
	xpos 280 moveto	(8) sp_textCenterCenter
	xpos 360 moveto	(+/-) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 40 moveto (â²) sp_textCenterCenter
	xpos 120 moveto	(3) sp_textCenterCenter
	xpos 200 moveto	(6) sp_textCenterCenter
	xpos 280 moveto	(9) sp_textCenterCenter
	xpos 360 moveto	(â) sp_textCenterCenter

	% store values on stack
	qxEnter
	qrNumber
	qsNumber
	MEM_Negative
	MEM_Comma
	MEM_DecimalPoint
%?manual_end
} def
%?partend

%?partdef baTouchKbd004
%?fn	baTouchKbd004
%?brief	numerical keyboard used for integer numbers +/- 0.0 ... xmax (no storage internally)
%?bbox	0 0 239 399
/baTouchKbd004 {
	/MEM_Negative_00 exch def	%?brief  %?use STATIC %?type BOOL
	/MEM_Comma_00 exch def	%?brief  %?use STATIC %?type BOOL
	/MEM_DecimalPoint_00 exch def	%?brief  %?use STATIC %?type DINT
	/idNumber	exch	def		%?brief actual value													%?use INP	%?type DINT	%?dflt 0
	/idMinNumber exch def		%?brief min. value (value is limited by x >= xmin)						%?use INP	%?type DINT	%?dflt -999
	/idMaxNumber exch def		%?brief max. value (value is limited by x <= xmax)						%?use INP	%?type DINT	%?dflt 999
	/ixInit			exch def	%?brief initialize keyboard (should be active for only one scan)	%?use INP		%?type BOOL	%?dflt false
	/qxEnter false def			%?brief enter key pressed												%?use OUT 	%?type BOOL %?dflt false
	/qdNumber	0		def		%?brief modificated value												%?use OUT	%?type DINT %?dflt 0
	/qsNumber () def			%?brief modificated value (as string)									%?use OUT	%?type STRI %?dflt (0)
%?manual_beg
	ixInit 0 idMaxNumber cvr idMinNumber cvr idNumber cvr
	MEM_DecimalPoint_00 MEM_Comma_00 MEM_Negative_00
	baTouchKbd003
	/MEM_DecimalPoint_00 exch store 
	/MEM_Comma_00 exch store 
	/MEM_Negative_00 exch store
	/qsNumber exch store 
	/qdNumber exch cvi store 
	/qxEnter exch store 
	qxEnter
	qdNumber
	qsNumber
	MEM_Negative_00
	MEM_Comma_00
	MEM_DecimalPoint_00
%?manual_end
} def
%?partend

%?partdef baTouchKbd005
%?fn	baTouchKbd005
%?brief	alphanumerical keyboard, numerical keypad
%?bbox	0 0 319 319
/baTouchKbd005 {
	/MEM_text	exch	def		%?brief actgual text						%?use STATIC	%?type STRI	%?dflt ()
	/MEM_edit	exch	def		%?brief edit mode activ						%?use STATIC	%?type BOOL	%?dflt false
	/isText		exch	def		%?brief initial text						%?use INP		%?type STRI	%?dflt ()
	/idMaxCharCount exch def	%?brief maximal count of characters  		%?use INP 		%?type DINT %?dflt 8
	/qxAlpha	false	def		%?brief alphanumerical keyboard key hit		%?use OUT		%?type BOOL	%?dflt false
	/qxEnter	false	def		%?brief ENTER key hit						%?use OUT		%?type BOOL	%?dflt false
	/qsString	()		def		%?brief inserted text						%?use OUT		%?type STRI	%?dflt ()
%?manual_beg
	/L_ActText (nos) def		%actual character
	/L_ActBckSpc false def		%backspace button pressed
	/L_ActPress false def		%button pressed
	%draw touch buttons and handle key hit
	currentcolor
	matrix currentmatrix 000 000 translate baTouchButton001 { /L_ActText (0) store } if setmatrix
	matrix currentmatrix 080 000 translate baTouchButton001 { /L_ActText (.) store } if setmatrix
	matrix currentmatrix 160 000 translate baTouchButton001 { /qxAlpha true store } if setmatrix
	matrix currentmatrix 240 000 translate 1 2 baTouchButton003 { /qxEnter true store } if setmatrix
	matrix currentmatrix 000 080 translate baTouchButton001 { /L_ActText (1) store } if setmatrix
	matrix currentmatrix 080 080 translate baTouchButton001 { /L_ActText (2) store } if setmatrix
	matrix currentmatrix 160 080 translate baTouchButton001 { /L_ActText (3) store } if setmatrix
	matrix currentmatrix 000 160 translate baTouchButton001 { /L_ActText (4) store } if setmatrix
	matrix currentmatrix 080 160 translate baTouchButton001 { /L_ActText (5) store } if setmatrix
	matrix currentmatrix 160 160 translate baTouchButton001 { /L_ActText (6) store } if setmatrix
	matrix currentmatrix 240 160 translate baTouchButton001 { /L_ActBckSpc true store } if setmatrix
	matrix currentmatrix 000 240 translate baTouchButton001 { /L_ActText (7) store } if setmatrix
	matrix currentmatrix 080 240 translate baTouchButton001 { /L_ActText (8) store } if setmatrix
	matrix currentmatrix 160 240 translate baTouchButton001 { /L_ActText (9) store } if setmatrix
	matrix currentmatrix 240 240 translate baTouchButton001 { /L_ActText (-) store } if setmatrix
	setcolor
	% limitate text to maximal count of characters
	MEM_text length idMaxCharCount ge { 
		/L_ActText (nos) store 
	} if
	% limitate text to maximal count of characters
	isText length idMaxCharCount gt { 
		isText length		 							% actual string length
		isText exch 1 sub strdelpos					% delete last character of string
		/isText exch store
	} if
	% check pressed button
	/L_ActPress L_ActText (nos) ne store
	% switch to edit-mode
	MEM_edit not {
		L_ActPress L_ActBckSpc or { /MEM_edit true store } if		
		/MEM_text isText store
	} if
	% draw symbols
	BigFatFont
	40 40 moveto  (0) sp_textCenterCenter
	120 40 moveto  (.) sp_textCenterCenter
	200 40 moveto  (â¨) sp_textCenterCenter
	280 80 moveto  (â²) sp_textCenterCenter
	40 120 moveto  (1) sp_textCenterCenter
	120 120 moveto  (2) sp_textCenterCenter
	200 120 moveto  (3) sp_textCenterCenter
	40 200 moveto  (4) sp_textCenterCenter
	120 200 moveto  (5) sp_textCenterCenter
	200 200 moveto  (6) sp_textCenterCenter
	280 200 moveto  (â) sp_textCenterCenter
	40 280 moveto  (7) sp_textCenterCenter
	120 280 moveto  (8) sp_textCenterCenter
	200 280 moveto  (9) sp_textCenterCenter
	280 280 moveto  (-) sp_textCenterCenter
	% evaluation of touch
	MEM_edit {
		L_ActBckSpc MEM_text length 0 gt and {
			MEM_text length		 							% actual string length
			MEM_text exch 1 sub strdelpos					% delete last character of string
			/MEM_text exch store
		} if
		L_ActPress {
			MEM_text L_ActText strcat						% extend string with actual character
			/MEM_text exch store
		} if
	} if
	qxEnter {
		/MEM_edit false store
	} if
	/qsString MEM_text store
%?manual_end
	qxAlpha
	qxEnter
	qsString
	MEM_text
	MEM_edit
} def
%?partend

% alphanumerical keyboard; keyboard layout AT
%!proc sp_kbdGraphic
%?subproc
/sp_kbdGraphic {
	/MEM_shift exch def %?brief Shift button pressed %?use STATIC %?type BOOL %?dflt false
	/MEM_ActEsc exch def %?brief ESC button pressed %?use STATIC %?type BOOL %?dflt false
	/MEM_ActBckSpc exch def %?brief BackSpace button pressed %?use STATIC %?type BOOL %?dflt false
	/MEM_ActEnter exch def %?brief ENTER button pressed %?use STATIC %?type BOOL %?dflt false
	/MEM_ActText exch def %?brief key button %?use STATIC %?type STRI %?dflt ()
	/ixExtended	exch def	%?brief extended keyboard	%?use INP		%?type BOOL	%?dflt false
%?manual_beg
	ixExtended {
		matrix currentmatrix
		currentcolor
		000 400 translate baTouchButton001 { /MEM_ActEsc true store } if
		setcolor
		BigFatFont
		40 40 moveto (â) sp_textCenterCenter
		0 0 moveto
		setmatrix
	} if
	MEM_shift not {
		currentcolor
		matrix currentmatrix 720 400 translate baTouchButton001 { /MEM_ActBckSpc true store } if setmatrix
		matrix currentmatrix 720 320 translate baTouchButton001 { /MEM_ActText (0) store } if setmatrix
		matrix currentmatrix 640 320 translate baTouchButton001 { /MEM_ActText (9) store } if setmatrix
		matrix currentmatrix 560 320 translate baTouchButton001 { /MEM_ActText (8) store } if setmatrix
		matrix currentmatrix 480 320 translate baTouchButton001 { /MEM_ActText (7) store } if setmatrix
		matrix currentmatrix 400 320 translate baTouchButton001 { /MEM_ActText (6) store } if setmatrix
		matrix currentmatrix 320 320 translate baTouchButton001 { /MEM_ActText (5) store } if setmatrix
		matrix currentmatrix 240 320 translate baTouchButton001 { /MEM_ActText (4) store } if setmatrix
		matrix currentmatrix 160 320 translate baTouchButton001 { /MEM_ActText (3) store } if setmatrix
		matrix currentmatrix 080 320 translate baTouchButton001 { /MEM_ActText (2) store } if setmatrix
		matrix currentmatrix 000 320 translate baTouchButton001 { /MEM_ActText (1) store } if setmatrix
		matrix currentmatrix 720 240 translate baTouchButton001 { /MEM_ActText (p) store } if setmatrix
		matrix currentmatrix 640 240 translate baTouchButton001 { /MEM_ActText (o) store } if setmatrix
		matrix currentmatrix 560 240 translate baTouchButton001 { /MEM_ActText (i) store } if setmatrix
		matrix currentmatrix 480 240 translate baTouchButton001 { /MEM_ActText (u) store } if setmatrix
		matrix currentmatrix 400 240 translate baTouchButton001 { /MEM_ActText (z) store } if setmatrix
		matrix currentmatrix 320 240 translate baTouchButton001 { /MEM_ActText (t) store } if setmatrix
		matrix currentmatrix 240 240 translate baTouchButton001 { /MEM_ActText (r) store } if setmatrix
		matrix currentmatrix 160 240 translate baTouchButton001 { /MEM_ActText (e) store } if setmatrix
		matrix currentmatrix 080 240 translate baTouchButton001 { /MEM_ActText (w) store } if setmatrix
		matrix currentmatrix 000 240 translate baTouchButton001 { /MEM_ActText (q) store } if setmatrix
		matrix currentmatrix 680 160 translate baTouchButton001 { /MEM_ActText (l) store } if setmatrix
		matrix currentmatrix 600 160 translate baTouchButton001 { /MEM_ActText (k) store } if setmatrix
		matrix currentmatrix 520 160 translate baTouchButton001 { /MEM_ActText (j) store } if setmatrix
		matrix currentmatrix 440 160 translate baTouchButton001 { /MEM_ActText (h) store } if setmatrix
		matrix currentmatrix 360 160 translate baTouchButton001 { /MEM_ActText (g) store } if setmatrix
		matrix currentmatrix 280 160 translate baTouchButton001 { /MEM_ActText (f) store } if setmatrix
		matrix currentmatrix 200 160 translate baTouchButton001 { /MEM_ActText (d) store } if setmatrix
		matrix currentmatrix 120 160 translate baTouchButton001 { /MEM_ActText (s) store } if setmatrix
		matrix currentmatrix 040 160 translate baTouchButton001 { /MEM_ActText (a) store } if setmatrix
		matrix currentmatrix 720 080 translate sp_touchButtonEnter { /MEM_ActEnter true store } if setmatrix
		matrix currentmatrix 640 080 translate baTouchButton001 { /MEM_ActText (,) store } if setmatrix
		matrix currentmatrix 560 080 translate baTouchButton001 { /MEM_ActText (m) store } if setmatrix
		matrix currentmatrix 480 080 translate baTouchButton001 { /MEM_ActText (n) store } if setmatrix
		matrix currentmatrix 400 080 translate baTouchButton001 { /MEM_ActText (b) store } if setmatrix
		matrix currentmatrix 320 080 translate baTouchButton001 { /MEM_ActText (v) store } if setmatrix
		matrix currentmatrix 240 080 translate baTouchButton001 { /MEM_ActText (c) store } if setmatrix
		matrix currentmatrix 160 080 translate baTouchButton001 { /MEM_ActText (x) store } if setmatrix
		matrix currentmatrix 080 080 translate baTouchButton001 { /MEM_ActText (y) store } if setmatrix
		matrix currentmatrix 000 080 translate false sp_touchButtonShift { /MEM_shift true store } if setmatrix
		matrix currentmatrix 720 000 translate baTouchButton001 { /MEM_ActText (+) store } if setmatrix
		matrix currentmatrix 640 000 translate baTouchButton001 { /MEM_ActText (#) store } if setmatrix
		matrix currentmatrix 560 000 translate baTouchButton001 { /MEM_ActText (-) store } if setmatrix
		matrix currentmatrix 480 000 translate baTouchButton001 { /MEM_ActText (.) store } if setmatrix
		matrix currentmatrix 240 000 translate 3 1 baTouchButton003 { /MEM_ActText ( ) store } if setmatrix
		matrix currentmatrix 160 000 translate baTouchButton001 { /MEM_ActText (\\) store } if setmatrix
		matrix currentmatrix 080 000 translate baTouchButton001 { /MEM_ActText (^) store } if setmatrix
		matrix currentmatrix 000 000 translate baTouchButton001 { /MEM_ActText (<) store } if setmatrix
		setcolor
		BigFatFont
		20 40 moveto   (<) sp_textLeftCenter
		120 40 moveto  (^) sp_textCenterCenter
		180 40 moveto  (\\) sp_textLeftCenter
		510 40 moveto  (.) sp_textLeftCenter
		600 40 moveto  (-) sp_textCenterCenter
		670 40 moveto  (#) sp_textCenterCenter
		750 40 moveto  (+) sp_textCenterCenter
		40 120 moveto (â§) sp_textCenterCenter
		120 120 moveto (y) sp_textCenterCenter
		200 120 moveto (x) sp_textCenterCenter
		280 120 moveto (c) sp_textCenterCenter
		360 120 moveto (v) sp_textCenterCenter
		440 120 moveto (b) sp_textCenterCenter
		520 120 moveto (n) sp_textCenterCenter
		600 120 moveto (m) sp_textCenterCenter
		670 120 moveto (,) sp_textLeftCenter
		760 120 moveto (â²) sp_textCenterCenter
		80 200 moveto (a) sp_textCenterCenter
		160 200 moveto (s) sp_textCenterCenter
		240 200 moveto (d) sp_textCenterCenter
		320 200 moveto (f) sp_textCenterCenter
		400 200 moveto (g) sp_textCenterCenter
		480 200 moveto (h) sp_textCenterCenter
		560 200 moveto (j) sp_textCenterCenter
		640 200 moveto (k) sp_textCenterCenter
		720 200 moveto (l) sp_textCenterCenter
		40 280 moveto (q) sp_textCenterCenter
		120 280 moveto (w) sp_textCenterCenter
		200 280 moveto (e) sp_textCenterCenter
		280 280 moveto (r) sp_textCenterCenter
		360 280 moveto (t) sp_textCenterCenter
		440 280 moveto (z) sp_textCenterCenter
		520 280 moveto (u) sp_textCenterCenter
		600 280 moveto (i) sp_textCenterCenter
		680 280 moveto (o) sp_textCenterCenter
		760 280 moveto (p) sp_textCenterCenter
		30 360 moveto (1) sp_textCenterCenter
		110 360 moveto (2) sp_textCenterCenter
		185 360 moveto (3) sp_textCenterCenter
		265 360 moveto (4) sp_textCenterCenter
		345 360 moveto (5) sp_textCenterCenter
		425 360 moveto (6) sp_textCenterCenter
		510 360 moveto (7) sp_textCenterCenter
		590 360 moveto (8) sp_textCenterCenter
		670 360 moveto (9) sp_textCenterCenter
		745 360 moveto (0) sp_textCenterCenter
		760 440 moveto (â) sp_textCenterCenter
		MidFont
		50 40 moveto   (>) sp_textLeftCenter
		200 40 moveto  (?) sp_textLeftCenter
		530 40 moveto  (:) sp_textLeftCenter
		600 40 moveto  (_) sp_textCenterCenter
		690 40 moveto  (') sp_textCenterCenter
		770 40 moveto  (*) sp_textCenterCenter
		690 120 moveto (;) sp_textLeftCenter
		50 360 moveto (!) sp_textCenterCenter
		140 360 moveto (") sp_textCenterCenter
		215 360 moveto (~) sp_textCenterCenter
		295 360 moveto ($) sp_textCenterCenter
		375 360 moveto (%) sp_textCenterCenter
		455 360 moveto (&) sp_textCenterCenter
		535 360 moveto (/) sp_textCenterCenter
		620 360 moveto (\() sp_textCenterCenter
		700 360 moveto (\)) sp_textCenterCenter
		775 360 moveto (=) sp_textCenterCenter
	} {
		currentcolor
		matrix currentmatrix 720 400 translate baTouchButton001 { /MEM_ActBckSpc true store } if setmatrix
		matrix currentmatrix 720 320 translate baTouchButton001 { /MEM_ActText (=) store } if setmatrix
		matrix currentmatrix 640 320 translate baTouchButton001 { /MEM_ActText (\)) store } if setmatrix
		matrix currentmatrix 560 320 translate baTouchButton001 { /MEM_ActText (\() store } if setmatrix
		matrix currentmatrix 480 320 translate baTouchButton001 { /MEM_ActText (/) store } if setmatrix
		matrix currentmatrix 400 320 translate baTouchButton001 { /MEM_ActText (&) store } if setmatrix
		matrix currentmatrix 320 320 translate baTouchButton001 { /MEM_ActText (%) store } if setmatrix
		matrix currentmatrix 240 320 translate baTouchButton001 { /MEM_ActText ($) store } if setmatrix
		matrix currentmatrix 160 320 translate baTouchButton001 { /MEM_ActText (~) store } if setmatrix
		matrix currentmatrix 080 320 translate baTouchButton001 { /MEM_ActText (") store } if setmatrix
		matrix currentmatrix 000 320 translate baTouchButton001 { /MEM_ActText (!) store } if setmatrix
		matrix currentmatrix 720 240 translate baTouchButton001 { /MEM_ActText (P) store } if setmatrix
		matrix currentmatrix 640 240 translate baTouchButton001 { /MEM_ActText (O) store } if setmatrix
		matrix currentmatrix 560 240 translate baTouchButton001 { /MEM_ActText (I) store } if setmatrix
		matrix currentmatrix 480 240 translate baTouchButton001 { /MEM_ActText (U) store } if setmatrix
		matrix currentmatrix 400 240 translate baTouchButton001 { /MEM_ActText (Z) store } if setmatrix
		matrix currentmatrix 320 240 translate baTouchButton001 { /MEM_ActText (T) store } if setmatrix
		matrix currentmatrix 240 240 translate baTouchButton001 { /MEM_ActText (R) store } if setmatrix
		matrix currentmatrix 160 240 translate baTouchButton001 { /MEM_ActText (E) store } if setmatrix
		matrix currentmatrix 080 240 translate baTouchButton001 { /MEM_ActText (W) store } if setmatrix
		matrix currentmatrix 000 240 translate baTouchButton001 { /MEM_ActText (Q) store } if setmatrix
		matrix currentmatrix 680 160 translate baTouchButton001 { /MEM_ActText (L) store } if setmatrix
		matrix currentmatrix 600 160 translate baTouchButton001 { /MEM_ActText (K) store } if setmatrix
		matrix currentmatrix 520 160 translate baTouchButton001 { /MEM_ActText (J) store } if setmatrix
		matrix currentmatrix 440 160 translate baTouchButton001 { /MEM_ActText (H) store } if setmatrix
		matrix currentmatrix 360 160 translate baTouchButton001 { /MEM_ActText (G) store } if setmatrix
		matrix currentmatrix 280 160 translate baTouchButton001 { /MEM_ActText (F) store } if setmatrix
		matrix currentmatrix 200 160 translate baTouchButton001 { /MEM_ActText (D) store } if setmatrix
		matrix currentmatrix 120 160 translate baTouchButton001 { /MEM_ActText (S) store } if setmatrix
		matrix currentmatrix 040 160 translate baTouchButton001 { /MEM_ActText (A) store } if setmatrix
		matrix currentmatrix 720 080 translate sp_touchButtonEnter { /MEM_ActEnter true store } if setmatrix
		matrix currentmatrix 640 080 translate baTouchButton001 { /MEM_ActText (;) store } if setmatrix
		matrix currentmatrix 560 080 translate baTouchButton001 { /MEM_ActText (M) store } if setmatrix
		matrix currentmatrix 480 080 translate baTouchButton001 { /MEM_ActText (N) store } if setmatrix
		matrix currentmatrix 400 080 translate baTouchButton001 { /MEM_ActText (B) store } if setmatrix
		matrix currentmatrix 320 080 translate baTouchButton001 { /MEM_ActText (V) store } if setmatrix
		matrix currentmatrix 240 080 translate baTouchButton001 { /MEM_ActText (C) store } if setmatrix
		matrix currentmatrix 160 080 translate baTouchButton001 { /MEM_ActText (X) store } if setmatrix
		matrix currentmatrix 080 080 translate baTouchButton001 { /MEM_ActText (Y) store } if setmatrix
		matrix currentmatrix 000 080 translate true sp_touchButtonShift { /MEM_shift false store } if setmatrix
		matrix currentmatrix 720 000 translate baTouchButton001 { /MEM_ActText (*) store } if setmatrix
		matrix currentmatrix 640 000 translate baTouchButton001 { /MEM_ActText (') store } if setmatrix
		matrix currentmatrix 560 000 translate baTouchButton001 { /MEM_ActText (_) store } if setmatrix
		matrix currentmatrix 480 000 translate baTouchButton001 { /MEM_ActText (:) store } if setmatrix
		matrix currentmatrix 240 000 translate 3 1 baTouchButton003 { /MEM_ActText ( ) store } if setmatrix
		matrix currentmatrix 160 000 translate baTouchButton001 { /MEM_ActText (?) store } if setmatrix
		matrix currentmatrix 080 000 translate baTouchButton001 { /MEM_ActText (^) store } if setmatrix
		matrix currentmatrix 000 000 translate baTouchButton001 { /MEM_ActText (>) store } if setmatrix
		setcolor
		BigFatFont
		50 40 moveto   (>) sp_textLeftCenter
		120 40 moveto  (^) sp_textCenterCenter
		200 40 moveto  (?) sp_textLeftCenter
		530 40 moveto  (:) sp_textLeftCenter
		600 40 moveto  (_) sp_textCenterCenter
		690 40 moveto  (') sp_textCenterCenter
		770 40 moveto  (*) sp_textCenterCenter
		40 120 moveto (âª) sp_textCenterCenter	%â§
		120 120 moveto (Y) sp_textCenterCenter
		200 120 moveto (X) sp_textCenterCenter
		280 120 moveto (C) sp_textCenterCenter
		360 120 moveto (V) sp_textCenterCenter
		440 120 moveto (B) sp_textCenterCenter
		520 120 moveto (N) sp_textCenterCenter
		600 120 moveto (M) sp_textCenterCenter
		690 120 moveto (;) sp_textLeftCenter
		760 120 moveto (â²) sp_textCenterCenter
		80 200 moveto (A) sp_textCenterCenter
		160 200 moveto (S) sp_textCenterCenter
		240 200 moveto (D) sp_textCenterCenter
		320 200 moveto (F) sp_textCenterCenter
		400 200 moveto (G) sp_textCenterCenter
		480 200 moveto (H) sp_textCenterCenter
		560 200 moveto (J) sp_textCenterCenter
		640 200 moveto (K) sp_textCenterCenter
		720 200 moveto (L) sp_textCenterCenter
		40 280 moveto (Q) sp_textCenterCenter
		120 280 moveto (W) sp_textCenterCenter
		200 280 moveto (E) sp_textCenterCenter
		280 280 moveto (R) sp_textCenterCenter
		360 280 moveto (T) sp_textCenterCenter
		440 280 moveto (Z) sp_textCenterCenter
		520 280 moveto (U) sp_textCenterCenter
		600 280 moveto (I) sp_textCenterCenter
		680 280 moveto (O) sp_textCenterCenter
		760 280 moveto (P) sp_textCenterCenter
		50 360 moveto (!) sp_textCenterCenter
		140 360 moveto (") sp_textCenterCenter
		215 360 moveto (~) sp_textCenterCenter
		295 360 moveto ($) sp_textCenterCenter
		375 360 moveto (%) sp_textCenterCenter
		455 360 moveto (&) sp_textCenterCenter
		535 360 moveto (/) sp_textCenterCenter
		620 360 moveto (\() sp_textCenterCenter
		700 360 moveto (\)) sp_textCenterCenter
		775 360 moveto (=) sp_textCenterCenter
		760 440 moveto (â) sp_textCenterCenter
		MidFont
		20 40 moveto   (<) sp_textLeftCenter
		180 40 moveto  (\\) sp_textLeftCenter
		510 40 moveto  (.) sp_textLeftCenter
		600 40 moveto  (-) sp_textCenterCenter
		670 40 moveto  (#) sp_textCenterCenter
		750 40 moveto  (+) sp_textCenterCenter
		670 120 moveto (,) sp_textLeftCenter
		30 360 moveto (1) sp_textCenterCenter
		110 360 moveto (2) sp_textCenterCenter
		185 360 moveto (3) sp_textCenterCenter
		265 360 moveto (4) sp_textCenterCenter
		345 360 moveto (5) sp_textCenterCenter
		425 360 moveto (6) sp_textCenterCenter
		510 360 moveto (7) sp_textCenterCenter
		590 360 moveto (8) sp_textCenterCenter
		670 360 moveto (9) sp_textCenterCenter
		745 360 moveto (0) sp_textCenterCenter
	} ifelse
	MEM_shift
	MEM_ActEsc
	MEM_ActBckSpc
	MEM_ActEnter
	MEM_ActText
%?manual_end
} def

%?partdef baTouchKbd101
%?fn	baTouchKbd101
%?brief	alphanumerical keyboard; keyboard layout AT, GER (no storage internally)
%?bbox	0 0 799 479
/baTouchKbd101 {
	/MEM_text	exch	def		%?brief aktueller Text					%?use STATIC	%?type STRI	%?dflt ()
	/MEM_shift	exch	def		%?brief Shift button pressed			%?use STATIC	%?type BOOL	%?dflt false
	/MEM_edit	exch	def		%?brief edit-Mode activ					%?use STATIC	%?type BOOL	%?dflt false
	/isCaption	exch	def		%?brief beschreibender Text				%?use INP		%?type STRI	%?dflt ()
	/isInitText	exch	def		%?brief vorhandener Text				%?use INP		%?type STRI	%?dflt ()
	/idMaxCharCount exch def	%?brief maximale Anzahl an Stellen  	%?use INP 		%?type DINT %?dflt 20
	/qxEnter	false	def		%?brief key hit ENTER					%?use OUT		%?type BOOL	%?dflt false
	/qsString	()		def		%?brief eingegebener Text				%?use OUT		%?type STRI	%?dflt ()
%?manual_beg
	/L_ActText (nos) def		%actual character
	/L_ActBckSpc false def		%backspace button pressed
	/L_ActEsc false def			% ESC button pressed
	/qxEnter false def			%enter button pressed
	% limitate text to maximal count of characters
	isInitText length idMaxCharCount gt { 
		isInitText length		 						% actual string length
		isInitText exch 1 sub strdelpos					% delete last character of string
		/isInitText exch store
	} if
	%draw keyboard and analyse key hit
	false L_ActText qxEnter L_ActBckSpc L_ActEsc MEM_shift sp_kbdGraphic 
	/L_ActText exch store
	/qxEnter exch store
	/L_ActBckSpc exch store
	/L_ActEsc exch store
	/MEM_shift exch store
	%check pressed button
	/L_ActPress false def		%button pressed
	/L_ActPress L_ActText (nos) ne store
	%disable shift after pressing one button (no locking shift key)
	% L_ActPress MEM_shift and { /MEM_shift false store } if
	% evaluation of touch events
	MEM_edit not { 
		L_ActPress L_ActBckSpc or { /MEM_edit true store } if		
		/MEM_text isInitText store
	} if
	MEM_edit {
		L_ActBckSpc MEM_text length 0 gt and {
			MEM_text length		 							% actual string length
			MEM_text exch 1 sub strdelpos					% delete last character of string
			/MEM_text exch store
		} if
		L_ActPress MEM_text length idMaxCharCount lt and {
			MEM_text L_ActText strcat						% extend string with actual character
			/MEM_text exch store
		} if
	} if
	% set outputs
	/qsString MEM_text store
	% store values on stack
	qxEnter
	qsString
	MEM_text
	MEM_shift
	MEM_edit
%?manual_end
} def
%?partend

%?partdef baTouchKbd102
%?fn	baTouchKbd102
%?brief	alphanumerical keyboard with ESC; keyboard layout AT, GER (no storage internally)
%?bbox	0 0 799 479
/baTouchKbd102 {
	/MEM_text exch def	%?brief aktueller Text %?use STATIC %?type STRI
	/MEM_shift_act exch def	%?brief Shift button pressed %?use STATIC %?type BOOL
	/MEM_edit exch def	%?brief edit-Mode activ %?use STATIC %?type BOOL
	/isCaption exch def	%?brief beschreibender Text %?use INP %?type STRI %?dflt 
	/isInitText exch def	%?brief vorhandener Text %?use INP %?type STRI %?dflt 
	/idMaxCharCount exch def	%?brief maximale Anzahl an Stellen (zusätzlich zur Begrenzung durch die maximale Breite der Eingabezeile) %?use INP %?type DINT %?dflt 50
	/qxEnter false def	%?brief key hit ENTER %?use OUT %?type BOOL %?dflt false
	/qsString () def	%?brief eingegebener Text %?use OUT %?type STRI %?dflt 
%?manual_beg
	/L_ActText (nos) def		% actual character
	/L_ActBckSpc false def		% backspace button pressed
	/L_ActEsc false def			% ESC button pressed
	/qxEnter false def			% enter button pressed
	
	% limitate text to maximal count of characters or maximum space for string
	BigFatFont
	{
		isInitText length idMaxCharCount le isInitText strw 600 le and { exit } if
		isInitText length		 						% actual string length
		isInitText exch 1 sub strdelpos					% delete last character of string
		/isInitText exch store
	} loop
	
	% draw keyboard and analyse key hit
	true L_ActText qxEnter L_ActBckSpc L_ActEsc MEM_shift_act
	sp_kbdGraphic 
	/L_ActText exch store
	/qxEnter exch store
	/L_ActBckSpc exch store
	/L_ActEsc exch store
	/MEM_shift_act exch store
	
	% check pressed button
	/L_ActPress false def		%button pressed
	/L_ActPress L_ActText (nos) ne store
	% disable shift after pressing one button (no locking shift key)
	% L_ActPress MEM_shift_act and { /MEM_shift_act false store } if
	
	% evaluation of touch events
	MEM_edit not { 
		L_ActPress L_ActBckSpc or { /MEM_edit true store } if		
		/MEM_text isInitText store
	} if
	MEM_edit {
		L_ActBckSpc MEM_text length 0 gt and {				% Backspace
			MEM_text length		 							% actual string length
			MEM_text exch 1 sub strdelpos					% delete last character of string
			/MEM_text exch store
		} if
		BigFatFont
		L_ActPress MEM_text length idMaxCharCount lt and {	% Zeichen anfügen
			MEM_text L_ActText strcat						% extend string with actual character
			/MEM_text exch store
		} if
	} if
	% set outputs
	L_ActEsc {
		/qxEnter true store
		/MEM_text isInitText store
	} if
	qxEnter {
		/MEM_edit false store
	} if

	% limitate text to maximal count of characters or maximum space for string
	BigFatFont
	{
		MEM_text length idMaxCharCount le MEM_text strw 600 le and { exit } if
		MEM_text length		 						% actual string length
		MEM_text exch 1 sub strdelpos					% delete last character of string
		/MEM_text exch store
	} loop

	/qsString MEM_text store
	% store values on stack
	qxEnter
	qsString
	MEM_text
	MEM_shift_act
	MEM_edit
%?manual_end
	
} def
%?partend

%?partdef baInpAreaKbd001
%?fn	baInpAreaKbd001
%?brief	numerical keyboard with real values for interaction with input areas
%?bbox	0 0 239 399
/baInpAreaKbd001 {
	/MEM_DecimalPoint_00 exch def	%?brief  %?use STATIC %?type DINT
	/MEM_Comma_00 exch def	%?brief  %?use STATIC %?type BOOL
	/MEM_Negative_00 exch def	%?brief  %?use STATIC %?type BOOL
%?manual_beg
	/LI_leftDigits	0	def
	/LI_leftLength 	0	def
	/LI_rightDigits	0	def

% Beschreibung:
% Diese numerische Tastatur wird in Zusammenhang mit Eingabefeldern (input area) verwendet.
% Das Grundprinzip der Input Area kann beim Part "baInpArea001" nachgelesen werden.
% Das Keyboard kann generell auf einer Seite mit InputAreas abgesetzt werden, oder es kann auf dieser Seite auch erst zur Anzeige gebracht werden,
% wenn eine InputArea aktiviert ist. (Hierzu müsste die Sichbarkeit mit der Variablen "MXiaActivated" verknüpft werden. Diese wird im Part GeneralFunction
% gesetzt (Dieses Part muß auf der page0 aufgerufen werden).
% Das Keyboard liest nun die globale Variable mit dem zu ändernden Wert. Der aktuell geänderte Wert wird über die Var MRiaActChaVal gespeichert.
% Zusätzlich wird der aktuell verstellte Wert in einer globalen Variable als STRING gespeichert.
% Grund: Wenn bei einer Kommazahl z.B. 3.2 die Taste Backspace gedrückt wird,
% so soll in der Anzeige 3. stehen und nicht nur 3 - Ausserdem muß die Information, daß das Komma aktiviert wurde ebenfalls gespeichert werden.
% Bei einem weiteren Drücken der Backspace Taste muß nämlich dieses aufgehoben werden.
% Wird die Taste ENTER gedrückt, so wird die InputArea deaktiviert und der veränderte Wert wird übernommen.

	% Anzuzeigende Stellen ermitteln
	MRiaActChaVal MRiaActDeciNumb
	sp_getDigitInfo
	/LI_leftLength exch store
	/LI_leftDigits exch store
	/LI_rightDigits exch store

	% Keyboard aufrufen
	matrix currentmatrix_nlw 
	currentcolor 
	MXiaInitKeyboard LI_rightDigits MRiaActMaxVal MRiaActMinVal MRiaActChaVal
	MEM_DecimalPoint_00 MEM_Comma_00 MEM_Negative_00
	baTouchKbd003 
	/MEM_DecimalPoint_00 exch store 
	/MEM_Comma_00 exch store 
	/MEM_Negative_00 exch store 
	/MSiaActChaVal exch store
	/MRiaActChaVal exch store 
	/MXiaKeybEnter exch store
	setcolor 
	setmatrix_nlw 
	
	/MXiaInitKeyboard false store
	/MDiaActDeciPoint MEM_DecimalPoint_00 store
	
%?manual_end
	MEM_DecimalPoint_00
	MEM_Comma_00
	MEM_Negative_00
} def
%?partend


%?partdef baInpArea001
%?fn	baInpArea001
%?brief	input area with real values, accepts new value after deactivation with ENTER (will be activated by touch and can be adjusted by input Area Keyboard or InputAreaIncreaseDrecrease)
%?bbox	0 0 79 39
/baInpArea001 {
	/MEM_Index	exch	def		%?brief actual value										%?use STATIC %?type DINT
	/idFontSelection  exch 	def	%?brief font	 											%?use INP %?type DINT %?dflt FSstdFont
	/irMaxNumber exch def		%?brief max. value (value is limited by x <= xmax)			%?use INP	%?type REAL	%?dflt 999.9
	/irMinNumber exch def		%?brief min. value (value is limited by x >= xmin)			%?use INP	%?type REAL	%?dflt 0.0
	/irDeciNumb exch def		%?brief Code der angezeigten Stellen z.B. 2.1				%?use INP	%?type REAL %?dflt 2.1
	/irNumber	exch	def		%?brief actual value										%?use INP	%?type REAL	%?dflt 0.0
	/qrNumber	0.0		def		%?brief modificated value									%?use OUT	%?type REAL	%?dflt 0.0
%?manual_beg

% Beschreibung Eingabefeld:
% Das Eingabefeld wird durch touch darauf aktiviert. Der Zahlenwert kann nun durch andere Parts, beispielsweise über "baInpAreaKbd001" verändert werden.
% Es gibt globale Variablen die in der llsystem definiert sind. Jede InputArea die in einem Projekt aufgerufen wird, muß beim ersten
% Durchlauf des Codes, also bei Ihrem ersten Aufruf initialisiert werden. Jede InputArea erhöht dabei den Globalen Indexzähler (MDiaIndexCounter)
% und merkt sich selbst über eine statische Variable den ihr zugeordnete Index (MEM_Index). Wenn der index der aktuell aufgerufenen InputArea Null ist,
% muß sie initialisiert werden.
% Wird die InputArea durch betätigen des TouchValue aktiviert, so wird der aktuelle globale InputArea index (der besagt, welche InputArea
% gerade aktiv ist) auf den index dieser InputArea gesetzt. (Die Globalen Variablen werden wiederum von anderen InputArea Parts
% wie z.B. "baInpAreaKbd001" ver- und bearbeitet) Gleichzeitig werden auch die Init-Variablen gesetzt. Solange die InputArea nicht aktiv ist,
% kann der Zahlenwert durch andere InputArea-Parts verändert werden. Da der Wert über Eingang eingelesen und am Ausgang wieder übergeben wird,
% kann der Wert auch von der Steuerung verändert werden. Solange die InputArea aktiv ist wird jedoch nur der aktuell zu ändernde Wert angezeigt.
% Ist die InputArea aktiv so liest sie nun in jedem Druchlauf den Wert aus der Variablen "MSiaActChaVal" und bringt ihn über ein
% Part "TouchString" zur Anzeige. Diese globale Variable wird von anderen InputArea Parts beschrieben. (der Grund weshalb hier
% eine STRING Variabel verwendet wird kann im Part "baInpAreaKbd001" nachgelesen werden) Während der Verstellung kommt der aktuell veränderte Wert
% also nur zur Anzeige. Übernommen auf den Zahlenwert-Ausgang der InputArea (also z.B. für die Steuerung) wird der veränderte Wert
% erst wenn die Eingabe korrekt abgeschlossen wurde. Dies geschieht über ENTER auf der Tastatur oder durch erneutes Touch-betätigen der InputArea.
% Wird die InputArea anders deaktiviert, z.B. durch aktivieren einer anderen InputArea oder durch Umblättern auf eine andere Seite der Visualisierung,
% so wird der Veränderte Wert nicht übernommen. Es bleibt der Wert vor der Aktivierung erhalten.
% Die Kontrolle, ob eine InputArea aktiviert wurde geschieht dadurch, daß der InitIndex ungleich Null und unglich dem aktuellen Index ist.


	idFontSelection selectFont

	% Index dieses Eingabefeldes festlegen und speichern
	MEM_Index 0 eq {
		/MDiaIndexCounter MDiaIndexCounter 1 add store
		/MEM_Index MDiaIndexCounter store
	} if

	% Wertanzeige aufrufen
	MDiaActualIndex MEM_Index eq {
		% Eingabefeld ist aktiv
		
		%Wertanzeige
		true
		MSiaActChaVal								% aktuell im keyboard eingegebener Wert lesen
		1 3 0
		irDeciNumb sp_getNumMaxLen 10 add
		0 idFontSelection
		baTouchString003							% hier wird die Stringanzeige verwendet, damit nur die eingebenen Nullen während der Eingabe erscheinen
		not MXiaKeybEnter or {						% Veränderte Werte übernehmen: wenn die InputArea deaktiviert wurde müssen die Globale Vars zurückgesetzt werden und die geänderten Werte übernommen werden (Dieses IF wird nur einmal bei deaktivieren durchlaufen)
			/MDiaActualIndex 0 store
			/MXiaKeybEnter false store
			/MRiaActualValue MRiaActChaVal store
			/irNumber MRiaActualValue store			% aktuell veränderten Wert übernehmen
		} if
	} {
		% Eingabefeld ist nicht aktiv
		false irNumber irDeciNumb 1 3 0 idFontSelection
		baTouchValue001 {							% Diese inputArea wird gerade aktiviert, und muß initialisiert werden
			% Kommastellen abschneiden: Der tatsächliche Wert muss auf den angezeigten Wert abgeschnitten werden.
			irDeciNumb dup cvi mod 0 eq { /irNumber irNumber cvi store } if
			irDeciNumb dup cvi mod 1 eq { /irNumber irNumber 10 mul cvi 10 div store } if
			irDeciNumb dup cvi mod 2 ge { /irNumber irNumber 100 mul cvi 10 div store } if
			% Initialisieren:
			/MDiaActualIndex MEM_Index store 		% Aktuelle InputArea aktiv setzen indem dieser Index in den global aktuellen geschrieben wird
			/MRiaActualValue irNumber store
			/MRiaActChaVal MRiaActualValue store
			/MRiaActMinVal irMinNumber store
			/MRiaActMaxVal irMaxNumber store
			/MRiaActDeciNumb irDeciNumb store
		} if
	} ifelse

	% eventuell veränderter Wert lesen und ausgeben, aber erst wenn die Eingabe vollständig erfolgt ist, sonst erfolgt nur die Anzeige des geänderten Wertes
	% Wenn die InputArea aktiv ist, wird die aktuelle Veränderung am Ausgang nicht übergeben. Erst wenn die Eingabe fertig ist, und die Input Area wieder deaktiviert wurde
	MDiaActualIndex MEM_Index eq {
		/qrNumber MRiaActualValue store
	} {
		/qrNumber irNumber store
	} ifelse

%?manual_end
	qrNumber
	MEM_Index
} def
%?partend

%?partdef baInpArea002
%?fn	baInpArea002
%?brief	input area with real values with unit and activation button, else same part as "baInpArea001" but can only be activated when its activation input is TRUE
%?bbox	0 0 79 39
/baInpArea002 {
	/MEM_Index	exch	def		%?brief actual value %?use STATIC %?type DINT
	/idUnit exch def			%?brief unit 0=no, f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 0
	/idFontSelection  exch 	def	%?brief font	 				%?use INP %?type DINT %?dflt FSstdFont
	/irMaxNumber exch def		%?brief max. value (value is limited by x <= xmax)						%?use INP	%?type REAL	%?dflt 999.9
	/irMinNumber exch def		%?brief min. value (value is limited by x >= xmin)						%?use INP	%?type REAL	%?dflt 0.0
	/irDeciNumb exch def		%?brief Code der angezeigten Stellen z.B. 2.1							%?use INP %?type REAL %?dflt 2.1
	/ixActPossible	exch	def	%?brief activation of the input area is possible						%?use INP	%?type BOOL %?dflt false
	/irNumber	exch	def		%?brief actual value													%?use INP	%?type REAL	%?dflt 0.0
	/qrNumber	0.0		def		%?brief modificated value												%?use OUT	%?type REAL	%?dflt 0.0
%?manual_beg
	/LR_value	0.0	def			% dient nur zur Anzeige
	/LS_Unit	()	def			% aktuelle Einheit als String

% Beschreibung Eingabefeld: siehe baInpArea001 

	idFontSelection selectFont

	% Index dieses Eingabefeldes festlegen und speichern
	MEM_Index 0 eq {
		/MDiaIndexCounter MDiaIndexCounter 1 add store
		/MEM_Index MDiaIndexCounter store
	} if

	%eventuelle Umrechnung auf imperiale Masseinheit, bzw. Einheit setzen
	irNumber idUnit
	sp_calc_imperial
	/LR_value exch store

	idUnit sp_set_unit
	/LS_Unit exch store

	% Wertanzeige aufrufen
	MDiaActualIndex MEM_Index eq {
		% Eingabefeld ist aktiv
		
		%Wertanzeige
		true
		MSiaActChaVal								% aktuell im keyboard eingegebener Wert lesen
		1 3 0
		irDeciNumb sp_getNumMaxLen 10 add
		idUnit idFontSelection
		baTouchString003 not						% hier wird die Stringanzeige verwendet, damit nur die eingebenen Nullen während der Eingabe erscheinen
		ixActPossible not or						% Wenn die Möglichkeit zur Aktivierung entzogen wird, das Feld deaktivieren
		MXiaKeybEnter or {							% TRUE: Diese inputArea wird gerade deaktiviert; Veränderte Werte übernehmen: wenn die InputArea deaktiviert wurde müssen die Globale Vars zurückgesetzt werden und die geänderten Werte übernommen werden (Dieses IF wird nur einmal bei deaktivieren durchlaufen)
			/MDiaActualIndex 0 store
			/MXiaKeybEnter false store
			/MRiaActualValue MRiaActChaVal idUnit sp_calc_SI store
			/irNumber MRiaActualValue store			% aktuell veränderten Wert übernehmen
		} if
	} {
		% Eingabefeld ist nicht aktiv

		ixActPossible {								% Eingabefeld kann aktiviert werden
			false LR_value irDeciNumb 1 3 0 idFontSelection idUnit
			baTouchValue003 {						% TRUE: Diese inputArea wird gerade aktiviert, und muß initialisiert werden
				% Kommastellen abschneiden: Der tatsächliche Wert muss auf den angezeigten Wert abgeschnitten werden.
				irDeciNumb dup cvi mod 0 eq { /irNumber irNumber cvi store } if
				irDeciNumb dup cvi mod 1 eq { /irNumber irNumber 10 mul cvi 10 div store } if
				irDeciNumb dup cvi mod 2 ge { /irNumber irNumber 100 mul cvi 10 div store } if
				% Initialisieren:
				/MDiaActualIndex MEM_Index store 	% Aktuelle InputArea aktiv setzen indem dieser Index in den global aktuellen geschrieben wird
				/MRiaActualValue irNumber store
				/MRiaActChaVal MRiaActualValue idUnit sp_calc_imperial store
				/MRiaActMinVal irMinNumber idUnit sp_calc_imperial store
				/MRiaActMaxVal irMaxNumber idUnit sp_calc_imperial store
				/MRiaActDeciNumb irDeciNumb store
			} if
		} {											% Eingabefeld kann nicht aktiviert werden
			LR_value irDeciNumb () LS_Unit false false false false idFontSelection 0 
			baValueText001
		} ifelse
	} ifelse

	% eventuell veränderter Wert lesen und ausgeben, aber erst wenn die Eingabe vollständig erfolgt ist, sonst erfolgt nur die Anzeige des geänderten Wertes
	% Wenn die InputArea aktiv ist, wird die aktuelle Veränderung am Ausgang nicht übergeben. Erst wenn die Eingabe fertig ist, und die Input Area wieder deaktiviert wurde
	MDiaActualIndex MEM_Index eq {
		/qrNumber MRiaActualValue store
	} {
		/qrNumber irNumber store
	} ifelse

%?manual_end
	qrNumber
	MEM_Index
} def
%?partend

%?partdef baInpArea003
%?fn	baInpArea003
%?brief	input area with real values with unit selectable to be shown, else same part as "baInpArea002"
%?bbox	0 0 79 39
/baInpArea003 {
	/MEM_Index	exch	def		%?brief actual value										%?use STATIC %?type DINT
	/idDummy5 exch def			%?brief dummy 5						%?use INP %?type REAL %?dflt 0.0
	/idDummy4 exch def			%?brief dummy 4						%?use INP %?type REAL %?dflt 0.0
	/idDummy3 exch def			%?brief dummy 3						%?use INP %?type REAL %?dflt 0.0
	/idDummy2 exch def			%?brief dummy 2						%?use INP %?type REAL %?dflt 0.0
	/idDummy1 exch def			%?brief dummy 1						%?use INP %?type REAL %?dflt 0.0
	/idOrigin	exch 	def		%?brief origin: 0=center/center, 1=left/bottom, 2=left/center, 3=left/top, 4=center/top, ...	%?use INP %?type DINT %?dflt 0
	/ixUnitShow exch def		%?brief show unit	%?use INP %?type BOOL %?dflt false
	/idUnit exch def			%?brief unit 0=no, f.e.: 10=m->ft; list: 1X=distance 2X=load 3X=pressure 4X=temperature 5X=Flow 6X=Speed	%?use INP %?type DINT %?dflt 0
	/idFontSelection  exch 	def	%?brief font	 											%?use INP %?type DINT %?dflt FSstdFont
	/irMaxNumber exch def		%?brief max. value (value is limited by x <= xmax)			%?use INP	%?type REAL	%?dflt 999.9
	/irMinNumber exch def		%?brief min. value (value is limited by x >= xmin)			%?use INP	%?type REAL	%?dflt 0.0
	/irDeciNumb exch def		%?brief Code der angezeigten Stellen z.B. 2.1				%?use INP	%?type REAL %?dflt 2.1
	/ixActPossible	exch	def	%?brief activation of the input area is possible						%?use INP	%?type BOOL %?dflt false
	/irNumber	exch	def		%?brief actual value										%?use INP	%?type REAL	%?dflt 0.0
	/qrNumber	0.0		def		%?brief modificated value									%?use OUT	%?type REAL	%?dflt 0.0
%?manual_beg
	/LR_value	0.0	def			% dient nur zur Anzeige
	/LS_Unit	()	def			% aktuelle Einheit als String

	idFontSelection selectFont

	% Index dieses Eingabefeldes festlegen und speichern
	MEM_Index 0 eq {
		/MDiaIndexCounter MDiaIndexCounter 1 add store
		/MEM_Index MDiaIndexCounter store
	} if

	%eventuelle Umrechnung auf imperiale Masseinheit, bzw. Einheit setzen
	irNumber idUnit
	sp_calc_imperial
	/LR_value exch store

	idUnit sp_set_unit
	/LS_Unit exch store
	
	% Wertanzeige aufrufen
	MDiaActualIndex MEM_Index eq {
		% Eingabefeld ist aktiv
		
		%Wertanzeige
		true
		MSiaActChaVal								% aktuell im keyboard eingegebener Wert lesen
		1 3 idOrigin
		irDeciNumb sp_getNumMaxLen 10 add
		ixUnitShow { idUnit } { 0 } ifelse
		idFontSelection
		baTouchString003 not						% hier wird die Stringanzeige verwendet, damit nur die eingebenen Nullen während der Eingabe erscheinen
		ixActPossible not or						% Wenn die Möglichkeit zur Aktivierung entzogen wird, das Feld deaktivieren
		MXiaKeybEnter or {							% Veränderte Werte übernehmen: wenn die InputArea deaktiviert wurde müssen die Globale Vars zurückgesetzt werden und die geänderten Werte übernommen werden (Dieses IF wird nur einmal bei deaktivieren durchlaufen)
			/MDiaActualIndex 0 store
			/MXiaKeybEnter false store
			/MRiaActualValue MRiaActChaVal idUnit sp_calc_SI store
			/irNumber MRiaActualValue store			% aktuell veränderten Wert übernehmen
		} if
	} {
		% Einbgabefeld mit Einheitenanzeige
		ixUnitShow {
			% Eingabefeld ist nicht aktiv
			ixActPossible {								% Eingabefeld kann aktiviert werden
				false LR_value irDeciNumb 1 3 idOrigin idFontSelection idUnit
				baTouchValue003 {						% TRUE: Diese inputArea wird gerade aktiviert, und muß initialisiert werden
					% Kommastellen abschneiden: Der tatsächliche Wert muss auf den angezeigten Wert abgeschnitten werden.
					irDeciNumb dup cvi mod 0 eq { /irNumber irNumber cvi store } if
					irDeciNumb dup cvi mod 1 eq { /irNumber irNumber 10 mul cvi 10 div store } if
					irDeciNumb dup cvi mod 2 ge { /irNumber irNumber 100 mul cvi 10 div store } if
					% Initialisieren:
					/MDiaActualIndex MEM_Index store 	% Aktuelle InputArea aktiv setzen indem dieser Index in den global aktuellen geschrieben wird
					/MRiaActualValue irNumber store
					/MRiaActChaVal MRiaActualValue idUnit sp_calc_imperial store
					/MRiaActMinVal irMinNumber idUnit sp_calc_imperial store
					/MRiaActMaxVal irMaxNumber idUnit sp_calc_imperial store
					/MRiaActDeciNumb irDeciNumb store
				} if
			} {											% Eingabefeld kann nicht aktiviert werden
				LR_value irDeciNumb () LS_Unit false false false false idFontSelection idOrigin 
				baValueText001
			} ifelse
		}{
		% Einbgabefeld ohne Einheitenanzeige
			% Eingabefeld ist nicht aktiv
			ixActPossible {								% Eingabefeld kann aktiviert werden
				false LR_value irDeciNumb 1 3 idOrigin idFontSelection
				baTouchValue001 {						% TRUE: Diese inputArea wird gerade aktiviert, und muß initialisiert werden
					/MDiaActualIndex MEM_Index store 	% Aktuelle InputArea aktiv setzen indem dieser Index in den global aktuellen geschrieben wird
					/MRiaActualValue irNumber store
					/MRiaActChaVal MRiaActualValue idUnit sp_calc_imperial store
					/MRiaActMinVal irMinNumber idUnit sp_calc_imperial store
					/MRiaActMaxVal irMaxNumber idUnit sp_calc_imperial store
					/MRiaActDeciNumb irDeciNumb store
				} if
			} {											% Eingabefeld kann nicht aktiviert werden
				LR_value irDeciNumb () LS_Unit false false false false idFontSelection idOrigin 
				baValueText001
			} ifelse
		} ifelse
	} ifelse

	% eventuell veränderter Wert lesen und ausgeben, aber erst wenn die Eingabe vollständig erfolgt ist, sonst erfolgt nur die Anzeige des geänderten Wertes
	% Wenn die InputArea aktiv ist, wird die aktuelle Veränderung am Ausgang nicht übergeben. Erst wenn die Eingabe fertig ist, und die Input Area wieder deaktiviert wurde
	MDiaActualIndex MEM_Index eq {
		/qrNumber MRiaActualValue store 
	} {
		/qrNumber irNumber store
	} ifelse

%?manual_end
	qrNumber
	MEM_Index
} def
%?partend

%?partdef baInpAreaIncrDecr001
%?fn	baInpAreaIncrDecr001
%?brief	touch button, increases or decreases a value by keeping the button pressed
%?bbox	0 0 79 79
/baInpAreaIncrDecr001 {
	/MEM_ActualChange exch def	%?brief actual change value at pressed button %?use STATIC %?type REAL
	/MEM_DecimalPoint exch def	%?brief input decade position (1 --> first decimal place) %?use STATIC %?type DINT
	/MEM_TimeAtStart exch def	%?brief time when button was pressed %?use STATIC %?type DINT
	/MEM_TimeAtLasSca exch def	%?brief time at last scan %?use STATIC %?type DINT
	/irChangeStep exch def	%?brief change step: changes at single click, 0=1 at the last shown place of the value	%?use INP %?type REAL %?dflt 1.00
	/irChangeRate exch def	%?brief change rate: changes of single click change steps per second %?use INP %?type REAL %?dflt    5.00
	/irStartDelayTime exch def	%?brief start delay time until the vlaue begins to be increased or decreased %?use INP %?type REAL %?dflt    1.00
	/ixIncrease exch def	%?brief increase the value (not decrease) %?use INP %?type BOOL %?dflt true
%?manual_beg
	/L_Activated false def			% button pressed started (mDown)
	/L_Active false def				% button pressed
	/L_TimeSinSta 0 def				% time since button pressed
	/L_TimeSinLasSca 0 def			% time since last scan
	/LI_rightDigits	0	def
	/LS_helps		()	def
	/LR_help		0.0	def
	
% Mit diesem Part kann der Wert einer aktiven InputArea durch gedrückthalten des Touchbutton im Schnellauf verändert werden.
% Dieses Part funktioniert auch in Zusammenhang mit dem Keyboard der InputArea. Der Wert um den bei einem Click oder bei gedrückthalten
% geändert wird, kann direkt über den Eingang irChangeStep vorgegeben werden. Es kann an diesem Eingang aber auch 0 übergeben werden, 
% dann wird automatisch die letzte angezeigte Stelle der Inputarea als Step hergenommen.

% Übernommen wird der Wert in der InputArea, wenn diese durch ENTER am Keyboard oder durch erneutes Drücken der InputArea
% deaktiviert wird. Wird sie durch Umblättern der Visualisierung oder durch aktivieren einer anderen InputArea deaktiviert,
% so wird der ALTE Wert von vor der Aktivierung wieder übernommen.

% ACHTUNG Info: wird der change step mit 0.01 festgelegt, so kann es sein, daß pro Programmdurchlauf die Berechnung der Änderung pro
% Durchlauf Null ergibt, da der Berechnung nur zwei Kommastellen zur Verfügung stehen. In diesem Fall verändert sich die Anzeige nicht.
% Abhilfe: der Step oder die ChangeRate muß groß genug gewählt werden.

	% Anzuzeigende Stellen ermitteln für die Ausgabe in der String Variablen
	MRiaActChaVal MRiaActDeciNumb
	sp_getDigitInfo
	pop pop
	/LI_rightDigits exch store

	0 0 moveto
	baTouchButton006
	/L_Activated exch store
	/L_Active exch store

	% Ermitten der zu ändernden Kommastellen
	L_Activated {			% Initialisieren
		/MEM_ActualChange 0 store
		%analyse der zu verändernden Zahl bezüglich aktuell veränderten Kommastellen
		irChangeStep sp_getDeciPoint
		/MEM_DecimalPoint exch store
	} if

	irChangeStep 0 eq {
		/MEM_DecimalPoint MDiaActDeciPoint store
		MDiaActDeciPoint 0 eq { /irChangeStep 1 store } if
		MDiaActDeciPoint 1 eq { /irChangeStep 0.1 store } if
		MDiaActDeciPoint 2 eq { /irChangeStep 0.01 store } if
	} if
	
	% Zeitwerte lesen und speichern	
	L_Active {
		realtime dup dup
		MEM_TimeAtStart sub abs				% hier wird der Absolutwert genommen, da realtime überläuft und negativ wird
		/L_TimeSinSta exch store			% Zeit seit dem Tastendruck in ms
		MEM_TimeAtLasSca sub abs				% hier wird der Absolutwert genommen, da realtime überläuft und negativ wird
		/L_TimeSinLasSca exch store			% Zeit seit dem letzten Durchlauf in ms
		/MEM_TimeAtLasSca exch store			% Zeit für den nächsten Durchlauf speichern
	} {
		realtime dup
		/MEM_TimeAtStart exch store
		/MEM_TimeAtLasSca exch store
	} ifelse
	
	% Änderung des Wertes berechnen
	% Änderung um irChangeStep bei Tastendruck
	L_Activated {
		ixIncrease {
			/MRiaActChaVal MRiaActChaVal irChangeStep add store
		} {
			/MRiaActChaVal MRiaActChaVal irChangeStep sub store
		} ifelse
		% Kontrolle der Grenzwerte
		MRiaActChaVal MRiaActMinVal lt { /MRiaActChaVal MRiaActMinVal store } if
		MRiaActChaVal MRiaActMaxVal gt { /MRiaActChaVal MRiaActMaxVal store } if
		/MSiaActChaVal MRiaActChaVal LS_helps LI_rightDigits ncvs store
	} if
	% Änderung im Schnellauf
	L_Active L_TimeSinSta irStartDelayTime 1000 mul gt and {
		irChangeRate irChangeStep mul L_TimeSinLasSca mul 1000 div		% Berechnung der Änderung pro Durchlauf (bleibt auf dem stack)
		/MEM_ActualChange exch MEM_ActualChange add store						% Berechneter Wert speichern
		% Die Änderung pro Durchlauf soll bei Übergabe irChangeStep = 1 auch nur um 1 erfolgen usw.
		MEM_DecimalPoint 0 eq { MEM_ActualChange round cvi } if							% ACHTUNG Wert am stack wird verändert und bleit am stack
		MEM_DecimalPoint 1 eq { MEM_ActualChange 10 mul round cvi cvr 10 div } if		% ACHTUNG Wert am stack wird verändert und bleit am stack
		MEM_DecimalPoint 2 eq { MEM_ActualChange 100 mul round cvi cvr 100 div } if		% ACHTUNG Wert am stack wird verändert und bleit am stack
		% eingegebenen Wert speichern
		dup irChangeStep ge { /MEM_ActualChange 0 store } if			% Änderungesspeicher löschen, wenn die Änderung übernommen wurde
		ixIncrease {
			MRiaActChaVal add
		} {
			MRiaActChaVal exch sub
		} ifelse
		/MRiaActChaVal exch store
		% Kontrolle der Grenzwerte
		MRiaActChaVal MRiaActMinVal lt { /MRiaActChaVal MRiaActMinVal store } if
		MRiaActChaVal MRiaActMaxVal gt { /MRiaActChaVal MRiaActMaxVal store } if
		% Umformung zur Anzeige
		/MSiaActChaVal MRiaActChaVal LS_helps LI_rightDigits ncvs store
	} if

%?manual_end
	MEM_ActualChange MEM_DecimalPoint MEM_TimeAtStart MEM_TimeAtLasSca 
} def
%?partend

%?partdef baCursorfield001
%?fn baCursorfield001
%?brief	cursorfield with three different cursors, color selectable
%?bbox	0 0 159 159
/baCursorfield001 {
	/irMaxYn	exch	def		%?brief maximaler negativer Y-Wert	%?use INP	%?type REAL	%?dflt -45
	/irMaxXn	exch	def		%?brief maximaler negativer X-Wert	%?use INP	%?type REAL	%?dflt -45
	/irMaxYp	exch	def		%?brief maximaler positiver Y-Wert	%?use INP	%?type REAL	%?dflt 45
	/irMaxXp	exch	def		%?brief maximaler positiver X-Wert	%?use INP	%?type REAL	%?dflt 45
	/irScaleY	exch	def		%?brief scale Y (1 = grid unit)		%?use INP	%?type REAL	%?dflt 1
	/irScaleX	exch	def		%?brief scale X (1 = grid unit)		%?use INP	%?type REAL	%?dflt 1
	/irYpos3	exch	def		%?brief Y-position des 3. Cursor	%?use INP	%?type REAL	%?dflt 0
	/irXpos3	exch	def		%?brief X-position des 3. Cursor	%?use INP	%?type REAL	%?dflt 0
	/irYpos2	exch	def		%?brief Y-position des 2. Cursor	%?use INP	%?type REAL	%?dflt 0
	/irXpos2	exch	def		%?brief X-position des 2. Cursor	%?use INP	%?type REAL	%?dflt 0
	/irYpos1	exch	def		%?brief Y-position des 1. Cursor	%?use INP	%?type REAL	%?dflt 0
	/irXpos1	exch	def		%?brief X-position des 1. Cursor	%?use INP	%?type REAL	%?dflt 0
	/idCursorForm3	exch	def		%?brief 3. Cursor-form: 0 nicht aktiv, 1 quadrat, 2 kreuz, 3 kreis (Farbe bsp: 11 grünes Quadrat, 22 blaues Kreuz, 33 gelber Kreis...)	%?use INP	%?type DINT	%?dflt 0
	/idCursorForm2	exch	def		%?brief 2. Cursor-form: 0 nicht aktiv, 1 quadrat, 2 kreuz, 3 kreis (Farbe bsp: 41 rotes Quadrat, 52 graues Kreuz, 63 hellgrauer Kreis...)	%?use INP	%?type DINT	%?dflt 0
	/idCursorForm1	exch	def		%?brief 1. Cursor-form: 0 nicht aktiv, 1 quadrat, 2 kreuz, 3 kreis (Farbe bsp: 71 dunkelgrünes Quadrat, 82 oranges Kreuz, 93 brauner Kreis...)	%?use INP	%?type DINT	%?dflt 0

%?manual_beg
	/LD_CursorForm1 idCursorForm1 dup 10 div cvi 10 mul sub def
	/LD_CursorForm2 idCursorForm2 dup 10 div cvi 10 mul sub def
	/LD_CursorForm3 idCursorForm3 dup 10 div cvi 10 mul sub def
	/LD_Cursorcolor1 idCursorForm1 10 div cvi def
	/LD_Cursorcolor2 idCursorForm2 10 div cvi def
	/LD_Cursorcolor3 idCursorForm3 10 div cvi def

	matrix currentmatrix currentcolor

	/L_RangeXpos 40 def
	/L_RangeYpos 40 def
	/L_RangeXneg 40 def
	/L_RangeYneg 40 def
	/L_Xposition 0 def
	/L_Yposition 0 def
	/L_size 5 def

	irScaleX 2 gt irScaleY 2 gt or {
		/L_size L_size 2 mul store
	} if

	% Berechnung der Randkoordinaten
	/L_RangeXpos MDsymbolGrid irScaleX mul 4 sub irMaxXn abs irMaxXp add div irMaxXp mul store
	/L_RangeYpos MDsymbolGrid irScaleY mul 4 sub irMaxYn abs irMaxYp add div irMaxYp mul store
	/L_RangeXneg MDsymbolGrid irScaleX mul 4 sub irMaxXn abs irMaxXp add div irMaxXn mul store
	/L_RangeYneg MDsymbolGrid irScaleY mul 4 sub irMaxYn abs irMaxYp add div irMaxYn mul store

	% Ursprung Koordinatensystem setzen
	L_RangeXneg neg 2 add L_RangeYneg neg 2 add translate
	% Rahmen zeichnen
	L_RangeXneg L_RangeYneg L_RangeXneg abs L_RangeXpos add L_RangeYneg abs L_RangeYpos add rectstroke
	% Fadenkreuz zeichnen
%	LightGrey
	L_RangeXneg 0 moveto L_RangeXpos 0 lineto stroke
	0 L_RangeYneg moveto 0 L_RangeYpos lineto stroke

	setcolor
	3 setlinewidth

	currentcolor
	LD_Cursorcolor1 sp_set_color
	irXpos1 irMaxXp lt irXpos1 irMaxXn gt and irYpos1 irMaxYp lt irYpos1 irMaxYn gt and and {
		irXpos1 0 ge { /L_Xposition irXpos1 irMaxXp div L_RangeXpos L_size sub mul store } { /L_Xposition irXpos1 irMaxXn div L_RangeXneg L_size add mul store } ifelse
		irYpos1 0 ge { /L_Yposition irYpos1 irMaxYp div L_RangeYpos L_size sub mul store } { /L_Yposition irYpos1 irMaxYn div L_RangeYneg L_size add mul store } ifelse
		L_Xposition L_Yposition moveto
		LD_CursorForm1 1 eq { L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto L_size 2 mul 0 rlineto 0 L_size 2 mul neg rlineto L_size 2 mul neg 0 rlineto stroke } if
		LD_CursorForm1 2 eq { L_size neg 0 rmoveto L_size 2 mul 0 rlineto L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto stroke } if
		LD_CursorForm1 3 eq { L_Xposition L_size add L_Yposition moveto L_Xposition L_Yposition L_size 0 360 arc stroke } if
	} if
	setcolor 

	currentcolor
	LD_Cursorcolor2 sp_set_color
	irXpos2 irMaxXp lt irXpos2 irMaxXn gt and irYpos2 irMaxYp lt irYpos2 irMaxYn gt and and {
		irXpos2 0 ge { /L_Xposition irXpos2 irMaxXp div L_RangeXpos L_size sub mul store } { /L_Xposition irXpos2 irMaxXn div L_RangeXneg L_size add mul store } ifelse
		irYpos2 0 ge { /L_Yposition irYpos2 irMaxYp div L_RangeYpos L_size sub mul store } { /L_Yposition irYpos2 irMaxYn div L_RangeYneg L_size add mul store } ifelse
		L_Xposition L_Yposition moveto
		LD_CursorForm2 1 eq { L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto L_size 2 mul 0 rlineto 0 L_size 2 mul neg rlineto L_size 2 mul neg 0 rlineto stroke } if
		LD_CursorForm2 2 eq { L_size neg 0 rmoveto L_size 2 mul 0 rlineto L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto stroke } if
		LD_CursorForm2 3 eq { L_Xposition L_size add L_Yposition moveto L_Xposition L_Yposition L_size 0 360 arc stroke } if
	} if
	setcolor 

	currentcolor
	LD_Cursorcolor3 sp_set_color
	irXpos3 irMaxXp lt irXpos3 irMaxXn gt and irYpos3 irMaxYp lt irYpos3 irMaxYn gt and and {
		irXpos3 0 ge { /L_Xposition irXpos3 irMaxXp div L_RangeXpos L_size sub mul store } { /L_Xposition irXpos3 irMaxXn div L_RangeXneg L_size add mul store } ifelse
		irYpos3 0 ge { /L_Yposition irYpos3 irMaxYp div L_RangeYpos L_size sub mul store } { /L_Yposition irYpos3 irMaxYn div L_RangeYneg L_size add mul store } ifelse
		L_Xposition L_Yposition moveto
		LD_CursorForm3 1 eq { L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto L_size 2 mul 0 rlineto 0 L_size 2 mul neg rlineto L_size 2 mul neg 0 rlineto stroke } if
		LD_CursorForm3 2 eq { L_size neg 0 rmoveto L_size 2 mul 0 rlineto L_size neg L_size neg rmoveto 0 L_size 2 mul rlineto stroke } if
		LD_CursorForm3 3 eq { L_Xposition L_size add L_Yposition moveto L_Xposition L_Yposition L_size 0 360 arc stroke } if
	} if
	setcolor 

	1 setlinewidth
	setmatrix
%?manual_end
} def
%?partend

%?partdef baTrendDisplay001
%?fn baTrendDisplay001
%?brief	continuous diagram over time
%?bbox	0 0 639 479
/baTrendDisplay001 {
%?manual_beg
	/MEMarrayTime exch def %?brief Zeit WerteArray %?use STATIC %?type ARR %?dflt 10000
	/MEMarray1 exch def %?brief Value 1 WerteArray Farbe: default %?use STATIC %?type ARR %?dflt 10000
	/MEMarray2 exch def %?brief Value 2 WerteArray Farbe: grün %?use STATIC %?type ARR %?dflt 10000
	/MEMarray3 exch def %?brief Value 3 WerteArray Farbe: gelb %?use STATIC %?type ARR %?dflt 10000
	/MEMarray4 exch def %?brief Value 4 WerteArray Farbe: rot %?use STATIC %?type ARR %?dflt 10000
	/MEMarray5 exch def %?brief Value 5 WerteArray Farbe: blau %?use STATIC %?type ARR %?dflt 10000

	/irMaxValue	exch	def		%?brief Maximumwert der Y-Skala	%?use INP	%?type REAL	%?dflt 10
	/irMinValue	exch	def		%?brief Mindestwert der Y-Skala	%?use INP	%?type REAL	%?dflt 0
	/irFieldsY	exch	def		%?brief Skalierungabschnitte der Y-Skala	%?use INP	%?type REAL	%?dflt 10
	/irValue5	exch	def		%?brief Anzeigewert 5 in blau	%?use INP	%?type REAL	%?dflt 0
	/irValue4	exch	def		%?brief Anzeigewert 4 in rot	%?use INP	%?type REAL	%?dflt 0
	/irValue3	exch	def		%?brief Anzeigewert 3 in grün	%?use INP	%?type REAL	%?dflt 0
	/irValue2	exch	def		%?brief Anzeigewert 2 in gelb	%?use INP	%?type REAL	%?dflt 0
	/irValue1	exch	def		%?brief Anzeigewert 1 in Systemfarbe	%?use INP	%?type REAL	%?dflt 0

	/LD_scaleX	100	def				% Genauigkeit der Skalierung der X-Achse: pixel/s
	/LD_timeS	0	def				% aktuelle Sekunden des TrendDisplay (ohne abgelaufene Minuten)
	/LD_timeM	0	def				% aktuelle Minuten des TrendDisplay
	/LD_lastTimeScale	0	def		% neueste ZeitachsenSkalierung rechts im Bild, nach links laufend: Abstand vom rechten Bildschirmrand
	/LD_pos		0	def
	/LD_StartPos 0 def
	/LD_ReadPos 0 def
	/LD_EndPos 0 def
	/LD_help	0	def
	/LS_help	()	def

	/LDmaxPixX MDmaxMsgPixX def
	/LDmaxPixY MDmaxMsgPixY def

	
	% berechnete Werte definieren
	/LD_scaleY LDmaxPixY irFieldsY div def		% Grösse eines Skalierungsabschnittes der Y-Achse in Pixel
	/LD_stepY irMaxValue irMinValue sub irFieldsY div def	% Skalierung der Y-Achse ausrechnen in Skalierungsschritten

	matrix currentmatrix currentcolor
	ValueFont

	% Zoomen der Zeit
	matrix currentmatrix currentcolor
	0 0 translate
	baTouchButton007 { /MDtdFactX MDtdFactX 2 div store } if
	15 40 moveto (Zoom) show_utf8
	25 15 moveto (Out) show_utf8
	setcolor setmatrix
	matrix currentmatrix currentcolor
	LDmaxPixX 80 sub 0 translate
	baTouchButton007 { /MDtdFactX MDtdFactX 2 mul store } if
	15 40 moveto (Zoom) show_utf8
	35 15 moveto (In) show_utf8
	setcolor setmatrix
	MDtdFactX 0 le { /MDtdFactX 0.01 store } if
	/LD_scaleX LD_scaleX MDtdFactX mul store

	% Starten des Zeitverlaufes (hierbei werden die Arrays gelöscht, und neu angefangen)
	matrix currentmatrix currentcolor
	LDmaxPixX 2 div 80 sub 0 translate
	baTouchButton007 {
		/MXdispRunning true store
		/MDstartTime realtime_sec store
		/LD_pos 0 store
		MEMarray1 length {
			MEMarrayTime LD_pos 0 put	
			MEMarray1 LD_pos 0 put	
			MEMarray2 LD_pos 0 put	
			MEMarray3 LD_pos 0 put	
			MEMarray4 LD_pos 0 put	
			MEMarray5 LD_pos 0 put	
			/LD_pos LD_pos 1 add store
		} repeat
		/MDactArrayPos 0 store
		/MXarrayFull false store
	} if
	20 30 moveto
	(RUN) show_utf8
	setcolor setmatrix
	% Stoppen des Zeitverlaufes
	matrix currentmatrix currentcolor
	LDmaxPixX 2 div 0 translate
	baTouchButton007 { /MXdispRunning false store } if
	15 30 moveto
	(STOP) show_utf8
	setcolor setmatrix

	% Startzeit berechnen
	MDstartTime 0 eq { /MDstartTime realtime_sec store } if
 	MXdispRunning { /MDtime realtime_sec MDstartTime sub store } if		% aktuelle Zeit seit dem Start in Sekunden
	/LD_timeS MDtime 60 mod store					% aktuelle Sekunden ohne Minuten herausrechnen
	/LD_timeM MDtime 60 div cvi store				% aktuelle Minuten ohne Sekunden herausrechnen

	% aktuelle Zeit einblenden
	(:xx.xx) strwh LDmaxPixX 2 index sub 3 sub LDmaxPixY 2 index sub 3 sub moveto pop pop		% Position hinter den Minuten
	LD_timeM LS_help 0 ncvs dup strw neg 0 rmoveto							% Position um die Anzeigelänge der minuten nach links schieben
	show_utf8											% Anzeige Minuten
	LD_timeS 10 lt { (:0) }{ (:) } ifelse show_utf8			
	LD_timeS LS_help 2 ncvs show_utf8					% Anzeige Sekunden

	% Skalierung Zeichnen
	Grey

	% Skalierung der Y-Achse
	/LD_pos 0 store
	irFieldsY {
		/LD_help LD_scaleY LD_pos mul store
		0 LD_help moveto LDmaxPixX LD_help lineto stroke					% horizontale Linie Zeichnen
		5 LD_help 5 add moveto LD_pos LD_stepY mul irMinValue add LS_help 0 ncvs show_utf8	% Beschriftung
		/LD_pos LD_pos 1 add store
	} repeat

	% Skalierung der Zeit-Achse
	/LD_lastTimeScale LD_timeS LD_timeS cvi sub LD_scaleX mul store	% Abstand der neuesten Zeitachse vom rechten Bildschirmrand berechnen
	/LD_pos LDmaxPixX LD_lastTimeScale sub store
	LDmaxPixX LD_scaleX div cvi 1 add {							% Anzahl der maximal sichtbaren Linien berechnen
		LD_pos 0 gt {												% das hinauszeichnen über den linken Bildschirmrand abfangen
			LD_pos 0 moveto LD_pos LDmaxPixY lineto stroke				% vertikale Linie Zeichnen
		} if
		/LD_pos LD_pos LD_scaleX sub store							% Position für den nächsten Schleifendurchlauf berechnen
	} repeat

	% aktuellen Zeitwert ins Array speichern
 	MXdispRunning {
		MEMarrayTime MDactArrayPos MDtime put
		% aktuellen Wert ins Array speichern
		MEMarray1 MDactArrayPos irValue1 put
		MEMarray2 MDactArrayPos irValue2 put
		MEMarray3 MDactArrayPos irValue3 put
		MEMarray4 MDactArrayPos irValue4 put
		MEMarray5 MDactArrayPos irValue5 put
		% aktuelle Arrayposition weiterzählen (beginnt bei 0)
		/MDactArrayPos MDactArrayPos 1 add store
		MDactArrayPos MEMarrayTime length ge {						% das Array arbeitet als Ringspeicher
			/MDactArrayPos 0 store
			/MXarrayFull true store
		} if
	} if

	% Diagramme zeichnen
	% aktuelle Startposition zum lesen des Array ermitteln
	MXarrayFull {
		/LD_StartPos MDactArrayPos store
		/LD_EndPos MDactArrayPos 1 sub store
		LD_EndPos 0 lt { /LD_EndPos MEMarrayTime length 1 sub store } if
	}{
		/LD_StartPos 0 store
		/LD_EndPos MDactArrayPos 1 sub store
		LD_EndPos 0 lt { /LD_EndPos 0 store } if
		LD_EndPos LD_StartPos lt { /LD_EndPos LD_StartPos store } if
	} ifelse

	% Linie 1: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
%	setcolor currentcolor						% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray1 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray1 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 2: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Green										% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray2 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray2 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 3: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Yellow										% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray3 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray3 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 4: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Red											% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray4 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray4 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 5: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Blue										% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray5 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray5 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	setcolor setmatrix
	% Variablen für die Globale Speicherung auf den stack legen
	MEMarrayTime
	MEMarray1
	MEMarray2
	MEMarray3
	MEMarray4
	MEMarray5
%?manual_end
} def
%?partend

%?partdef baTrendDisplay002
%?fn baTrendDisplay002
%?brief	continuous diagram over time
%?bbox	0 0 639 479
/baTrendDisplay002 {
%?manual_beg
	/MEMtdFactX exch def %?brief Zoomfactor für die Zeitachse X des Trenddisplay %?use STATIC %?type DINT %?dflt 1
	/MEMdispRun exch def %?brief trend display is running %?use STATIC %?type BOOL %?dflt false
	/MEMarrayTime exch def %?brief Zeit WerteArray %?use STATIC %?type ARR %?dflt 10000
	/MEMarray1 exch def %?brief Value 1 WerteArray Farbe: default %?use STATIC %?type ARR %?dflt 10000
	/MEMarray2 exch def %?brief Value 2 WerteArray Farbe: grün %?use STATIC %?type ARR %?dflt 10000
	/MEMarray3 exch def %?brief Value 3 WerteArray Farbe: gelb %?use STATIC %?type ARR %?dflt 10000
	/MEMarray4 exch def %?brief Value 4 WerteArray Farbe: rot %?use STATIC %?type ARR %?dflt 10000
	/MEMarray5 exch def %?brief Value 5 WerteArray Farbe: blau %?use STATIC %?type ARR %?dflt 10000

	/irScaleY exch def	%?brief scale Y (1 = grid unit)	%?use INP %?type REAL %?dflt 1.0
	/irScaleX exch def	%?brief scale X (1 = grid unit)	%?use INP %?type REAL %?dflt 7.0
	/irMaxValue	exch	def		%?brief Maximumwert der Y-Skala	%?use INP	%?type REAL	%?dflt 10
	/irMinValue	exch	def		%?brief Mindestwert der Y-Skala	%?use INP	%?type REAL	%?dflt 0
	/irFieldsY	exch	def		%?brief Skalierungabschnitte der Y-Skala	%?use INP	%?type REAL	%?dflt 10
	/irValue5	exch	def		%?brief Anzeigewert 5 in blau	%?use INP	%?type REAL	%?dflt 0
	/irValue4	exch	def		%?brief Anzeigewert 4 in rot	%?use INP	%?type REAL	%?dflt 0
	/irValue3	exch	def		%?brief Anzeigewert 3 in grün	%?use INP	%?type REAL	%?dflt 0
	/irValue2	exch	def		%?brief Anzeigewert 2 in gelb	%?use INP	%?type REAL	%?dflt 0
	/irValue1	exch	def		%?brief Anzeigewert 1 in Systemfarbe	%?use INP	%?type REAL	%?dflt 0

	/LD_scaleX	100	def				% Genauigkeit der Skalierung der X-Achse: pixel/s
	/LD_timeS	0	def				% aktuelle Sekunden des TrendDisplay (ohne abgelaufene Minuten)
	/LD_timeM	0	def				% aktuelle Minuten des TrendDisplay
	/LD_lastTimeScale	0	def		% neueste ZeitachsenSkalierung rechts im Bild, nach links laufend: Abstand vom rechten Bildschirmrand
	/LD_pos		0	def
	/LD_StartPos 0 def
	/LD_ReadPos 0 def
	/LD_EndPos 0 def
	/LD_help	0	def
	/LS_help	()	def

	/LDmaxPixX MDsymbolGrid irScaleX mul def
	/LDmaxPixY MDsymbolGrid irScaleY mul def

	
	% berechnete Werte definieren
	/LD_scaleY LDmaxPixY irFieldsY div def		% Grösse eines Skalierungsabschnittes der Y-Achse in Pixel
	/LD_stepY irMaxValue irMinValue sub irFieldsY div def	% Skalierung der Y-Achse ausrechnen in Skalierungsschritten

	matrix currentmatrix currentcolor
	ValueFont

	% Zoomen der Zeit
	matrix currentmatrix currentcolor
	0 0 translate
	baTouchButton007 { /MEMtdFactX MEMtdFactX 2 div store } if
	15 40 moveto (Zoom) show_utf8
	25 15 moveto (Out) show_utf8
	setcolor setmatrix
	matrix currentmatrix currentcolor
	LDmaxPixX 80 sub 0 translate
	baTouchButton007 { /MEMtdFactX MEMtdFactX 2 mul store } if
	15 40 moveto (Zoom) show_utf8
	35 15 moveto (In) show_utf8
	setcolor setmatrix
	MEMtdFactX 0 le { /MEMtdFactX 0.01 store } if
	/LD_scaleX LD_scaleX MEMtdFactX mul store

	% Starten des Zeitverlaufes (hierbei werden die Arrays gelöscht, und neu angefangen)
	matrix currentmatrix currentcolor
	LDmaxPixX 2 div 80 sub 0 translate
	baTouchButton007 {
		/MEMdispRun true store
		/MDstartTime realtime_sec store
		/LD_pos 0 store
		MEMarray1 length {
			MEMarrayTime LD_pos 0 put	
			MEMarray1 LD_pos 0 put	
			MEMarray2 LD_pos 0 put	
			MEMarray3 LD_pos 0 put	
			MEMarray4 LD_pos 0 put	
			MEMarray5 LD_pos 0 put	
			/LD_pos LD_pos 1 add store
		} repeat
		/MDactArrayPos 0 store
		/MXarrayFull false store
	} if
	20 30 moveto
	(RUN) show_utf8
	setcolor setmatrix
	% Stoppen des Zeitverlaufes
	matrix currentmatrix currentcolor
	LDmaxPixX 2 div 0 translate
	baTouchButton007 { /MEMdispRun false store } if
	15 30 moveto
	(STOP) show_utf8
	setcolor setmatrix

	% Startzeit berechnen
	MDstartTime 0 eq { /MDstartTime realtime_sec store } if
 	MEMdispRun { /MDtime realtime_sec MDstartTime sub store } if		% aktuelle Zeit seit dem Start in Sekunden
	/LD_timeS MDtime 60 mod store					% aktuelle Sekunden ohne Minuten herausrechnen
	/LD_timeM MDtime 60 div cvi store				% aktuelle Minuten ohne Sekunden herausrechnen

	% aktuelle Zeit einblenden
	(:xx.xx) strwh LDmaxPixX 2 index sub 3 sub LDmaxPixY 2 index sub 3 sub moveto pop pop		% Position hinter den Minuten
	LD_timeM LS_help 0 ncvs dup strw neg 0 rmoveto							% Position um die Anzeigelänge der minuten nach links schieben
	show_utf8											% Anzeige Minuten
	LD_timeS 10 lt { (:0) }{ (:) } ifelse show_utf8			
	LD_timeS LS_help 2 ncvs show_utf8					% Anzeige Sekunden

	% Skalierung Zeichnen
	Grey

	% Skalierung der Y-Achse
	/LD_pos 0 store
	irFieldsY {
		/LD_help LD_scaleY LD_pos mul store
		0 LD_help moveto LDmaxPixX LD_help lineto stroke					% horizontale Linie Zeichnen
		5 LD_help 5 add moveto LD_pos LD_stepY mul irMinValue add LS_help 0 ncvs show_utf8	% Beschriftung
		/LD_pos LD_pos 1 add store
	} repeat

	% Skalierung der Zeit-Achse
	/LD_lastTimeScale LD_timeS LD_timeS cvi sub LD_scaleX mul store	% Abstand der neuesten Zeitachse vom rechten Bildschirmrand berechnen
	/LD_pos LDmaxPixX LD_lastTimeScale sub store
	LDmaxPixX LD_scaleX div cvi 1 add {							% Anzahl der maximal sichtbaren Linien berechnen
		LD_pos 0 gt {												% das hinauszeichnen über den linken Bildschirmrand abfangen
			LD_pos 0 moveto LD_pos LDmaxPixY lineto stroke				% vertikale Linie Zeichnen
		} if
		/LD_pos LD_pos LD_scaleX sub store							% Position für den nächsten Schleifendurchlauf berechnen
	} repeat

	% aktuellen Zeitwert ins Array speichern
 	MEMdispRun {
		MEMarrayTime MDactArrayPos MDtime put
		% aktuellen Wert ins Array speichern
		MEMarray1 MDactArrayPos irValue1 put
		MEMarray2 MDactArrayPos irValue2 put
		MEMarray3 MDactArrayPos irValue3 put
		MEMarray4 MDactArrayPos irValue4 put
		MEMarray5 MDactArrayPos irValue5 put
		% aktuelle Arrayposition weiterzählen (beginnt bei 0)
		/MDactArrayPos MDactArrayPos 1 add store
		MDactArrayPos MEMarrayTime length ge {						% das Array arbeitet als Ringspeicher
			/MDactArrayPos 0 store
			/MXarrayFull true store
		} if
	} if

	% Diagramme zeichnen
	% aktuelle Startposition zum lesen des Array ermitteln
	MXarrayFull {
		/LD_StartPos MDactArrayPos store
		/LD_EndPos MDactArrayPos 1 sub store
		LD_EndPos 0 lt { /LD_EndPos MEMarrayTime length 1 sub store } if
	}{
		/LD_StartPos 0 store
		/LD_EndPos MDactArrayPos 1 sub store
		LD_EndPos 0 lt { /LD_EndPos 0 store } if
		LD_EndPos LD_StartPos lt { /LD_EndPos LD_StartPos store } if
	} ifelse

	% Linie 1: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	setcolor currentcolor						% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray1 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray1 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 2: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Green										% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray2 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray2 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 3: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Yellow										% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray3 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray3 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 4: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Red											% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray4 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray4 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	% Linie 5: array auslesen und linien zeichnen (gezeichnet wird beginnend am ältesten Punkt bis zum neuesten)
	Blue										% Farbe wechseln
	/LD_ReadPos LD_StartPos store
	MEMarrayTime LD_ReadPos get					% X Position
	MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
	LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
	MEMarray5 LD_ReadPos get					% Y Position Wert 1
	irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
	moveto
	MXarrayFull { MEMarrayTime length 1 sub } { LD_EndPos } ifelse {						
		/LD_ReadPos LD_ReadPos 1 add store
		LD_ReadPos MEMarrayTime length ge {
			/LD_ReadPos 0 store
		} if
		MEMarrayTime LD_ReadPos get					% X Position
		MDtime exch sub LD_scaleX mul				% in die aktuelle Skalierung einrechnen
		LDmaxPixX exch sub						% in das zeitlich laufende Display einrechnen
		MEMarray5 LD_ReadPos get					% Y Position
		irMinValue sub LDmaxPixY irMaxValue irMinValue sub div mul	% in die aktuelle Skalierung einrechnen
		1 index 0 gt {								% Falls über den linken Bildschirmrand hinausgezeichnet würde, die Linie nicht zeichnen
			lineto
		}{
			moveto
		} ifelse
	} repeat
	stroke

	setcolor setmatrix
	% Variablen für die Globale Speicherung auf den stack legen
	MEMtdFactX
	MEMdispRun
	MEMarrayTime
	MEMarray1
	MEMarray2
	MEMarray3
	MEMarray4
	MEMarray5
%?manual_end
} def
%?partend

%?partdef baCalculator001
%?fn	baCalculator001
%?brief	calculator
%?bbox	0 0 319 479
/baCalculator001 {
	/MEM_ShowRes	exch def	%?brief show result (not actual input)								%?use STATIC	%?type BOOL %?dflt false
	/MEM_DecimalPoint exch def	%?brief input decade position (1 --> decimal point)			%?use STATIC 	%?type DINT %?dflt 0.0
	/MEM_Input_last	exch def	%?brief first typed number											%?use STATIC	%?type REAL %?dflt 0.0
	/MEM_Input_act	exch def	%?brief second typed number											%?use STATIC	%?type REAL %?dflt 0.0
	/MEM_Operator	exch def	%?brief typed operator											%?use STATIC	%?type DINT %?dflt 0
%?manual_beg
	/LD_numIn -1 def
	/LD_opIn -1 def
	/LX_Perc false def
	/LX_Comma false def
	/LX_Negativ false def
	/LX_Invers false def
	/LX_Result false def
	/LD_fraction 0 def
	/LS_number () def
	/LR_MaxNumber 21474836 def
	
	% check sign of actual number
	MEM_Input_act 0 lt { true } { false } ifelse
	/LX_ActNeg exch def

	% draw background
	matrix currentmatrix
	currentcolor
	Invisible
	0 0 translate
	1 1 318 478 rectfill
	setcolor
	setmatrix

	% handling of key Clear
	currentcolor
	matrix currentmatrix
	0 0 translate
	baTouchButton001 {
 		/MEM_Input_last 0.0 store 
 		/MEM_Input_act 0.0 store
 		/MEM_Operator 0 store
 		/MEM_DecimalPoint 0 store
 		/MEM_ShowRes false store
	} if
	setmatrix
	setcolor
	% draw keyboard keys and handle mouse events
	currentcolor
	matrix currentmatrix
	80 0 translate
	baTouchButton001 { /LD_numIn 0 store } if
	setmatrix
	matrix currentmatrix
	0 80 translate
	baTouchButton001 { /LD_numIn 1 store } if
	setmatrix
	matrix currentmatrix
	80 80 translate
	baTouchButton001 { /LD_numIn 2 store } if
	setmatrix
	matrix currentmatrix
	160 80 translate
	baTouchButton001 { /LD_numIn 3 store } if
	setmatrix
	matrix currentmatrix
	0 160 translate
	baTouchButton001 { /LD_numIn 4 store } if
	setmatrix
	matrix currentmatrix
	80 160 translate
	baTouchButton001 { /LD_numIn 5 store } if
	setmatrix
	matrix currentmatrix
	160 160 translate
	baTouchButton001 { /LD_numIn 6 store } if
	setmatrix
	matrix currentmatrix 
	0 240 translate
	baTouchButton001 { /LD_numIn 7 store } if
	setmatrix
	matrix currentmatrix
	80 240 translate
	baTouchButton001 { /LD_numIn 8 store } if
	setmatrix
	matrix currentmatrix
	160 240 translate
	baTouchButton001 { /LD_numIn 9 store } if
	setmatrix
	matrix currentmatrix
	160 0 translate
	baTouchButton001 { /LX_Comma true store } if
	setmatrix
	matrix currentmatrix
	240 0 translate
	baTouchButton001 { /LX_Result true store } if
	setmatrix
	matrix currentmatrix
	240 80 translate
	baTouchButton001 { /LX_Invers true store } if
	setmatrix
	matrix currentmatrix
	240 160 translate
	baTouchButton001 { /LX_Negativ true store } if
	setmatrix
	matrix currentmatrix
	240 240 translate
	baTouchButton001 { /LD_opIn 1 store } if
	setmatrix
	matrix currentmatrix
	240 320 translate
	baTouchButton001 { /LD_opIn 2 store } if
	setmatrix
	matrix currentmatrix
	160 320 translate
	baTouchButton001 { /LD_opIn 3 store } if
	setmatrix
	matrix currentmatrix
	80 320 translate
	baTouchButton001 { /LD_opIn 4 store } if
	setmatrix
	matrix currentmatrix
	0 320 translate
	baTouchButton001 { /LX_Perc true store } if
	setmatrix
	setcolor

	% handling of key hit INVERS
	LX_Invers {
		MEM_ShowRes {
			MEM_Input_last 0 ne {
				/MEM_Input_last 1 MEM_Input_last div store
			} if
		} {
			MEM_Input_act 0 ne {
				/MEM_Input_act 1 MEM_Input_act div store
				/MEM_DecimalPoint 3 store
			} if
		} ifelse
	} if
	% handling of key hit PLUS/MINUS
	LX_Negativ {
		MEM_ShowRes {
			/MEM_Input_last MEM_Input_last neg store
		} {
			/MEM_Input_act MEM_Input_act neg store
		} ifelse
	} if
	% handling of key hit PERCENT
	LX_Perc MEM_Operator 0 gt and {
		/MEM_Input_act MEM_Input_last MEM_Input_act mul 100 div store
		/MEM_DecimalPoint 3 store
	} if

	% handling of key hit RESULT
	LX_Result LD_opIn 0 gt or {
		MEM_Operator 0 eq { /MEM_Input_last MEM_Input_act store } if								% für erste Eingabe
		MEM_Operator 1 eq { /MEM_Input_last MEM_Input_last MEM_Input_act add store } if
		MEM_Operator 2 eq { /MEM_Input_last MEM_Input_last MEM_Input_act sub store } if
		MEM_Operator 3 eq { /MEM_Input_last MEM_Input_last MEM_Input_act mul store } if
		MEM_Operator 4 eq { /MEM_Input_last MEM_Input_last MEM_Input_act div store } if
		/MEM_Operator LD_opIn store																	% Operator für Berechnung nach zweiter Zahleneingabe speichern
		/LD_opIn -1 store
		/MEM_Input_act 0.0 store
 		/MEM_DecimalPoint 0 store
 		/MEM_ShowRes true store
	 } if

	% handling of key hit COMMA
	LX_Comma {
		MEM_DecimalPoint 0 eq {
			/MEM_DecimalPoint 1 store
		} {
			/MXfailureBeep true store
		} ifelse
	} if
		
	% handling of numerical key hit
	LD_numIn -1 ne {
 		/MEM_ShowRes false store
		MEM_DecimalPoint 2 eq {
			LX_ActNeg { 
				/MEM_Input_act MEM_Input_act LD_numIn 100 div sub store
			} {
				/MEM_Input_act MEM_Input_act LD_numIn 100 div add store
			} ifelse
			/MEM_DecimalPoint 3 store
		} if
		MEM_DecimalPoint 1 eq {
			LX_ActNeg { 
				/MEM_Input_act MEM_Input_act LD_numIn 10 div sub store
			} {
				/MEM_Input_act MEM_Input_act LD_numIn 10 div add store
			} ifelse
			/MEM_DecimalPoint 2 store
		} if
		MEM_DecimalPoint 0 eq {
			MEM_Input_act abs LR_MaxNumber 10 div lt {
				LX_ActNeg { 
					 MEM_Input_act 10 mul LD_numIn sub 
				} {
					 MEM_Input_act 10 mul LD_numIn add 
				} ifelse
				/MEM_Input_act exch store
			} {
				/MXfailureBeep true store
			} ifelse
		} if
	} if

	% handling of key hit BACKSPACE
	currentcolor
	matrix currentmatrix
	240 400 translate
	baTouchButton001 {
		MEM_DecimalPoint 0 eq {
			/MEM_Input_act MEM_Input_act 10 div cvi store
		} if
		MEM_DecimalPoint 1 eq {
			/MEM_DecimalPoint 0 store
		} if
		MEM_DecimalPoint 2 eq {
			/MEM_Input_act MEM_Input_act cvi store
			/MEM_DecimalPoint 1 store
		} if
		MEM_DecimalPoint 3 eq {
			/MEM_Input_act MEM_Input_act 10 mul cvi 10 div store
			/MEM_DecimalPoint 2 store
		} if
	} if
	setmatrix
	setcolor

	% set output variable (string)
	/LS_number () store
	MEM_ShowRes {
		/LS_number MEM_Input_last LS_number 2 ncvs store
	} {
		MEM_DecimalPoint 0 le { /LS_number MEM_Input_act LS_number 0 ncvs store } if
		MEM_DecimalPoint 1 eq { /LS_number MEM_Input_act LS_number 0 ncvs store } if
		MEM_DecimalPoint 2 eq { /LS_number MEM_Input_act LS_number 1 ncvs store } if
		MEM_DecimalPoint 3 ge { /LS_number MEM_Input_act LS_number 2 ncvs store } if
	} ifelse

	MEM_DecimalPoint 1 eq {
		/LS_number LS_number (.) strcat store
	} if

	% show actual number
	matrix currentmatrix
	230 440 translate
	LS_number FSfatFont 6
	baText001
	setmatrix

	% show keyboard symbols
	/xpos 40 def
	BigFatFont 
	xpos 40 moveto (C) sp_textCenterCenter
	xpos 120 moveto	(1) sp_textCenterCenter
	xpos 200 moveto	(4) sp_textCenterCenter
	xpos 280 moveto	(7) sp_textCenterCenter
	xpos 360 moveto	(%) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 40 moveto	(0) sp_textCenterCenter
	xpos 120 moveto	(2) sp_textCenterCenter
	xpos 200 moveto	(5) sp_textCenterCenter
	xpos 280 moveto	(8) sp_textCenterCenter
	xpos 360 moveto	(/) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 40 moveto (.) sp_textCenterCenter
	xpos 120 moveto	(3) sp_textCenterCenter
	xpos 200 moveto	(6) sp_textCenterCenter
	xpos 280 moveto	(9) sp_textCenterCenter
	xpos 360 moveto	(*) sp_textCenterCenter
	/xpos xpos 80 add store
	xpos 40 moveto (=) sp_textCenterCenter
	xpos 120 moveto	(1/x) sp_textCenterCenter
	xpos 200 moveto	(+/-) sp_textCenterCenter
	xpos 280 moveto	(+) sp_textCenterCenter
	xpos 360 moveto	(-) sp_textCenterCenter
	xpos 440 moveto	(â) sp_textCenterCenter
	
	1 478 moveto
	1 402 lineto
	stroke
	1 478 moveto
	238 478 lineto
	stroke

	% store values on stack
	MEM_ShowRes
	MEM_DecimalPoint
	MEM_Input_last
	MEM_Input_act
	MEM_Operator
%?manual_end
} def
%?partend


