%?version 00012
%?class	llsystem

% Definition of global system routines and variables LWN PS project files


% global variables especially for touch screen feature, keyboard and entry fields
% Never change these! Never use these for something other!
/_currentpage (page0) def
/_cpindex -1 def	% for "display"-procedure
/_mdown false def	% for touchscreen detection
/_mup false def
/_mstatus false def % true after touch down, reset at touch release
/_mxposd 0 def
/_myposd 0 def
% for keyboard hit detection
/_keyhit false def	
/_keycode 0 def
% for entry fields
/_fieldselect 0 def % index of currently selected entry field (0 if none)
/_fieldprevious 0 def % index of the last edited field
/_fieldactive false def % true if any entry field is highlighted

% Global not documented variables needed in every project
/_unused 0 def			%?brief sink for unused part outputs %?type DINT %?dflt 0

% Global variables needed in every project
/SXchangeUnit false def	%?brief switch to imperial units %?use GLO %?type BOOL %?dflt false
/SXoneBeep false def	%?brief set one beep %?use GLO %?type BOOL %?dflt false
/SScurrentPage (page0) def	%?brief actual page name (read only!) %?use MEM %?type STRI %?dflt (page0)
/MXflashing true def	%?brief variable flashing %?use MEM %?type BOOL %?dflt true
/MDrotate 0.000 def		%?brief variable rotating 360dgr %?use MEM %?type REAL %?dflt 0.000
/MDslide 0.000 def		%?brief variable sliding 0 to 100 and back %?use MEM %?type REAL %?dflt 0.000
/MDmsgValidNr -1 def		%?brief Anzahl aller aktuell relevanten Messages %?use MEM %?type REAL %?dflt 0.000
/MDmsgAcknNr 0 def		%?brief Anzahl aller aktuell quittierten, aber noch aktiven Messages %?use MEM %?type DINT %?dflt 0
/MDmsgDeactNr 0 def		%?brief Anzahl aller nicht quittierten aber schon zurückgesetzten Messages	%?use MEM %?type DINT %?dflt 0

% Global variables used in this library
/MXmbeepAcknFirst false def	%?brief Fehler auf der First Page Acknowledged								%?type BOOL %?dflt false
/MXmbeepAcknEng false def	%?brief Fehler auf der Engine Page Acknowledged								%?type BOOL %?dflt false
/MDmsgLowIndex 0 def		%?brief niedrigster relevanter Message index								%?type DINT %?dflt 0
/MDmsgHighIndex 0 def		%?brief höchster relevanter Message index									%?type DINT %?dflt 0
/MDmbeep 0 def				%?brief Anzahl aller nicht quittierten Fehler								%?type DINT %?dflt 0


% Procedure for displaying of "currentpage" - called on any page switch
% Caution: Other implementation necessary for use with original PS interpreter (Ghostscript etc.)
/display {
	_cpindex 0 lt {
		/_fieldselect 0 store	% page switch occured -
		/_fieldprevious 0 store	% reset selection parameters for entry fields
		/_fieldactive false store % initially no field selected
		dup /SScurrentPage exch store
		% page adress not valid, generate it
		cvx		
		/_cpindex exch store
		
	} {
		% page adress valid, use it directly
		pop	% remove page name from stack		
	} ifelse
	_cpindex exec
} def


% ******************************************************************************
% function definitions
% ******************************************************************************

%!proc sysRotVar
/sysRotVar {
	/MDrotate realtime 20 div 360 mod store			% dreht pro ms um 0,05°
} def

%!proc getSlide
/getSlide {
	realtime 2000 mod dup 1000 gt { 2000 exch sub } if 20 div	% 0 bis 100 in einer Sekunde, dann zurück
	/MDslide exch store
} def

%!proc getFlashing
/getFlashing {
	/MXflashing getflashstate store
} def

%!proc getMsgState
/getMsgState {
	getmessagestate
	/MDmsgHighIndex exch store
	/MDmsgLowIndex exch store
	/MDmsgAcknNr exch store
	/MDmsgDeactNr exch store
	/MDmsgValidNr exch store
} def



% ******************************************************************************
% font definitions
% ******************************************************************************

% Important: If you add a font procedure definition here,
% 			 do also add an entry in the procedure fontinit{} below!

%!proc Fontdefinitions

%?fontdef
/StdFont {
 	/llfar012 10 selectfont	% 12 pixel size
} def		
/FSstdFont 1 def	%?brief Font selection standard Font %?use MEM %?type DINT %?dflt 1

%?fontdef
/MiniFont {
 	/llfstd	10 selectfont	% 10 pixel size
} def		
/FSminiFont 2 def	%?brief Font selection Miini Font %?use MEM %?type DINT %?dflt 2

%?fontdef
/MidFont {
 	/llfar016 10 selectfont	% 16 pixel size
} def		
/FSmidFont 3 def	%?brief Font selection middle Font %?use MEM %?type DINT %?dflt 3

%?fontdef
/BigFont {
 	/llfstd 20 selectfont	% 20 pixel size
} def		
/FSbigFont 4 def	%?brief Font selection big Font %?use MEM %?type DINT %?dflt 4

%?fontdef
/ValueFont {
 	/llfar016	10 selectfont	% 16 pixel size
} def		
/FSvalueFont 5 def	%?brief Font selection Value Font %?use MEM %?type DINT %?dflt 5

%?fontdef
/MsgFont {
%% 	/llfar012	10 selectfont 	% 12 pixel size
 	/llfar016	10 selectfont	% 16 pixel size
} def		
/FSmsgFont 6 def	%?brief Font selection Message Font %?use MEM %?type DINT %?dflt 6

%?fontdef
/FatFont { 
	/llfar020	10 selectfont	% 20 pixel size	, outlines gefüllt
} def	
/FSfatFont 7 def	%?brief Font selection Fat Font %?use MEM %?type DINT %?dflt 7

%?fontdef
/BigFatFont { 
	/llfar020	15 selectfont	% 30 pixel size	, outlines gefüllt
} def	
/FSbigFatFont 8 def	%?brief Font selection Big Fat Font %?use MEM %?type DINT %?dflt 8


% fontinit: All font procedures must be called here! 
% Purpose: 1. To force an error to occur if a font procedure selects an unknown font
% 		   2. To set the default font. The last font which is called here remains set
% 	          until a font call occurs in the project
/fontinit {
	BigFatFont
	FatFont
	MsgFont
	ValueFont
	BigFont
	MidFont
	MiniFont
	StdFont		% <- the last font which is called here is the default font!
} def


%set font according to font number
%?subproc
/selectFont {
	% select optimized font for given font size
	/I_FontSelect exch def
	I_FontSelect 1 eq {	
		StdFont
	} {
		I_FontSelect 2 eq {	
			MiniFont	
		} {
			I_FontSelect 3 eq {	
				MidFont
			} {
				I_FontSelect 4 eq {	
					BigFont
				} {
					I_FontSelect 5 eq {	
						ValueFont
					} {
						I_FontSelect 6 eq {	
							MsgFont
						} {
							I_FontSelect 7 eq {	
								FatFont
							} {
								I_FontSelect 8 eq {	
									BigFatFont
								} {
									StdFont % unknown font size -> standard
								} ifelse
							} ifelse
						} ifelse
					} ifelse
				} ifelse
			} ifelse
		} ifelse
	} ifelse
} def


% ******************************************************************************
% color definitions (do not change the structure of the definitions!!!)
% ******************************************************************************

%!proc Colordefinitions

/ColGreen 0 def
/ColYellow 0 def
/ColRed 0 def
/ColBlue 0 def
/ColGrey 0 def
/ColLightGrey 0 def
/ColWhite 0 def
/ColBlack 0 def

%?coldef Green
/Green {
ColGreen setcolor
} def

%?coldef Yellow
/Yellow {
ColYellow setcolor
} def

%?coldef Red
/Red {
ColRed setcolor
} def

%?coldef Blue
/Blue {
ColBlue setcolor
} def

%?coldef Grey
/Grey {
ColGrey setcolor
} def

%?coldef LightGrey
/LightGrey {
ColLightGrey setcolor
} def

%?coldef TouchArea
/TouchArea {
ColGrey setcolor
} def

%?coldef TouchAreaInv
/TouchAreaInv {
ColLightGrey setcolor
} def

%?coldef Invisible
/Invisible {
ColBlack setcolor
} def

%?coldef White
/White {
ColWhite setcolor
} def


% Procedure for initialisation of color variables
% To be called from main part of project file at every startup of monitor

/colorinit {
currentcolor

0.05 0.95 0.05 setrgbcolor
currentcolor
/ColGreen exch store

0.95 0.95 0.05 setrgbcolor
currentcolor
/ColYellow exch store

0.95 0.05 0.05 setrgbcolor
currentcolor
/ColRed exch store

0.05 0.05 0.95 setrgbcolor
currentcolor
/ColBlue exch store

0.40 0.40 0.40 setrgbcolor
currentcolor
/ColGrey exch store

0.50 0.50 0.50 setrgbcolor
currentcolor
/ColLightGrey exch store

0.95 0.95 0.95 setrgbcolor
currentcolor
/ColWhite exch store

0.00 0.00 0.00 setrgbcolor
currentcolor
/ColBlack exch store

/_cpindex -1 store

setcolor
} def

% must be called here one time at first run to initialize color variables
colorinit	


% ******************************************************************************
% Part - definitionen
% ******************************************************************************

%?partdef	GeneralFunctions
%?fn	GeneralFunctions
%?brief	Part with general functions needed in page0
%?bbox 0 0 79 79
/GeneralFunctions {
%?manual_beg
	% FirstPage
	/MEM_msgIndex	exch	def		%?brief aktuell abgefragter Message index	%?use STATIC	%?type DINT	%?dflt 0
	/I_firstPage exch def			%?brief Seite die nach dem Einschalten erscheinen soll	%?use INP	%?type STRING	%?dflt main
	_currentpage (page0) eq {
		/_currentpage I_firstPage store
		/_cpindex -1 store
		/SScurrentPage _currentpage store
	} if

	% Funktionsaufrufe
	sysRotVar
	getSlide
	getFlashing
	getMsgState

	% Beschleunigung der MessageSeite (Page 0 vorder im Hintergrund laufend eine Message nach der anderen an, damit die Messages auf den Monitor geladen werden)
	MDmsgValidNr 0 gt _currentpage (s_message) ne and {
		MEM_msgIndex MDmsgLowIndex lt {
			/MEM_msgIndex MDmsgLowIndex store
		} if
		MEM_msgIndex MDmsgHighIndex le {
			MEM_msgIndex getmessagetext
			pop pop pop pop pop								% die erhaltene Information ist uninteressant, die Messages sollen nur vom Master auf den Monitor geholt werden
		} if
		/MEM_msgIndex MEM_msgIndex 1 add store				% Message-Index für nächsten Durchlauf erhöhen
		MEM_msgIndex MDmsgHighIndex gt {					% Falls der Maximale Index überschritten wurde, soll von vorne begonnen werden.
			/MEM_msgIndex MDmsgLowIndex store
		} if
	} if
	% Werte für globale Speicherung auf den stack legen
	MEM_msgIndex
%?manual_end
} def
%?partend

%?partdef WndCompLow
%?fn	WndCompLow
%?brief	Fensterkomparator mit Hysterese unterhalb des Schwellwert (gleich lwnlib)
%?bbox 0 0 79 79
/WndCompLow {
%?manual_beg
	/I_LimitHyst exch def		%?brief Schwellwert deaktiviert Ausgang	%?use INP	%?type REAL	%?dflt 0.000
	/I_Limit exch def			%?brief Schwellwert aktiviert Ausgang	%?use INP	%?type REAL	%?dflt 0.000
	/I_Value exch def			%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.000
	/O_ValInWnd false def		%?brief Eingangswert liegt unter dem Schwellwert	%?use OUT	%?type BOOL	%?dflt false
	I_Value I_Limit lt {
		/O_ValInWnd true store
	} if
	I_Value I_LimitHyst gt {
		/O_ValInWnd false store
	} if
	O_ValInWnd
%?manual_end
} def
%?partend

%?partdef WndCompHigh
%?fn	WndCompHigh
%?brief	Fensterkomparator mit Hysterese oberhalb des Schwellwert (gleich lwnlib)
%?bbox 0 0 79 79
/WndCompHigh {
%?manual_beg
	/I_LimitHyst exch def		%?brief Schwellwert deaktiviert Ausgang	%?use INP	%?type REAL	%?dflt 0.000
	/I_Limit exch def			%?brief Schwellwert aktiviert Ausgang	%?use INP	%?type REAL	%?dflt 0.000
	/I_Value exch def			%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.000
	/O_ValInWnd false def		%?brief Eingangswert liegt ober dem Schwellwert	%?use OUT	%?type BOOL	%?dflt false
	I_Value I_Limit gt {
		/O_ValInWnd true store
	} if
	I_Value I_LimitHyst lt {
		/O_ValInWnd false store
	} if
	O_ValInWnd
%?manual_end
} def
%?partend

%?partdef	BeepCall
%?fn	BeepCall
%?brief	Aufruf des Beep
%?bbox 0 0 79 79
/BeepCall {
%?manual_beg
	/I_active		exch	def		%?brief Beep eingeschalten	%?use INP	%?type BOOL	%?dflt false
	/I_volume		exch	def		%?brief Beep Lautstärke	%?use INP	%?type REAL	%?dflt 100
	/I_freq2		exch	def		%?brief Beep Frequenz 2	%?use INP	%?type REAL	%?dflt 0
	/I_freq1		exch	def		%?brief Beep Frequenz 1	%?use INP	%?type REAL	%?dflt 1000
	/I_time2		exch	def		%?brief Zeit Beep Frequenz 2	%?use INP	%?type REAL	%?dflt 1000
	/I_time1		exch	def		%?brief Zeit Beep Frequenz 1	%?use INP	%?type REAL	%?dflt 1000

% definition for PME Display
	/I_freq2 0 store
	I_freq1 990 gt {
		/I_freq1 2400 store
	} {
		/I_freq1 1300 store
	} ifelse
end
	
	I_time1 I_time2 I_freq1 I_freq2 I_volume I_active multibeep

%?manual_end
} def
%?partend

%?partdef	BeepAct
%?fn	BeepAct
%?brief	Beeper Part
%?bbox 0 0 79 79
/BeepAct {
%?manual_beg
	/MEM_acknowledged	exch	def		%?brief Störmeldung quittiert gespeichert	%?use STATIC	%?type BOOL	%?dflt false
	/I_ackn		exch	def		%?brief Quittierung der Störmeldung	%?use INP	%?type BOOL	%?dflt false
	/I_valid	exch	def		%?brief Aktivierung der Störmeldung	%?use INP	%?type BOOL	%?dflt false

	I_ackn { /MEM_acknowledged true store } if
	I_valid MEM_acknowledged not and { /MDmbeep MDmbeep 1 add store } if
	I_valid not MEM_acknowledged and { /MEM_acknowledged false store } if

	% Werte für globale Speicherung auf den stack legen
	MEM_acknowledged
%?manual_end
} def
%?partend

%?partdef	BeepActStore
%?fn	BeepActStore
%?brief	Beeper Part: bleibt erhalten bis zur Quittierung
%?bbox 0 0 79 79
/BeepActStore {
%?manual_beg
	/MEM_active	exch	def		%?brief Störmeldung aktiv gespeichert	%?use STATIC	%?type BOOL	%?dflt false
	/MEM_acknowledged	exch	def		%?brief Störmeldung quittiert gespeichert	%?use STATIC	%?type BOOL	%?dflt false
	/I_ackn		exch	def		%?brief quittierung der Störmeldung	%?use INP	%?type BOOL	%?dflt false
	/I_valid	exch	def		%?brief Aktivierung der Störmeldung	%?use INP	%?type BOOL	%?dflt false
	/O_active	false	def		%?brief Ausgangswert zur Symbolanzeige	%?use OUT	%?type BOOL	%?dflt false

	I_valid { /MEM_active true store } if			% Störmeldung speichern (wenn nicht aktiv -> keine Änderung)
	I_ackn { /MEM_acknowledged true store } if		% Quittierung speichern (wenn nicht aktiv -> keine Änderung)

	% beeperzähler erhöhen
	MEM_active MEM_acknowledged not and { /MDmbeep MDmbeep 1 add store } if

	% zurücksetzen der Speicher
	I_valid not MEM_acknowledged and { /MEM_active false store /MEM_acknowledged false store } if

	% Ausgangswert für Symbolanzeige auf den stack legen
	/O_active MEM_active store
	O_active

	% Werte für globale Speicherung auf den stack legen
	MEM_active
	MEM_acknowledged
%?manual_end
} def
%?partend


% ************************************************************************************************************************

%?partdef	TOGGLE
%?fn	TOGGLE
%?brief	toggle-Funktion: mit jeder steigenden Flanke am Eingang wechselt der Ausgang
%?bbox 0 0 79 79
/TOGGLE {
%?manual_beg
	/MEM_toggle	exch def	%?brief toggle Zustand gespeichert	%?use STATIC	%?type BOOL	%?dflt false
	/In1	exch	def		%?brief toggle Impuls (darf nur ein Durchlauf true sein (z.B. touch))	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief Ausgang			%?use OUT	%?type BOOL	%?dflt false

	In1 MEM_toggle and { /MEM_toggle false store } if
	In1 MEM_toggle not and { /MEM_toggle true store } if
	/Out MEM_toggle store
	
	Out
	MEM_toggle
%?manual_end
} def
%?partend


%?partdef	FUN_AND_2
%?fn	FUN_AND_2
%?brief	AND -Funktion mit 2 Eingängen
%?bbox 0 0 79 79
/FUN_AND_2 {
%?manual_beg
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type BOOL	%?dflt true
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief AND-Ausgang			%?use OUT	%?type BOOL	%?dflt false

	In1 In2 and
%?manual_end
} def
%?partend


%?partdef	FUN_AND_5
%?fn	FUN_AND_5
%?brief	AND -Funktion mit 5 Eingängen
%?bbox 0 0 79 79
/FUN_AND_5 {
%?manual_beg
	/In5	exch	def		%?brief Eingangsvariable 5	%?use INP	%?type BOOL	%?dflt true
	/In4	exch	def		%?brief Eingangsvariable 4	%?use INP	%?type BOOL	%?dflt true
	/In3	exch	def		%?brief Eingangsvariable 3	%?use INP	%?type BOOL	%?dflt true
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type BOOL	%?dflt true
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief AND-Ausgang			%?use OUT	%?type BOOL	%?dflt false

	In1 In2 In3 In4 In5 and and and and
%?manual_end
} def
%?partend


%?partdef	FUN_AND_15
%?fn	FUN_AND_15
%?brief	AND -Funktion mit 15 Eingängen
%?bbox 0 0 79 79
/FUN_AND_15 {
%?manual_beg
	/In15	exch	def		%?brief Eingangsvariable 15	%?use INP	%?type BOOL	%?dflt true
	/In14	exch	def		%?brief Eingangsvariable 14	%?use INP	%?type BOOL	%?dflt true
	/In13	exch	def		%?brief Eingangsvariable 13	%?use INP	%?type BOOL	%?dflt true
	/In12	exch	def		%?brief Eingangsvariable 12	%?use INP	%?type BOOL	%?dflt true
	/In11	exch	def		%?brief Eingangsvariable 11	%?use INP	%?type BOOL	%?dflt true
	/In10	exch	def		%?brief Eingangsvariable 10	%?use INP	%?type BOOL	%?dflt true
	/In9	exch	def		%?brief Eingangsvariable 9	%?use INP	%?type BOOL	%?dflt true
	/In8	exch	def		%?brief Eingangsvariable 8	%?use INP	%?type BOOL	%?dflt true
	/In7	exch	def		%?brief Eingangsvariable 7	%?use INP	%?type BOOL	%?dflt true
	/In6	exch	def		%?brief Eingangsvariable 6	%?use INP	%?type BOOL	%?dflt true
	/In5	exch	def		%?brief Eingangsvariable 5	%?use INP	%?type BOOL	%?dflt true
	/In4	exch	def		%?brief Eingangsvariable 4	%?use INP	%?type BOOL	%?dflt true
	/In3	exch	def		%?brief Eingangsvariable 3	%?use INP	%?type BOOL	%?dflt true
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type BOOL	%?dflt true
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief AND-Ausgang		%?use OUT	%?type BOOL	%?dflt false

	In1 In2 In3 In4 In5 In6 In7 In8 In9 In10 In11 In12 In13 In14 In15
	and and and and and and and and and and and and and and
%?manual_end
} def
%?partend


%?partdef	FUN_OR_2
%?fn	FUN_OR_2
%?brief	ODER -Funktion mit 2 Eingängen
%?bbox 0 0 79 79
/FUN_OR_2 {
%?manual_beg
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type BOOL	%?dflt false
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief ODER-Ausgang		%?use OUT	%?type BOOL	%?dflt false

	In1 In2 or
%?manual_end
} def
%?partend


%?partdef	FUN_OR_5
%?fn	FUN_OR_5
%?brief	ODER -Funktion mit 5 Eingängen
%?bbox 0 0 79 79
/FUN_OR_5 {
%?manual_beg
	/In5	exch	def		%?brief Eingangsvariable 5	%?use INP	%?type BOOL	%?dflt false
	/In4	exch	def		%?brief Eingangsvariable 4	%?use INP	%?type BOOL	%?dflt false
	/In3	exch	def		%?brief Eingangsvariable 3	%?use INP	%?type BOOL	%?dflt false
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type BOOL	%?dflt false
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief ODER-Ausgang		%?use OUT	%?type BOOL	%?dflt false

	In1 In2 In3 In4 In5 or or or or
%?manual_end
} def
%?partend


%?partdef	FUN_OR_15
%?fn	FUN_OR_15
%?brief	ODER -Funktion mit 15 Eingängen
%?bbox 0 0 79 79
/FUN_OR_15 {
%?manual_beg
	/In15	exch	def		%?brief Eingangsvariable 15	%?use INP	%?type BOOL	%?dflt false
	/In14	exch	def		%?brief Eingangsvariable 14	%?use INP	%?type BOOL	%?dflt false
	/In13	exch	def		%?brief Eingangsvariable 13	%?use INP	%?type BOOL	%?dflt false
	/In12	exch	def		%?brief Eingangsvariable 12	%?use INP	%?type BOOL	%?dflt false
	/In11	exch	def		%?brief Eingangsvariable 11	%?use INP	%?type BOOL	%?dflt false
	/In10	exch	def		%?brief Eingangsvariable 10	%?use INP	%?type BOOL	%?dflt false
	/In9	exch	def		%?brief Eingangsvariable 9	%?use INP	%?type BOOL	%?dflt false
	/In8	exch	def		%?brief Eingangsvariable 8	%?use INP	%?type BOOL	%?dflt false
	/In7	exch	def		%?brief Eingangsvariable 7	%?use INP	%?type BOOL	%?dflt false
	/In6	exch	def		%?brief Eingangsvariable 6	%?use INP	%?type BOOL	%?dflt false
	/In5	exch	def		%?brief Eingangsvariable 5	%?use INP	%?type BOOL	%?dflt false
	/In4	exch	def		%?brief Eingangsvariable 4	%?use INP	%?type BOOL	%?dflt false
	/In3	exch	def		%?brief Eingangsvariable 3	%?use INP	%?type BOOL	%?dflt false
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type BOOL	%?dflt false
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type BOOL	%?dflt false
	/Out	false	def		%?brief ODER-Ausgang		%?use OUT	%?type BOOL	%?dflt false

	In1 In2 In3 In4 In5 In6 In7 In8 In9 In10 In11 In12 In13 In14 In15
	or or or or or or or or or or or or or or
%?manual_end
} def
%?partend


%?partdef	FUN_MUL
%?fn	FUN_MUL
%?brief	MUL -Funktion mit 2 Eingängen
%?bbox 0 0 79 79
/FUN_MUL {
%?manual_beg
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type REAL	%?dflt 0.00
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type REAL	%?dflt 0.00
	/Out	0.00	def		%?brief MUL-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	In1 In2 mul
%?manual_end
} def
%?partend


%?partdef	FUN_DIV
%?fn	FUN_DIV
%?brief	DIV -Funktion mit 2 Eingängen
%?bbox 0 0 79 79
/FUN_DIV {
%?manual_beg
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type REAL	%?dflt 0.00
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type REAL	%?dflt 0.00
	/Out	0.00	def		%?brief DIV-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	In2 0 ne { In1 In2 div } if
%?manual_end
} def
%?partend


%?partdef	FUN_ADD
%?fn	FUN_ADD
%?brief	ADD -Funktion mit 2 Eingängen
%?bbox 0 0 79 79
/FUN_ADD {
%?manual_beg
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type REAL	%?dflt 0.00
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type REAL	%?dflt 0.00
	/Out	0.00	def		%?brief ADD-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	In1 In2 add
%?manual_end
} def
%?partend


%?partdef	FUN_SUB
%?fn	FUN_SUB
%?brief	SUB -Funktion mit 2 Eingängen
%?bbox 0 0 79 79
/FUN_SUB {
%?manual_beg
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type REAL	%?dflt 0.00
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type REAL	%?dflt 0.00
	/Out	0.00	def		%?brief SUB-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	In1 In2 sub
%?manual_end
} def
%?partend


%?partdef	FUN_SEL
%?fn	FUN_SEL
%?brief	SEL -Funktion (Selektierer)
%?bbox 0 0 79 79
/FUN_SEL {
%?manual_beg
	/In1	exch	def		%?brief Eingangsvariable IN 1	%?use INP	%?type REAL	%?dflt 0.00
	/In0	exch	def		%?brief Eingangsvariable IN 0	%?use INP	%?type REAL	%?dflt 0.00
	/InG	exch	def		%?brief Eingangsvariable G (Auswahl)	%?use INP	%?type BOOL	%?dflt false
	/Out	0.00	def		%?brief SEL-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	InG true eq { In1 } { In0 } ifelse
%?manual_end
} def
%?partend


%?partdef	FUN_MUX5
%?fn	FUN_MUX5
%?brief	MUX -Funktion (Multiplexer mit 5 Eingängen)
%?bbox 0 0 79 79
/FUN_MUX5 {
%?manual_beg
	/In5	exch	def		%?brief Eingangsvariable 5	%?use INP	%?type REAL	%?dflt 0.00
	/In4	exch	def		%?brief Eingangsvariable 4	%?use INP	%?type REAL	%?dflt 0.00
	/In3	exch	def		%?brief Eingangsvariable 3	%?use INP	%?type REAL	%?dflt 0.00
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type REAL	%?dflt 0.00
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type REAL	%?dflt 0.00
	/InK	exch	def		%?brief Eingangsvariable K (Auswahl)	%?use INP	%?type REAL	%?dflt 0.00
	/Out	0.00	def		%?brief MUX-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	InK 1 eq { In1 } if
	InK 2 eq { In2 } if
	InK 3 eq { In3 } if
	InK 4 eq { In4 } if
	InK 5 eq { In5 } if
%?manual_end
} def
%?partend


%?partdef	FUN_MUX15
%?fn	FUN_MUX15
%?brief	MUX -Funktion (Multiplexer mit 15 Eingängen)
%?bbox 0 0 79 79
/FUN_MUX15 {
%?manual_beg
	/In15	exch	def		%?brief Eingangsvariable 15	%?use INP	%?type REAL	%?dflt 0.00
	/In14	exch	def		%?brief Eingangsvariable 14	%?use INP	%?type REAL	%?dflt 0.00
	/In13	exch	def		%?brief Eingangsvariable 13	%?use INP	%?type REAL	%?dflt 0.00
	/In12	exch	def		%?brief Eingangsvariable 12	%?use INP	%?type REAL	%?dflt 0.00
	/In11	exch	def		%?brief Eingangsvariable 11	%?use INP	%?type REAL	%?dflt 0.00
	/In10	exch	def		%?brief Eingangsvariable 10	%?use INP	%?type REAL	%?dflt 0.00
	/In9	exch	def		%?brief Eingangsvariable 9	%?use INP	%?type REAL	%?dflt 0.00
	/In8	exch	def		%?brief Eingangsvariable 8	%?use INP	%?type REAL	%?dflt 0.00
	/In7	exch	def		%?brief Eingangsvariable 7	%?use INP	%?type REAL	%?dflt 0.00
	/In6	exch	def		%?brief Eingangsvariable 6	%?use INP	%?type REAL	%?dflt 0.00
	/In5	exch	def		%?brief Eingangsvariable 5	%?use INP	%?type REAL	%?dflt 0.00
	/In4	exch	def		%?brief Eingangsvariable 4	%?use INP	%?type REAL	%?dflt 0.00
	/In3	exch	def		%?brief Eingangsvariable 3	%?use INP	%?type REAL	%?dflt 0.00
	/In2	exch	def		%?brief Eingangsvariable 2	%?use INP	%?type REAL	%?dflt 0.00
	/In1	exch	def		%?brief Eingangsvariable 1	%?use INP	%?type REAL	%?dflt 0.00
	/InK	exch	def		%?brief Eingangsvariable K (Auswahl)	%?use INP	%?type REAL	%?dflt 0.00
	/Out	0.00	def		%?brief MUX-Ausgang		%?use OUT	%?type REAL	%?dflt 0.00

	InK 1 eq { In1 } if
	InK 2 eq { In2 } if
	InK 3 eq { In3 } if
	InK 4 eq { In4 } if
	InK 5 eq { In5 } if
	InK 6 eq { In6 } if
	InK 7 eq { In7 } if
	InK 8 eq { In8 } if
	InK 9 eq { In9 } if
	InK 10 eq { In10 } if
	InK 11 eq { In11 } if
	InK 12 eq { In12 } if
	InK 13 eq { In13 } if
	InK 14 eq { In14 } if
	InK 15 eq { In15 } if
%?manual_end
} def
%?partend


%?partdef	bitmap
%?fn	bitmap
%?brief	Einbettung eines Bitmaps auf dem Bild
%?bbox 0 0 80 80
/bitmap {
%?manual_beg
	/bmp_name	exch	def		%?brief Dateiname bitmap	%?use INP	%?type STRI	%?dflt *.bmp
	0 0 moveto 
	bmp_name	 
	showimage 
%?manual_end
} def
%?partend



% ****************************************************************************************************************

%?partdef	calc_lbs
%?fn	calc_lbs
%?brief	Einheitenumrechnung Gewicht: t -> lbs (Tonnen in Pounds)
%?bbox 0 0 79 79
/calc_lbs {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out	0.0		def		%?brief Ausgabewert		%?use OUT	%?type REAL	%?dflt 0.0

	In 2204.62 mul
%?manual_end
} def
%?partend

%?partdef	calc_F
%?fn	calc_F
%?brief	Einheitenumrechnung Temperatur: °C -> °F (Grad Celsius in Grad Fahrenheit)
%?bbox 0 0 79 79
/calc_F {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out	0.0		def		%?brief Ausgabewert		%?use OUT	%?type REAL	%?dflt 0.0

	In 1.8 mul 32 add
%?manual_end
} def
%?partend

%?partdef	calc_psi
%?fn	calc_psi
%?brief	Einheitenumrechnung Druck: bar -> psi (Tonnen in Pounds)
%?bbox 0 0 79 79
/calc_psi {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out	0.0		def		%?brief Ausgabewert		%?use OUT	%?type REAL	%?dflt 0.0

	In 1450.38 mul 100 div
%?manual_end
} def
%?partend

%?partdef	calc_kmh_mph
%?fn	calc_kmh_mph
%?brief	Einheitenumrechnung Geschwindigkeit: km/h -> mph (Kilometer pro Stunde in Mile per houre)
%?bbox 0 0 79 79
/calc_kmh_mph {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out	0.0		def		%?brief Ausgabewert		%?use OUT	%?type REAL	%?dflt 0.0

	In 62.14 mul 100 div
%?manual_end
} def
%?partend

%?partdef	calc_ms_mph
%?fn	calc_ms_mph
%?brief	Einheitenumrechnung Geschwindigkeit: m/s -> mph (Meter pro Sekunde in Mile per houre)
%?bbox 0 0 79 79
/calc_ms_mph {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out	0.0		def		%?brief Ausgabewert		%?use OUT	%?type REAL	%?dflt 0.0

	In 223.69 mul 100 div
%?manual_end
} def
%?partend

%?partdef	calc_ms_kn
%?fn	calc_ms_kn
%?brief	Einheitenumrechnung Geschwindigkeit: m/s -> kn (Meter pro Sekunde in knots (nautical mile (nmi) per houre))
%?bbox 0 0 79 79
/calc_ms_kn {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out	0.0		def		%?brief Ausgabewert		%?use OUT	%?type REAL	%?dflt 0.0

	In 194.39 mul 100 div
%?manual_end
} def
%?partend

%?partdef	calc_ftin
%?fn	calc_ftin
%?brief	Einheitenumrechnung Weg: m -> ft, in (',") (Meter in feet und inch)
%?bbox 0 0 79 79
/calc_ftin {
%?manual_beg
	/In		exch	def		%?brief Eingangswert	%?use INP	%?type REAL	%?dflt 0.0
	/Out1	0.0		def		%?brief Ausgabewert ganze inch	%?use OUT	%?type REAL	%?dflt 0.0
	/Out2	0.0		def		%?brief Ausgabewert ganze feet	%?use OUT	%?type REAL	%?dflt 0.0

	/LD_value 0 def

	In 39.37 mul									% Umrechnung in inch
	/LD_value exch store							% Inch speichern
	% Numerischen Wert runden
	LD_value cvi 0 eq {								% hier wird eine Division durch null verhindert: mod im else-Teil
		LD_value cvi 0.5 ge { 1 }{ 0 } ifelse
	}{
		LD_value LD_value cvi mod 0.5 ge {
			LD_value cvi 1 add
		}{
			LD_value cvi
		} ifelse
	} ifelse
	/LD_value exch store							% Inch gerundet speichern
		
	% Numerischen Wert in feet und inch aufteilen
	LD_value 12 div cvi								% ganze Feet ermitteln
	/Out2 exch store								% Feet speichern
	LD_value Out2 12 mul sub					% verbliebene Inch ermitteln
	/Out1 exch store								% Inch speichern
	
	Out1
	Out2
%?manual_end
} def
%?partend


